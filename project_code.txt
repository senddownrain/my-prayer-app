
### package.json
```
{
  "name": "my-prayer-app",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "export-code": "node export-code.js",
    "db:seed": "node seed-db.js"
  },
  "dependencies": {
    "@mdi/font": "^7.4.47",
    "@tiptap/extension-color": "^3.0.7",
    "@tiptap/extension-text-align": "^3.0.9",
    "@tiptap/extension-text-style": "^3.0.7",
    "@tiptap/pm": "^3.0.7",
    "@tiptap/starter-kit": "^3.0.7",
    "@tiptap/vue-3": "^3.0.7",
    "firebase": "^10.12.2",
    "pinia": "^3.0.3",
    "vue": "^3.4.27",
    "vue-i18n": "^11.1.11",
    "vue-router": "^4.3.3",
    "vuetify": "^3.6.8"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^5.0.5",
    "vite": "^5.2.13",
    "vite-plugin-pwa": "^0.20.5",
    "vite-plugin-vuetify": "^2.0.3"
  }
}

```

### vite.config.js
```
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { VitePWA } from 'vite-plugin-pwa'
// ✅ 1. Импортируем утилиты для работы с путями из Node.js
import { fileURLToPath, URL } from 'node:url'

export default defineConfig({
  plugins: [
    vue(),
    VitePWA({
      // ... секция PWA остается без изменений ...
    })
  ],
  resolve: {
    alias: {
      // ✅ 2. Используем НОВЫЙ синтаксис для определения псевдонима '@'
      '@': fileURLToPath(new URL('./src', import.meta.url))
    },
  },
})
```

### firebase.json
```
{
  "hosting": {
    "public": "dist",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  }
}
```

### index.html
```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <!-- ✅ META-ТЕГИ ДЛЯ PWA -->
    <meta name="theme-color" content="#1867C0">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" sizes="180x180">
    <link rel="mask-icon" href="/mask-icon.svg" color="#FFFFFF">
    
    <title>Мои Молитвы</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
```

### seed-db.js
```
const { initializeApp } = require("firebase/app");
// ✅ --- ФИНАЛЬНОЕ ИСПРАВЛЕНИЕ: Добавил 'doc' в список --- ✅
const { getFirestore, collection, getDocs, writeBatch, addDoc, serverTimestamp, updateDoc, doc } = require("firebase/firestore");

const firebaseConfig = {
  apiKey: "AIzaSyDF2TD4MTcKiBChKRssauvL-nNyT4Am9N0",
  authDomain: "molitwy.firebaseapp.com",
  projectId: "molitwy",
  storageBucket: "molitwy.firebasestorage.app",
  messagingSenderId: "654293224787",
  appId: "1:654293224787:web:5f4fce64abf5ba1b1ea5a6"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

const prayersData = [
  { id: "pater_noster", title: "Отче наш", tags: ["основные"], textVersions: { ru: "<p>Текст...</p>", be: "<p>Тэкст...</p>", la: "<p>Text...</p>" } },
  { id: "ave_maria", title: "Радуйся, Мария", tags: ["основные", "марианские"], textVersions: { ru: "<p>Текст...</p>", be: "<p>Тэкст...</p>", la: "<p>Text...</p>" } },
  { id: "credo", title: "Символ веры", tags: ["основные"], textVersions: { ru: "<p>Текст...</p>", be: "<p>Тэкст...</p>", la: "<p>Text...</p>" }, linkedNoteIds: ["pater_noster", "ave_maria"] },
  { id: "gloria_patri", title: "Слава", tags: ["основные"], textVersions: { ru: "<p>Текст...</p>", be: "<p>Тэкст...</p>", la: "<p>Text...</p>" }, linkedNoteIds: ["pater_noster"] },
];

async function clearCollection(db, collectionPath) {
  const collectionRef = collection(db, collectionPath);
  const snapshot = await getDocs(collectionRef);
  if (snapshot.empty) { console.log(`Коллекция '${collectionPath}' уже пуста.`); return; }
  const batch = writeBatch(db);
  snapshot.docs.forEach(doc => { batch.delete(doc.ref); });
  await batch.commit();
  console.log(`Все документы в коллекции '${collectionPath}' были удалены.`);
}

async function seedDatabase() {
  try {
    console.log("Очистка коллекции 'items'...");
    await clearCollection(db, 'items');
    console.log("Наполнение базы новыми данными...");
    const itemsCollection = collection(db, 'items');
    const addedIds = {};

    for (const prayer of prayersData) {
      const dataToAdd = {
        title: prayer.title,
        tags: prayer.tags,
        textVersions: prayer.textVersions,
        createdAt: serverTimestamp()
      };
      
      const docRef = await addDoc(itemsCollection, dataToAdd);
      addedIds[prayer.id] = docRef.id;
      console.log(`- Добавлена: "${prayer.title}"`);
    }

    console.log("Обновление связей...");
    for (const prayer of prayersData) {
        if (prayer.linkedNoteIds && prayer.linkedNoteIds.length > 0) {
            const realLinkedIds = prayer.linkedNoteIds.map(tempId => addedIds[tempId]);
            const realDocId = addedIds[prayer.id];
            // Теперь и doc(), и updateDoc() импортированы и будут работать
            await updateDoc(doc(db, "items", realDocId), { linkedNoteIds: realLinkedIds });
            console.log(`- Обновлены связи для "${prayer.title}"`);
        }
    }
    console.log("Наполнение базы завершено!");
  } catch (error) {
    console.error("КРИТИЧЕСКАЯ ошибка:", error);
  }
}

seedDatabase();
```

### vite.config.mjs
```

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import vuetify, { transformAssetUrls } from 'vite-plugin-vuetify'
import { VitePWA } from 'vite-plugin-pwa'
import path from 'path' 

export default defineConfig({
  plugins: [
    vue({ 
      template: { transformAssetUrls }
    }),
    vuetify({
      autoImport: true,
    }),
    VitePWA({
      registerType: 'autoUpdate',
      injectRegister: 'auto',
      workbox: {
        globPatterns: ['**/*.{js,css,html,ico,png,svg,json,vue,txt,woff2}'],
        cleanupOutdatedCaches: true,
      },
      manifest: {
        name: 'Мое Vue Приложение',
        short_name: 'VueApp',
        description: 'Простое приложение на Vue, Vuetify и Firebase',
        theme_color: '#ffffff',
        background_color: '#ffffff',
        display: 'standalone',
        start_url: '.',
        icons: [
          {
            src: 'img/icons/icon-192x192.png',
            sizes: '192x192',
            type: 'image/png'
          },
          {
            src: 'img/icons/icon-512x512.png',
            sizes: '512x512',
            type: 'image/png'
          }
        ]
      }
    })
  ],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
})


```

### src/App.vue
```
<template>
  <v-app :theme="settings.currentTheme">
    <v-navigation-drawer v-model="isDrawerOpen" temporary>
      <v-list nav>
        <v-list-item 
          prepend-icon="mdi-format-list-text" 
          :title="$t('allPrayers')"
          @click="navigateToCategory(null)"
        ></v-list-item>
        <v-divider></v-divider>
        <v-list-subheader>Категории</v-list-subheader>
        <v-list-item
          v-for="category in settings.menuCategories"
          :key="category.name"
          prepend-icon="mdi-label-outline"
          :title="category.name"
          @click="navigateToCategory(category)"
        ></v-list-item>
        <v-divider></v-divider>
        
        <!-- ✅ Настройки теперь доступны ВСЕМ пользователям -->
        <v-list-item 
          prepend-icon="mdi-cog-outline" 
          :title="$t('settings')"
          :to="{ name: 'Settings' }"
        ></v-list-item>

        <!-- Ссылки, видимые только администратору -->
        <v-list-item 
          v-if="authStore.user"
          prepend-icon="mdi-shield-crown-outline" 
          title="Админка"
          :to="{ name: 'Admin' }"
        ></v-list-item>
        
        <!-- Общие ссылки -->
        <v-list-item 
          prepend-icon="mdi-information-outline" 
          title="О нас"
          :to="{ name: 'About' }"
        ></v-list-item>
        <v-divider></v-divider>

        <!-- Кнопка Выход / Вход -->
        <v-list-item
          v-if="authStore.user"
          prepend-icon="mdi-logout"
          title="Выход"
          @click="handleLogout"
        ></v-list-item>
         <v-list-item
          v-else
          prepend-icon="mdi-login"
          title="Вход"
          :to="{ name: 'Login' }"
        ></v-list-item>
      </v-list>
    </v-navigation-drawer>

    <v-app-bar :elevation="2" app>
        <v-btn v-if="!appBar.showBackButton" icon="mdi-menu" @click="isDrawerOpen = !isDrawerOpen"></v-btn>
        <v-btn v-else icon="mdi-arrow-left" @click="router.back()"></v-btn>
        
        <v-expand-x-transition>
            <v-text-field
                v-if="isSearchActive"
                v-model="search"
                :placeholder="$t('searchPlaceholder')"
                variant="solo-inverted"
                flat
                hide-details
                autofocus
                density="compact"
                @blur="isSearchActive = false; search = ''"
            ></v-text-field>
        </v-expand-x-transition>

        <v-toolbar-title v-if="!isSearchActive">
            {{ appBar.title }}
        </v-toolbar-title>

        <v-spacer v-if="!isSearchActive"></v-spacer>

        <template v-if="!isSearchActive">
            <v-btn v-if="appBar.isSearchVisible" icon="mdi-magnify" @click="isSearchActive = true"></v-btn>
            <v-btn v-for="action in appBar.actions" :key="action.icon" :icon="action.icon" @click="action.onClick"></v-btn>
        </template>
    </v-app-bar>

    <v-main>
      <router-view />
      <FilterSheet />
    </v-main>

    <NotificationSnackbar ref="snackbar" />
  </v-app>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import { useRouter } from 'vue-router';
import { useSettingsStore } from '@/stores/settings';
import { useAppBar } from '@/composables/useAppBar';
import { useFilters } from '@/composables/useFilters';
import { useAuthStore } from '@/stores/auth';
import { notifier } from '@/composables/useNotifier';
import FilterSheet from '@/components/FilterSheet.vue';
import NotificationSnackbar from '@/components/NotificationSnackbar.vue';

const settings = useSettingsStore();
const router = useRouter();
const authStore = useAuthStore();

const { appBar, isDrawerOpen, isSearchActive } = useAppBar();
const { selectedTags, search } = useFilters();
const snackbar = ref(null);

onMounted(() => {
  notifier.value = snackbar.value;
});

function navigateToCategory(category) {
  selectedTags.value = category ? (category.tags || []) : [];
  
  if (router.currentRoute.value.name !== 'ItemsList') {
    router.push({ name: 'ItemsList' });
  }
  
  isDrawerOpen.value = false;
}

// ✅ Добавляем отдельную функцию для выхода, чтобы закрывать меню
async function handleLogout() {
    isDrawerOpen.value = false;
    await authStore.logout();
}
</script>
```

### src/components/AboutView.vue
```
<template>
  <v-container>
    <v-card>
      <v-card-title class="text-h5">О приложении</v-card-title>
      <v-card-text>
        <p>Это приложение создано для личного сбора молитв и заметок.</p>
        <p class="mt-4">Версия: 1.0.0</p>
        <p>Разработано с любовью.</p>
      </v-card-text>
    </v-card>
  </v-container>
</template>

<script setup>
import { onMounted } from 'vue';
import { useAppBar } from '@/composables/useAppBar';
const { setAppBar } = useAppBar();
onMounted(() => {
  setAppBar({ title: 'О нас', showBackButton: true, isMenu: true });
});
</script>
```

### src/components/AdminView.vue
```
<template>
  <v-container>
    <v-card>
      <v-card-title class="text-h5">Админка</v-card-title>
      <v-card-text>
        <p>
          Здесь будет панель администратора.
          <br>
          Пока это лишь заготовка для будущих функций.
        </p>
        <v-alert type="warning" variant="outlined" class="mt-4">
          Сейчас приложение работает в локальном режиме. Любой пользователь может редактировать данные. Для реализации полноценного администрирования потребуется система аутентификации.
        </v-alert>
      </v-card-text>
    </v-card>
  </v-container>
</template>

<script setup>
import { onMounted } from 'vue';
import { useAppBar } from '@/composables/useAppBar';
const { setAppBar } = useAppBar();
onMounted(() => {
  setAppBar({ title: 'Админка', showBackButton: true, isMenu: true });
});
</script>
```

### src/components/Editor.vue
```
<template>
  <div v-if="editor" class="editor-container">
    <!-- ✅ ОБНОВЛЕННАЯ ПАНЕЛЬ ИНСТРУМЕНТОВ -->
    <div class="editor-toolbar">
      <!-- Выпадающий список для стилей -->
      <v-menu offset-y>
        <template v-slot:activator="{ props }">
          <v-btn v-bind="props" density="compact" class="mr-2" style="min-width: 130px;">
            {{ currentStyleLabel }}
            <v-icon right>mdi-menu-down</v-icon>
          </v-btn>
        </template>
        <v-list density="compact">
          <v-list-item @click="editor.chain().focus().setParagraph().run()" :active="editor.isActive('paragraph')">
            <v-list-item-title>{{ $t('style.normal') }}</v-list-item-title>
          </v-list-item>
          <v-list-item @click="editor.chain().focus().toggleHeading({ level: 2 }).run()" :active="editor.isActive('heading', { level: 2 })">
            <v-list-item-title>{{ $t('style.h2') }}</v-list-item-title>
          </v-list-item>
          <v-list-item @click="editor.chain().focus().toggleHeading({ level: 3 }).run()" :active="editor.isActive('heading', { level: 3 })">
            <v-list-item-title>{{ $t('style.h3') }}</v-list-item-title>
          </v-list-item>
           <v-list-item @click="editor.chain().focus().toggleRubric().run()" :active="editor.isActive('rubric')">
            <v-list-item-title>{{ $t('style.rubric') }}</v-list-item-title>
          </v-list-item>
        </v-list>
      </v-menu>

      <v-divider vertical class="mx-1"></v-divider>

      <!-- Кнопки форматирования -->
      <v-btn-toggle multiple density="compact" variant="text">
        <v-btn @click="editor.chain().focus().toggleBold().run()" :class="{ 'v-btn--active': editor.isActive('bold') }" icon="mdi-format-bold"></v-btn>
        <v-btn @click="editor.chain().focus().toggleItalic().run()" :class="{ 'v-btn--active': editor.isActive('italic') }" icon="mdi-format-italic"></v-btn>
      </v-btn-toggle>

      <v-divider vertical class="mx-1"></v-divider>

       <!-- Списки -->
      <v-btn-toggle multiple density="compact" variant="text">
        <v-btn @click="editor.chain().focus().toggleBulletList().run()" :class="{ 'v-btn--active': editor.isActive('bulletList') }" icon="mdi-format-list-bulleted"></v-btn>
        <v-btn @click="editor.chain().focus().toggleOrderedList().run()" :class="{ 'v-btn--active': editor.isActive('orderedList') }" icon="mdi-format-list-numbered"></v-btn>
      </v-btn-toggle>
       <v-divider vertical class="mx-1"></v-divider>
      <!-- Выравнивание -->
      <v-btn-toggle multiple density="compact" variant="text">
        <v-btn @click="editor.chain().focus().setTextAlign('left').run()" :class="{ 'v-btn--active': editor.isActive({ textAlign: 'left' }) }" icon="mdi-format-align-left"></v-btn>
        <v-btn @click="editor.chain().focus().setTextAlign('center').run()" :class="{ 'v-btn--active': editor.isActive({ textAlign: 'center' }) }" icon="mdi-format-align-center"></v-btn>
        <v-btn @click="editor.chain().focus().setTextAlign('justify').run()" :class="{ 'v-btn--active': editor.isActive({ textAlign: 'justify' }) }" icon="mdi-format-align-justify"></v-btn>
      </v-btn-toggle>

    </div>

    <editor-content :editor="editor" />
  </div>
</template>

<script setup>
import { computed, watch, onBeforeUnmount, ref } from 'vue';
import { useEditor, EditorContent } from '@tiptap/vue-3';
import StarterKit from '@tiptap/starter-kit';
import TextAlign from '@tiptap/extension-text-align';
import { Paragraph } from '@tiptap/extension-paragraph';
import { Node } from '@tiptap/core';
import { useI18n } from 'vue-i18n';

const { t } = useI18n();
const props = defineProps({ modelValue: { type: String, default: '' } });
const emit = defineEmits(['update:modelValue']);

// ✅ Пользовательское расширение для Рубрики
const Rubric = Node.create({
  name: 'rubric',
  group: 'block',
  content: 'inline*',
  parseHTML() { return [{ tag: 'p.rubric', class: 'rubric' }]; },
  renderHTML({ HTMLAttributes }) { return ['p', { ...HTMLAttributes, class: 'rubric' }, 0]; },
  addCommands() {
    return {
      toggleRubric: () => ({ commands, state }) => {
        const isActive = this.editor.isActive('rubric');
        if (isActive) {
          return commands.setNode('paragraph');
        }
        return commands.setNode(this.name);
      },
    };
  },
});

const editor = useEditor({
  content: props.modelValue,
  extensions: [
    StarterKit.configure({
      heading: { levels: [2, 3] }, // Заголовки h2 и h3
      paragraph: false, // Отключаем стандартный, чтобы добавить свой
    }),
    Paragraph, // Добавляем стандартный параграф
    TextAlign.configure({ types: ['heading', 'paragraph', 'rubric'] }),
    Rubric, // Наше расширение для рубрик
  ],
  onUpdate: () => {
    emit('update:modelValue', editor.value.getHTML());
  },
});

// ✅ Логика для отображения текущего стиля в кнопке
const currentStyleLabel = computed(() => {
  if (!editor.value) return '';
  if (editor.value.isActive('heading', { level: 2 })) return t('style.h2');
  if (editor.value.isActive('heading', { level: 3 })) return t('style.h3');
  if (editor.value.isActive('rubric')) return t('style.rubric');
  return t('style.normal');
});


watch(() => props.modelValue, (value) => {
  if (editor.value && editor.value.getHTML() !== value) {
    editor.value.commands.setContent(value, false);
  }
});

onBeforeUnmount(() => {
  if (editor.value) {
    editor.value.destroy();
  }
});
</script>
```

### src/components/FilterSheet.vue
```
<template>
  <v-bottom-sheet v-model="isFilterSheetOpen">
    <v-card class="pa-4">
      <v-card-title>{{ $t('filterByTags') }}</v-card-title>
      <v-card-text>
        <div v-if="allTags.length === 0" class="text-grey pa-2">Нет тегов для выбора</div>
        <v-chip-group v-else v-model="selectedTags" column multiple>
          <v-chip
            v-for="tag in allTags"
            :key="tag"
            :value="tag"
            filter
            variant="outlined"
            class="ma-1"
            size="large"
          >
            {{ tag }}
          </v-chip>
        </v-chip-group>
      </v-card-text>
      <v-card-actions>
        <v-spacer></v-spacer>
        <v-btn color="primary" variant="text" @click="isFilterSheetOpen = false">{{ $t('done') }}</v-btn>
      </v-card-actions>
    </v-card>
  </v-bottom-sheet>
</template>

<script setup>
import { useAppBar } from '@/composables/useAppBar';
import { useFilters } from '@/composables/useFilters';
import { useItems } from '@/composables/useItems';

const { isFilterSheetOpen } = useAppBar();
const { selectedTags } = useFilters();
const { allTags } = useItems();
</script>
```

### src/components/ItemForm.vue
```
<template>
  <v-container>
    <v-form v-if="isFormReady" @submit.prevent="handleSave">
      <v-text-field v-model="form.title" :label="$t('title')" variant="outlined" class="mb-4"></v-text-field>
      <v-text-field v-model="form.source" :label="$t('source')" variant="outlined" class="mb-4" clearable></v-text-field>

      <v-tabs v-model="currentLangTab" bg-color="primary" class="mb-1">
        <v-tab value="be">Бел</v-tab>
        <v-tab value="ru">Рус</v-tab>
        <v-tab value="la">Lat</v-tab>
      </v-tabs>
      
      <v-window v-model="currentLangTab">
        <v-window-item value="be"><Editor v-model="form.textVersions.be" /></v-window-item>
        <v-window-item value="ru"><Editor v-model="form.textVersions.ru" /></v-window-item>
        <v-window-item value="la"><Editor v-model="form.textVersions.la" /></v-window-item>
      </v-window>

      <v-combobox
        v-model="form.tags"
        :items="allTags"
        :label="$t('tags')"
        multiple
        chips
        clearable
        variant="outlined"
        class="mt-4"
      ></v-combobox>

      <v-divider class="my-4"></v-divider>
      <h3 class="text-subtitle-1 mb-2">Связанные заметки</h3>
      <div v-if="form.linkedNoteIds && form.linkedNoteIds.length > 0" class="mb-3">
        <v-chip
          v-for="linkedNote in currentlyLinkedNotes"
          :key="linkedNote.id"
          class="mr-2 mb-2"
          closable
          @click:close="removeLink(linkedNote.id)"
        >
          {{ linkedNote.title }}
        </v-chip>
      </div>
      <v-btn @click="isLinkDialogOpen = true" prepend-icon="mdi-link-plus">Добавить связь</v-btn>
    </v-form>

    <div v-else class="text-center mt-16">
      <v-progress-circular indeterminate color="primary"></v-progress-circular>
    </div>

    <v-dialog v-model="isLinkDialogOpen" max-width="500px">
      <v-card>
        <v-card-title>Выберите заметку для связи</v-card-title>
        <v-list>
          <v-list-item
            v-for="note in availableNotesToLink"
            :key="note.id"
            :title="note.title"
            @click="addLink(note.id)"
          ></v-list-item>
        </v-list>
      </v-card>
    </v-dialog>
  </v-container>
</template>

<script setup>
import { ref, watch, onMounted, onUnmounted, computed } from 'vue';
import { useRouter } from 'vue-router';
import { useItems } from '@/composables/useItems';
import { useAppBar } from '@/composables/useAppBar';
import Editor from '@/components/Editor.vue';
import { useI18n } from 'vue-i18n';
import { useNotifier } from '@/composables/useNotifier';

const props = defineProps({ id: { type: String, required: false } });
const router = useRouter();
const { t } = useI18n();
const { items, addItem, updateItem, allTags } = useItems();
const { setAppBar, resetAppBar } = useAppBar();
const { showSuccess } = useNotifier();
const isEditMode = computed(() => !!props.id);
const isFormReady = ref(false);
const currentLangTab = ref('be');

const form = ref({
  title: '',
  source: '',
  textVersions: { ru: '', be: '', la: '' },
  tags: [],
  linkedNoteIds: []
});

const isLinkDialogOpen = ref(false);
const currentlyLinkedNotes = computed(() => form.value.linkedNoteIds?.map(id => items.value.find(item => item.id === id)).filter(Boolean) || []);
const availableNotesToLink = computed(() => items.value.filter(item => item.id !== props.id && !form.value.linkedNoteIds?.includes(item.id)));

function addLink(noteId) { form.value.linkedNoteIds.push(noteId); isLinkDialogOpen.value = false; }
function removeLink(noteId) { form.value.linkedNoteIds = form.value.linkedNoteIds.filter(id => id !== noteId); }

async function handleSave() {
  if (!form.value.title) return;
  const dataToSave = {
    title: form.value.title,
    source: form.value.source || '',
    textVersions: form.value.textVersions,
    tags: form.value.tags,
    linkedNoteIds: form.value.linkedNoteIds || []
  };

  if (isEditMode.value) {
    await updateItem(props.id, dataToSave);
  } else {
    await addItem(dataToSave);
  }
  showSuccess('Заметка успешно сохранена!');
  router.push({ name: 'ItemsList' });
}

onMounted(() => {
  setAppBar({
    title: isEditMode.value ? t('editing') : t('newNote'),
    showBackButton: true,
    actions: [{ icon: 'mdi-check', onClick: handleSave }]
  });

  if (isEditMode.value) {
    // ✅ ИСПРАВЛЕНИЕ: Мы объявляем переменную stopWatch заранее, чтобы избежать ошибки.
    let stopWatch;
    stopWatch = watch(items, (newItems) => {
      const itemToEdit = newItems.find(i => i.id === props.id);
      if (itemToEdit) {
        form.value = { 
          ...itemToEdit,
          source: itemToEdit.source || '',
          tags: itemToEdit.tags || [],
          textVersions: itemToEdit.textVersions || { ru: '', be: '', la: '' },
          linkedNoteIds: itemToEdit.linkedNoteIds || []
        };
        isFormReady.value = true;
        // Теперь мы можем безопасно вызвать stopWatch, так как он уже определен.
        if(stopWatch) stopWatch();
      }
    }, { immediate: true });
  } else {
    isFormReady.value = true;
  }
});

onUnmounted(resetAppBar);
</script>
```

### src/components/ItemsList.vue
```
<template>
  <v-container>
    <v-form v-if="isFormReady" @submit.prevent="handleSave">
      <v-text-field v-model="form.title" :label="$t('title')" variant="outlined" class="mb-4"></v-text-field>
      <v-text-field v-model="form.source" :label="$t('source')" variant="outlined" class="mb-4" clearable></v-text-field>

      <v-tabs v-model="currentLangTab" bg-color="primary" class="mb-1">
        <v-tab value="be">Бел</v-tab>
        <v-tab value="ru">Рус</v-tab>
        <v-tab value="la">Lat</v-tab>
      </v-tabs>
      
      <v-window v-model="currentLangTab">
        <v-window-item value="be"><Editor v-model="form.textVersions.be" /></v-window-item>
        <v-window-item value="ru"><Editor v-model="form.textVersions.ru" /></v-window-item>
        <v-window-item value="la"><Editor v-model="form.textVersions.la" /></v-window-item>
      </v-window>

      <v-combobox
        v-model="form.tags"
        :items="allTags"
        :label="$t('tags')"
        multiple
        chips
        clearable
        variant="outlined"
        class="mt-4"
      ></v-combobox>

      <v-divider class="my-4"></v-divider>
      <h3 class="text-subtitle-1 mb-2">Связанные заметки</h3>
      <div v-if="form.linkedNoteIds && form.linkedNoteIds.length > 0" class="mb-3">
        <v-chip
          v-for="linkedNote in currentlyLinkedNotes"
          :key="linkedNote.id"
          class="mr-2 mb-2"
          closable
          @click:close="removeLink(linkedNote.id)"
        >
          {{ linkedNote.title }}
        </v-chip>
      </div>
      <v-btn @click="isLinkDialogOpen = true" prepend-icon="mdi-link-plus">Добавить связь</v-btn>
    </v-form>

    <div v-else class="text-center mt-16">
      <v-progress-circular indeterminate color="primary"></v-progress-circular>
    </div>

    <v-dialog v-model="isLinkDialogOpen" max-width="500px">
      <v-card>
        <v-card-title>Выберите заметку для связи</v-card-title>
        <v-list>
          <v-list-item
            v-for="note in availableNotesToLink"
            :key="note.id"
            :title="note.title"
            @click="addLink(note.id)"
          ></v-list-item>
        </v-list>
      </v-card>
    </v-dialog>
  </v-container>
</template>

<script setup>
import { ref, watch, onMounted, onUnmounted, computed } from 'vue';
import { useRouter } from 'vue-router';
import { useItems } from '@/composables/useItems';
import { useAppBar } from '@/composables/useAppBar';
import Editor from '@/components/Editor.vue';
import { useI18n } from 'vue-i18n';
import { useNotifier } from '@/composables/useNotifier';

const props = defineProps({ id: { type: String, required: false } });
const router = useRouter();
const { t } = useI18n();
const { items, addItem, updateItem, allTags } = useItems();
const { setAppBar, resetAppBar } = useAppBar();
const { showSuccess } = useNotifier();
const isEditMode = computed(() => !!props.id);
const isFormReady = ref(false);
const currentLangTab = ref('be');

const form = ref({
  title: '',
  source: '',
  textVersions: { ru: '', be: '', la: '' },
  tags: [],
  linkedNoteIds: []
});

const isLinkDialogOpen = ref(false);
const currentlyLinkedNotes = computed(() => form.value.linkedNoteIds?.map(id => items.value.find(item => item.id === id)).filter(Boolean) || []);
const availableNotesToLink = computed(() => items.value.filter(item => item.id !== props.id && !form.value.linkedNoteIds?.includes(item.id)));

function addLink(noteId) { form.value.linkedNoteIds.push(noteId); isLinkDialogOpen.value = false; }
function removeLink(noteId) { form.value.linkedNoteIds = form.value.linkedNoteIds.filter(id => id !== noteId); }

async function handleSave() {
  if (!form.value.title) return;
  const dataToSave = {
    title: form.value.title,
    source: form.value.source || '',
    textVersions: form.value.textVersions,
    tags: form.value.tags,
    linkedNoteIds: form.value.linkedNoteIds || []
  };

  if (isEditMode.value) {
    await updateItem(props.id, dataToSave);
  } else {
    await addItem(dataToSave);
  }
  showSuccess('Заметка успешно сохранена!');
  router.push({ name: 'ItemsList' });
}

onMounted(() => {
  setAppBar({
    title: isEditMode.value ? t('editing') : t('newNote'),
    showBackButton: true,
    actions: [{ icon: 'mdi-check', onClick: handleSave }]
  });

  if (isEditMode.value) {
    // ✅ ИСПРАВЛЕНИЕ: Мы объявляем переменную stopWatch заранее, чтобы избежать ошибки.
    let stopWatch;
    stopWatch = watch(items, (newItems) => {
      const itemToEdit = newItems.find(i => i.id === props.id);
      if (itemToEdit) {
        form.value = { 
          ...itemToEdit,
          source: itemToEdit.source || '',
          tags: itemToEdit.tags || [],
          textVersions: itemToEdit.textVersions || { ru: '', be: '', la: '' },
          linkedNoteIds: itemToEdit.linkedNoteIds || []
        };
        isFormReady.value = true;
        // Теперь мы можем безопасно вызвать stopWatch, так как он уже определен.
        if(stopWatch) stopWatch();
      }
    }, { immediate: true });
  } else {
    isFormReady.value = true;
  }
});

onUnmounted(resetAppBar);
</script>
```

### src/components/ItemView.vue
```
<template>
  <v-container>
    <!-- ✅ Улучшенная логика отображения -->
    <div v-if="!isLoading && item">
      <h2 class="text-h5 font-weight-bold mb-4">{{ item.title }}</h2>
      <div v-for="(text, lang) in availableVersions" :key="lang" class="mb-4">
        <h2 class="text-h6 font-weight-medium text-grey-darken-1 mb-2">{{ langNames[lang] }}</h2>
        <div v-html="text" class="note-content-area ProseMirror"></div>
      </div>
      <div v-if="linkedNotes.length > 0" class="mt-8">
        <v-divider class="mb-4"></v-divider>
        <h3 class="text-subtitle-1 font-weight-bold mb-3">Связанные заметки:</h3>
        <v-list density="compact" class="pa-0 linked-notes-list">
          <v-list-item
            v-for="linkedNote in linkedNotes"
            :key="linkedNote.id"
            @click="router.push({ name: 'ItemView', params: { id: linkedNote.id } })"
            class="pa-0 mb-2"
          >
            <template v-slot:prepend><v-icon color="grey" class="mr-2">mdi-link-variant</v-icon></template>
            <v-list-item-title class="text-wrap font-weight-medium">{{ linkedNote.title }}</v-list-item-title>
          </v-list-item>
        </v-list>
      </div>
      <div class="mt-6 text-body-2 text-medium-emphasis">
        <div v-if="item.source">
          <v-divider class="my-3"></v-divider>
          <strong>Источник:</strong> {{ item.source }}
        </div>
        <div v-if="item.tags && item.tags.length > 0" class="mt-3">
          <strong>Теги:</strong> {{ item.tags.join(', ') }}
        </div>
      </div>
    </div>
    <!-- ✅ Состояние "не найдено" -->
    <div v-else-if="!isLoading && !item" class="text-center mt-16">
        <v-icon size="64" class="mb-4">mdi-file-question-outline</v-icon>
        <h2 class="text-h5 mb-4">Заметка не найдена</h2>
        <p class="text-medium-emphasis mb-6">Возможно, она была удалена или ссылка неверна.</p>
        <v-btn color="primary" :to="{ name: 'ItemsList' }">Вернуться на главную</v-btn>
    </div>
    <!-- ✅ Состояние загрузки -->
    <div v-else class="text-center text-grey-darken-1 mt-16">
      <v-progress-circular indeterminate color="primary"></v-progress-circular>
    </div>
  </v-container>
</template>

<script setup>
import { computed, watch, onMounted, onUnmounted } from 'vue';
import { useRouter } from 'vue-router';
import { useItems } from '@/composables/useItems';
import { useAppBar } from '@/composables/useAppBar';
import { useAuthStore } from '@/stores/auth';

const props = defineProps({ id: { type: String, required: true } });
const router = useRouter();
const { items, isLoading } = useItems(); // ✅ Получаем isLoading
const { setAppBar, resetAppBar } = useAppBar();
const authStore = useAuthStore(); // ✅ Получаем хранилище авторизации

const item = computed(() => items.value.find(i => i.id === props.id));
const linkedNotes = computed(() => item.value?.linkedNoteIds?.map(id => items.value.find(note => note.id === id)).filter(Boolean) || []);
const availableVersions = computed(() => item.value ? Object.fromEntries(Object.entries(item.value.textVersions).filter(([_, v]) => v)) : {});
const langNames = { ru: 'Русский', be: 'Беларуская', la: 'Latina' };

const updateAppBarForItem = (currentItem) => {
  if (currentItem) {
    setAppBar({
      title: currentItem.title,
      showBackButton: true,
      // ✅ Кнопка редактирования видна только администратору
      actions: authStore.user ? [{ icon: 'mdi-pencil', onClick: () => router.push({ name: 'ItemEdit', params: { id: currentItem.id } }) }] : []
    });
  }
};

onMounted(() => {
  watch(item, updateAppBarForItem, { immediate: true });
});

onUnmounted(resetAppBar);
</script>
```

### src/components/LoginView.vue
```
<template>
  <v-container class="fill-height justify-center">
    <v-card width="100%" max-width="400">
      <v-card-title class="text-center text-h5 py-4">Вход для администратора</v-card-title>
      <v-card-text>
        <v-form @submit.prevent="handleLogin">
          <v-text-field
            v-model="email"
            label="Email"
            type="email"
            variant="outlined"
            class="mb-2"
            :rules="[v => !!v || 'Email обязателен']"
            required
          ></v-text-field>
          <v-text-field
            v-model="password"
            label="Пароль"
            type="password"
            variant="outlined"
            :rules="[v => !!v || 'Пароль обязателен']"
            required
          ></v-text-field>
          <v-alert v-if="error" type="error" density="compact" class="mt-4" text>{{ error }}</v-alert>
          <v-btn type="submit" color="primary" block size="large" class="mt-6" :loading="isLoggingIn">Войти</v-btn>
        </v-form>
      </v-card-text>
    </v-card>
  </v-container>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import { useAuthStore } from '@/stores/auth';
import { useAppBar } from '@/composables/useAppBar';

const email = ref('');
const password = ref('');
const error = ref(null);
const isLoggingIn = ref(false);

const authStore = useAuthStore();
const { setAppBar } = useAppBar();

const handleLogin = async () => {
  isLoggingIn.value = true;
  error.value = null;
  try {
    await authStore.login(email.value, password.value);
  } catch (e) {
    error.value = 'Неверный email или пароль.';
  } finally {
    isLoggingIn.value = false;
  }
};

onMounted(() => {
    setAppBar({ title: 'Вход', showBackButton: false });
});
</script>
```

### src/components/NotificationSnackbar.vue
```
<template>
  <v-snackbar
    v-model="visible"
    :color="color"
    :timeout="timeout"
    location="bottom right"
    variant="elevated"
  >
    {{ message }}
    <template v-slot:actions>
      <v-btn icon="mdi-close" @click="hide"></v-btn>
    </template>
  </v-snackbar>
</template>

<script setup>
import { ref } from 'vue';

const visible = ref(false);
const message = ref('');
const color = ref('success');
const timeout = ref(3000);

// Глобальная функция для показа уведомления
function show(newMessage, newColor = 'success') {
  message.value = newMessage;
  color.value = newColor;
  visible.value = true;
}

function hide() {
  visible.value = false;
}

// Делаем функцию show доступной извне через ref
defineExpose({ show });
</script>
```

### src/components/SettingsView.vue
```
<template>
  <v-container>
    <v-list lines="two" subheader>
      <v-list-subheader>{{ $t('appearance') }}</v-list-subheader>
      <v-list-item :title="$t('viewMode')" :subtitle="$t('viewModeHint')">
        <template v-slot:prepend><v-icon>mdi-view-dashboard-outline</v-icon></template>
        <template v-slot:append>
          <v-btn-toggle :model-value="settings.viewMode" @update:model-value="settings.toggleViewMode" mandatory variant="outlined" density="compact">
            <v-btn value="card"><v-icon>mdi-view-grid</v-icon></v-btn>
            <v-btn value="compact"><v-icon>mdi-view-list</v-icon></v-btn>
          </v-btn-toggle>
        </template>
      </v-list-item>
      <v-list-item :title="$t('darkTheme')" :subtitle="$t('themeIs', { themeName: $t('themeNames.' + settings.currentTheme) })">
        <template v-slot:prepend><v-icon>mdi-theme-light-dark</v-icon></template>
        <template v-slot:append><v-switch :model-value="settings.currentTheme === 'dark'" @update:model-value="settings.toggleTheme" inset color="primary" hide-details></v-switch></template>
      </v-list-item>
      <v-list-item :title="$t('fontSize')" :subtitle="$t('fontSizeHint')">
        <template v-slot:prepend><v-icon>mdi-format-font-size-increase</v-icon></template>
        <template v-slot:append>
          <div class="d-flex align-center">
            <v-btn icon="mdi-minus" variant="text" size="small" @click="settings.decreaseFontSize" :disabled="settings.fontSizeMultiplier <= 0.8"></v-btn>
            <span class="mx-2 font-weight-bold" style="width: 40px; text-align: center;">{{ Math.round(settings.fontSizeMultiplier * 100) }}%</span>
            <v-btn icon="mdi-plus" variant="text" size="small" @click="settings.increaseFontSize" :disabled="settings.fontSizeMultiplier >= 1.5"></v-btn>
          </div>
        </template>
      </v-list-item>
    </v-list>
    <v-divider class="my-4"></v-divider>
    <v-card variant="outlined" class="pa-4">
      <h3 class="v-list-subheader pa-0 mb-2">{{ $t('preview') }}</h3>
      <div class="note-content-area mt-2">
        <p class="text-body-1">Это пример обычного текста. Вы можете видеть, как он изменяется в реальном времени.</p>
        <p class="text-caption mt-2">А это — текст поменьше, для примера.</p>
      </div>
    </v-card>
    <v-divider class="my-4"></v-divider>
    <v-list>
      <v-list-subheader>{{ $t('language') }}</v-list-subheader>
      <v-list-item>
        <v-select
          :label="$t('language')" :items="[{value: 'ru', title: 'Русский'}, {value: 'be', title: 'Беларуская'}]"
          :model-value="settings.currentLanguage" @update:model-value="settings.setLanguage"
          variant="outlined" density="compact" hide-details
        ></v-select>
      </v-list-item>
    </v-list>
     <!-- ✅ --- ОБНОВЛЕННЫЙ РАЗДЕЛ: НАСТРОЙКА КАТЕГОРИЙ --- ✅ -->
    <v-divider class="my-4"></v-divider>
    <v-list-subheader>Категории в меню</v-list-subheader>
    <v-list-item v-for="(cat, index) in settings.menuCategories" :key="index">
      <v-list-item-title>{{ cat.name }}</v-list-item-title>
       <!-- ✅ Отображаем все теги для категории -->
      <v-list-item-subtitle>Фильтр по тегам: `{{ cat.tags?.join(', ') }}`</v-list-item-subtitle>
      <template v-slot:append>
        <v-btn icon="mdi-delete-outline" variant="text" color="grey" @click="settings.removeCategory(index)"></v-btn>
      </template>
    </v-list-item>
    <v-card variant="tonal" class="pa-4 mt-4">
      <h3 class="text-subtitle-1 mb-3">Добавить категорию</h3>
      <v-form @submit.prevent="onAddCategory">
        <v-text-field v-model="newCategory.name" label="Название категории" density="compact" variant="solo-filled" flat></v-text-field>
        <!-- ✅ Заменяем v-autocomplete на v-combobox с multiple -->
        <v-combobox
          v-model="newCategory.tags"
          :items="allTags"
          label="Выберите или введите теги"
          density="compact"
          variant="solo-filled"
          flat
          multiple
          chips
          clearable
          class="mt-2"
        ></v-combobox>
        <v-btn type="submit" color="primary" block class="mt-2">Добавить</v-btn>
      </v-form>
    </v-card>
  </v-container>
</template>
<script setup>
import { onMounted, ref } from 'vue';
import { useAppBar } from '@/composables/useAppBar';
import { useSettingsStore } from '@/stores/settings';
import { useItems } from '@/composables/useItems';
const { setAppBar } = useAppBar();
const settings = useSettingsStore();
const { allTags } = useItems(); // Получаем все доступные теги
// ✅ newCategory теперь содержит массив tags
const newCategory = ref({ name: '', tags: [] });

function onAddCategory() {
  if (newCategory.value.name && newCategory.value.tags.length > 0) {
    settings.addCategory({ ...newCategory.value });
    newCategory.value = { name: '', tags: [] }; // Сбрасываем форму
  }
}
onMounted(() => {
  setAppBar({ title: 'Настройки', showBackButton: true });
});
</script>
```

### src/composables/useAppBar.js
```
import { ref } from 'vue';

// Глобальные реактивные переменные
const appBar = ref({
  title: 'Мои Молитвы',
  showBackButton: false,
  isSearchVisible: false, // Показывать ли иконку поиска
  actions: []
});

const isDrawerOpen = ref(false);
const isSearchActive = ref(false); // Активен ли режим поиска (поле ввода на весь appbar)
// ✅ Добавляем глобальную переменную для состояния шторки фильтра
const isFilterSheetOpen = ref(false);

export function useAppBar() {
  const setAppBar = (config) => {
    appBar.value.title = config.title || 'Мои Молитвы';
    appBar.value.showBackButton = config.showBackButton || false;
    appBar.value.isSearchVisible = config.isSearchVisible || false;
    appBar.value.actions = config.actions || [];
  };

  const resetAppBar = () => {
    // Сброс к состоянию по умолчанию для главного экрана
    setAppBar({
      title: 'Мои Молитвы',
      isSearchVisible: true,
      actions: []
    });
  };

  return { 
    appBar, 
    isDrawerOpen, 
    isSearchActive, 
    isFilterSheetOpen,
    setAppBar, 
    resetAppBar 
  };
}
```

### src/composables/useFilters.js
```
import { ref } from 'vue';

// Создаем реактивные переменные для наших фильтров
const search = ref('');
const selectedTags = ref([]);

// Экспортируем функцию, которая будет предоставлять доступ
// к этим переменным в любом компоненте
export function useFilters() {
  return {
    search,
    selectedTags,
  };
}
```

### src/composables/useItems.js
```
import { ref, computed } from 'vue';
import { db } from '@/firebase';
import { 
  collection, 
  onSnapshot, 
  addDoc, 
  deleteDoc, 
  updateDoc, 
  doc,
  serverTimestamp,
  query,
  orderBy
} from 'firebase/firestore';
import { useSettingsStore } from '@/stores/settings';

const items = ref([]);
const allTags = ref([]);
const isLoading = ref(true); // ✅ Добавляем состояние загрузки

const itemsCollection = collection(db, 'items');
const itemsQuery = query(itemsCollection, orderBy('createdAt', 'desc'));

onSnapshot(itemsQuery, (snapshot) => {
  items.value = snapshot.docs.map(doc => ({
    id: doc.id,
    ...doc.data()
  }));
  allTags.value = [...new Set(items.value.flatMap(item => item.tags || []))].sort();
  isLoading.value = false; // ✅ Выключаем загрузку, когда данные получены
}, (error) => {
  console.error("Ошибка получения данных из Firestore: ", error);
  isLoading.value = false;
});

export function useItems() {
  const settings = useSettingsStore();

  // ✅ Создаем вычисляемое свойство для сортировки по закрепленным заметкам
  const sortedItems = computed(() => {
    if (!items.value) return [];
    return [...items.value].sort((a, b) => (settings.isPinned(b.id) - settings.isPinned(a.id)));
  });

  const addItem = async (data) => {
    const docRef = await addDoc(itemsCollection, {
      ...data,
      createdAt: serverTimestamp()
    });
    return docRef;
  };

  const deleteItem = async (id) => {
    await deleteDoc(doc(db, 'items', id));
  };

  const updateItem = async (id, data) => {
    const dataToUpdate = { ...data };
    delete dataToUpdate.id; 
    await updateDoc(doc(db, 'items', id), dataToUpdate);
  };

  return {
    items: sortedItems, // ✅ Экспортируем уже отсортированный массив
    allTags,
    isLoading, // ✅ Экспортируем состояние загрузки
    addItem,
    deleteItem,
    updateItem,
  };
}
```

### src/composables/useNotifier.js
```
import { ref } from 'vue';

// Эта переменная будет хранить ссылку на наш компонент уведомлений
export const notifier = ref(null);

export function useNotifier() {
  const showSuccess = (message) => {
    if (notifier.value) {
      notifier.value.show(message, 'success');
    }
  };

  const showError = (message) => {
    if (notifier.value) {
      notifier.value.show(message, 'error');
    }
  };

  return { showSuccess, showError };
}   
```

### src/export-code.js
```
const fs = require('fs');
const path = require('path');

// Список файлов и папок, которые мы хотим экспортировать
const pathsToExport = [
  'package.json',
  'vite.config.js',
  'src' // Экспортируем всю папку src
];

const outputFileName = 'project_code.txt';
let output = '';

// Функция для рекурсивного обхода папок
function readDirectory(dirPath) {
  const files = fs.readdirSync(dirPath);
  for (const file of files) {
    const filePath = path.join(dirPath, file);
    const stat = fs.statSync(filePath);

    if (stat.isDirectory()) {
      readDirectory(filePath); // Если это папка, идем глубже
    } else if (['.js', '.vue', '.css', '.json'].includes(path.extname(filePath))) {
      // Если это файл с нужным расширением, добавляем его в вывод
      const relativePath = path.relative(__dirname, filePath).replace(/\\/g, '/');
      output += `\n### ${relativePath}\n`;
      output += '```\n';
      output += fs.readFileSync(filePath, 'utf-8');
      output += '\n```\n';
    }
  }
}

// Основная логика
try {
  for (const p of pathsToExport) {
    const fullPath = path.join(__dirname, p);
    if (!fs.existsSync(fullPath)) continue;

    const stat = fs.statSync(fullPath);
    if (stat.isDirectory()) {
      readDirectory(fullPath);
    } else {
      const relativePath = path.relative(__dirname, fullPath).replace(/\\/g, '/');
      output += `\n### ${relativePath}\n`;
      output += '```\n';
      output += fs.readFileSync(fullPath, 'utf-8');
      output += '\n```\n';
    }
  }

  fs.writeFileSync(outputFileName, output);
  console.log(`Проект успешно экспортирован в файл: ${outputFileName}`);
} catch (error) {
  console.error('Произошла ошибка при экспорте проекта:', error);
}
```

### src/firebase.js
```
import { initializeApp } from "firebase/app";
// ✅ Возвращаем правильную инициализацию Firestore с поддержкой оффлайн-кэширования
import { initializeFirestore, persistentLocalCache } from "firebase/firestore";

const firebaseConfig = {
  apiKey: "AIzaSyDF2TD4MTcKiBChKRssauvL-nNyT4Am9N0",
  authDomain: "molitwy.firebaseapp.com",
  projectId: "molitwy",
  storageBucket: "molitwy.firebasestorage.app",
  messagingSenderId: "654293224787",
  appId: "1:654293224787:web:5f4fce64abf5ba1b1ea5a6"
};

const app = initializeApp(firebaseConfig);

// ✅ Используем НОВЫЙ метод инициализации с настройками кэша,
// который заменяет и getFirestore(), и enableIndexedDbPersistence()
const db = initializeFirestore(app, {
  localCache: persistentLocalCache({})
});

// Экспортируем db, как и раньше
export { db };
```

### src/i18n.js
```
import { createI18n } from 'vue-i18n';
import ru from './locales/ru.json';
import be from './locales/be.json';

const savedLanguage = localStorage.getItem('language') || 'ru';

const i18n = createI18n({
  legacy: false, 
  locale: savedLanguage,
  fallbackLocale: 'ru',
  messages: {
    ru,
    be
  }
});

export default i18n;
```

### src/locales/be.json
```
{
  "appTitle": "Мае малітвы",
  "searchPlaceholder": "Пошук...",
  "filterByTags": "Фільтр па тэгах",
  "done": "Гатова",
  "edit": "Рэдагаваць",
  "delete": "Выдаліць",
  "pin": "Замацаваць",
  "unpin": "Адмацаваць",
  "noNotesFound": "Нататак не знойдзена",
  "confirmDeletion": "Пацвердзіце выдаленне",
  "deleteConfirmationMessage": "Вы ўпэўнены, што хочаце назаўсёды выдаліць нататку \"{title}\"?",
  "cancel": "Адмена",
  "title": "Назва",
  "source": "Крыніца",
  "tags": "Тэгі",
  "tagsHint": "Абярыце або ўвядзіце новыя тэгі",
  "editing": "Рэдагаванне",
  "newNote": "Новая нататка",
  "loading": "Загрузка...",
  "noteNotFound": "Нататка не знойдзена",
  "settings": "Налады",
  "appearance": "Знешні выгляд",
  "darkTheme": "Цёмная тэма",
  "themeIs": "Зараз выкарыстоўваецца {themeName} тэма",
  "themeNames": { "light": "светлая", "dark": "цёмная" },
  "fontSize": "Памер тэксту",
  "fontSizeHint": "Наладзьце памер шрыфту ў дадатку",
  "viewMode": "Выгляд спісу",
  "viewModeHint": "Карткі ці кампактны спіс",
  "preview": "Папярэдні прагляд",
  "language": "Мова",
  "textStyle": "Стыль тэксту",
  "allPrayers": "Все молитвы",
  "style": {
    "normal": "Звычайны",
    "h2": "Загаловак 1",
    "h3": "Загаловак 2",
    "rubric": "Рубрыка"
  }
}
```

### src/locales/ru.json
```
{
  "appTitle": "Мои молитвы",
  "searchPlaceholder": "Поиск...",
  "filterByTags": "Фильтр по тегам",
  "done": "Готово",
  "edit": "Редактировать",
  "delete": "Удалить",
  "pin": "Закрепить",
  "unpin": "Открепить",
  "noNotesFound": "Заметок не найдено",
  "confirmDeletion": "Подтвердите удаление",
  "deleteConfirmationMessage": "Вы уверены, что хотите навсегда удалить заметку \"{title}\"?",
  "cancel": "Отмена",
  "title": "Название",
  "source": "Источник",
  "tags": "Теги",
  "tagsHint": "Выберите или введите новые теги",
  "editing": "Редактирование",
  "newNote": "Новая заметка",
  "loading": "Загрузка...",
  "noteNotFound": "Заметка не найдена",
  "settings": "Настройки",
  "appearance": "Внешний вид",
  "darkTheme": "Тёмная тема",
  "themeIs": "Сейчас используется {themeName} тема",
  "themeNames": { "light": "светлая", "dark": "тёмная" },
  "fontSize": "Размер текста",
  "fontSizeHint": "Настройте размер шрифта в приложении",
  "viewMode": "Вид списка",
  "viewModeHint": "Карточки или компактный список",
  "preview": "Предпросмотр",
  "language": "Язык",
  "textStyle": "Стиль текста",
  "allPrayers": "Все молитвы",
  "style": {
    "normal": "Обычный",
    "h2": "Заголовок 1",
    "h3": "Заголовок 2",
    "rubric": "Рубрика"
  }
}
```

### src/main.js
```
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
import vuetify from './plugins/vuetify'
import { initializeApp } from "firebase/app"; // Импортируем для getAuth
import { getAuth, onAuthStateChanged } from "firebase/auth"; // Импортируем для проверки
import '@mdi/font/css/materialdesignicons.css'
import { createPinia } from 'pinia'; 
import './styles/main.css';
import i18n from './i18n';

// --- ИСПРАВЛЕНИЕ: Логика отложенной инициализации ---

// 1. Получаем экземпляр auth
const auth = getAuth();
let app; // Объявляем переменную для нашего приложения

// 2. Устанавливаем прослушиватель onAuthStateChanged
// Этот код выполнится один раз при запуске, определив статус пользователя
onAuthStateChanged(auth, () => {

  // 3. Создаем и монтируем приложение ТОЛЬКО ПОСЛЕ того, 
  // как Firebase определил статус пользователя.
  if (!app) {
    const pinia = createPinia();
    
    app = createApp(App)
      .use(router)
      .use(vuetify)
      .use(pinia)
      .use(i18n)
      .mount('#app');
  }
});
```

### src/plugins/vuetify.js
```

import 'vuetify/styles';
import { createVuetify } from 'vuetify';
import * as components from 'vuetify/components';
import * as directives from 'vuetify/directives';

export default createVuetify({
  components,
  directives,
});


```

### src/router/index.js
```
import { createRouter, createWebHistory } from 'vue-router';
import { useAuthStore } from '@/stores/auth';

const routes = [
  { path: '/login', name: 'Login', component: () => import('@/components/LoginView.vue') },
  
  { path: '/', name: 'ItemsList', component: () => import('@/components/ItemsList.vue') },
  { path: '/item/:id', name: 'ItemView', component: () => import('@/components/ItemView.vue'), props: true },
  
  // ✅ УБИРАЕМ ЗАЩИТУ со страницы настроек. Теперь она доступна всем.
  { path: '/settings', name: 'Settings', component: () => import('@/components/SettingsView.vue') },
  
  // Защищаем только те маршруты, которые действительно требуют прав администратора
  { path: '/edit/:id', name: 'ItemEdit', component: () => import('@/components/ItemForm.vue'), props: true, meta: { requiresAuth: true } },
  { path: '/add', name: 'ItemAdd', component: () => import('@/components/ItemForm.vue'), meta: { requiresAuth: true } },
  { path: '/admin', name: 'Admin', component: () => import('@/components/AdminView.vue'), meta: { requiresAuth: true } },
  
  { path: '/about', name: 'About', component: () => import('@/components/AboutView.vue') },
];

const router = createRouter({
  history: createWebHistory(),
  routes,
});

// --- ✅ ГЛАВНОЕ ИСПРАВЛЕНИЕ: Полностью переработанный навигационный страж ---
router.beforeEach((to, from, next) => {
  const authStore = useAuthStore();
  
  const requiresAuth = to.matched.some(record => record.meta.requiresAuth);
  const userIsLoggedIn = !!authStore.user;

  // Случай 1: Пользователь пытается зайти на защищенную страницу, но не авторизован.
  if (requiresAuth && !userIsLoggedIn) {
    // Перенаправляем его на страницу входа.
    // Мы также можем передать исходный путь в `query`, чтобы вернуть его обратно после входа.
    next({ name: 'Login', query: { redirect: to.fullPath } });
  } 
  // Случай 2: Пользователь авторизован и пытается зайти на страницу входа.
  else if (to.name === 'Login' && userIsLoggedIn) {
    // Не пускаем его, перенаправляем на главную.
    next({ name: 'ItemsList' });
  } 
  // Случай 3: Все остальные случаи (включая выход с защищенной страницы).
  else {
    // Просто разрешаем навигацию.
    next();
  }
});

export default router;
```

### src/stores/auth.js
```
import { defineStore } from 'pinia';
import { ref } from 'vue';
import { getAuth, signInWithEmailAndPassword, signOut, onAuthStateChanged } from 'firebase/auth';
import router from '@/router';

export const useAuthStore = defineStore('auth', () => {
  const user = ref(null);
  const auth = getAuth();
  const loading = ref(true);

  // Прослушиватель для отслеживания состояния входа
  const unsubscribe = onAuthStateChanged(auth, (firebaseUser) => {
    user.value = firebaseUser;
    loading.value = false;
  });

  const login = async (email, password) => {
    try {
      await signInWithEmailAndPassword(auth, email, password);
      router.push({ name: 'ItemsList' });
    } catch (error) {
      console.error("Ошибка входа:", error.code);
      throw error; // Пробрасываем ошибку для обработки в компоненте
    }
  };

  const logout = async () => {
    await signOut(auth);
    router.push({ name: 'Login' });
  };
  
  // Возвращаем функцию, чтобы ее можно было вызвать при выходе из приложения
  const unbind = () => {
    unsubscribe();
  };

  return { user, login, logout, unbind, loading };
});
```

### src/stores/settings.js
```
import { defineStore } from 'pinia';
import { ref, watch } from 'vue';
import { useTheme } from 'vuetify';
import { useI18n } from 'vue-i18n';

// ✅ Значения по умолчанию для категорий (теперь с массивом тегов)
const defaultCategories = [
  { name: 'Основные молитвы', tags: ['основные'] },
  { name: 'Марианские молитвы', tags: ['марианские'] }
];

export const useSettingsStore = defineStore('settings', () => {
  const theme = useTheme();
  const { locale } = useI18n();

  const currentTheme = ref(localStorage.getItem('theme') || 'light');
  if (theme.global.name.value !== currentTheme.value) {
    theme.global.name.value = currentTheme.value;
  }
  function toggleTheme() {
    const newTheme = currentTheme.value === 'light' ? 'dark' : 'light';
    currentTheme.value = newTheme;
    theme.global.name.value = newTheme;
    localStorage.setItem('theme', newTheme);
  }

  const fontSizeMultiplier = ref(parseFloat(localStorage.getItem('fontSizeMultiplier')) || 1.0);
  watch(fontSizeMultiplier, (newMultiplier) => { document.documentElement.style.setProperty('--font-size-multiplier', newMultiplier); }, { immediate: true });
  function increaseFontSize() { if (fontSizeMultiplier.value < 1.5) fontSizeMultiplier.value += 0.1; }
  function decreaseFontSize() { if (fontSizeMultiplier.value > 0.8) fontSizeMultiplier.value -= 0.1; }

  const currentLanguage = ref(localStorage.getItem('language') || 'ru');
  locale.value = currentLanguage.value;
  function setLanguage(lang) { locale.value = lang; localStorage.setItem('language', lang); }

  const viewMode = ref(localStorage.getItem('viewMode') || 'card');
  function toggleViewMode() { viewMode.value = viewMode.value === 'card' ? 'compact' : 'card'; localStorage.setItem('viewMode', viewMode.value) }

  const pinnedIds = ref(JSON.parse(localStorage.getItem('pinnedIds') || '[]'));
  watch(pinnedIds, (newIds) => { localStorage.setItem('pinnedIds', JSON.stringify(newIds)); }, { deep: true });
  function isPinned(noteId) { return pinnedIds.value.includes(noteId); }
  function togglePin(noteId) {
    const index = pinnedIds.value.indexOf(noteId);
    if (index > -1) {
      pinnedIds.value.splice(index, 1);
    } else {
      pinnedIds.value.unshift(noteId);
    }
  }

  // ✅ --- ОБНОВЛЕННЫЙ БЛОК УПРАВЛЕНИЯ КАТЕГОРИЯМИ --- ✅
  const menuCategories = ref(
    JSON.parse(localStorage.getItem('menuCategories') || JSON.stringify(defaultCategories))
  );

  watch(menuCategories, (newCategories) => {
    localStorage.setItem('menuCategories', JSON.stringify(newCategories));
  }, { deep: true });

  function addCategory(category) {
    // ✅ Проверяем, что есть имя и хотя бы один тег в массиве
    if (category && category.name && category.tags && category.tags.length > 0) {
      menuCategories.value.push(category);
    }
  }

  function removeCategory(index) {
    menuCategories.value.splice(index, 1);
  }

  return {
    currentTheme, toggleTheme,
    fontSizeMultiplier, increaseFontSize, decreaseFontSize,
    currentLanguage, setLanguage,
    viewMode, toggleViewMode,
    pinnedIds, isPinned, togglePin,
    menuCategories, addCategory, removeCategory
  };
});
```

### src/style.css
```

```

### src/styles/main.css
```
/* Базовый сброс и переменные */
:root {
  --font-size-multiplier: 1.0;
}

/* Стили для контента из редактора */
.note-content-area h2,
.ProseMirror h2 {
  /* ✅ УМЕНЬШЕННЫЙ РАЗМЕР */
  font-size: calc(1.5rem * var(--font-size-multiplier));
  line-height: 1.4;
  margin: 1.5em 0 0.5em;
  font-weight: 500;
}

.note-content-area h3,
.ProseMirror h3 {
   /* ✅ УМЕНЬШЕННЫЙ РАЗМЕР */
  font-size: calc(1.15rem * var(--font-size-multiplier));
  line-height: 1.4;
  margin: 1.5em 0 0.5em;
  font-weight: 500;
}

.note-content-area p,
.ProseMirror p {
  font-size: calc(1rem * var(--font-size-multiplier));
  line-height: 1.7;
  margin-bottom: 1em;
}

.note-content-area .rubric,
.ProseMirror .rubric {
  color: rgb(var(--v-theme-error));
  font-style: italic;
  text-align: center;
}

/* Правило для выравнивания по ширине */
.note-content-area p[style*="text-align: justify;"],
.note-content-area h2[style*="text-align: justify;"],
.note-content-area h3[style*="text-align: justify;"] {
  text-align: justify;
}

/* Правило для переноса текста в заголовках карточек и списков */
.v-card-title, .v-list-item-title {
  white-space: normal !important;
  word-break: break-word;
  line-height: 1.4;
}

/* ✅ УЛУЧШЕННЫЕ СТИЛИ ДЛЯ МОБИЛЬНЫХ УСТРОЙСТВ */
@media (max-width: 600px) {
  .v-container {
    padding-left: 8px;   /* Уменьшаем отступы */
    padding-right: 8px;
  }
  /* Убираем отступы у первого элемента списка/карточки */
  .v-container > div > .v-card:first-child,
  .v-container > div > .v-list:first-child {
      margin-top: 0;
  }
  .v-list-item {
    padding-left: 4px;
    padding-right: 4px;
  }
}

/* Дополнительные стили для редактора */
.editor-container {
  border: 1px solid rgba(var(--v-border-color), var(--v-border-opacity));
  border-radius: 4px;
}

.editor-toolbar {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  padding: 4px 8px;
  border-bottom: 1px solid rgba(var(--v-border-color), var(--v-border-opacity));
  gap: 4px; /* Добавляем небольшой отступ между группами кнопок */
}

.editor-toolbar .v-btn.v-btn--active {
  background-color: rgba(var(--v-theme-primary), 0.1);
  color: rgb(var(--v-theme-primary));
}

.ProseMirror {
  padding: 12px 16px;
  min-height: 200px;
  outline: none;
}

.ProseMirror p { margin-bottom: 0; }
.ProseMirror p.rubric { margin: 1em 0; }
.ProseMirror-focused { border-color: transparent; box-shadow: none; }
/* ✅ Исправление для иконки в списке связанных заметок */
.linked-notes-list .v-list-item__prepend .v-icon {
  margin-inline-end: 12px; /* Добавляем отступ справа от иконки */
}


```
