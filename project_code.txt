
### package.json
```
{
  "name": "my-prayer-app",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "export-code": "node export-code.js",
    "db:seed": "node seed-db.js",
    "db:migrate": "node migration.js"
  },
  "dependencies": {
    "@mdi/font": "^7.4.47",
    "@tiptap/extension-color": "^3.0.7",
    "@tiptap/extension-link": "^3.0.9",
    "@tiptap/extension-text-align": "^3.0.9",
    "@tiptap/extension-text-style": "^3.0.7",
    "@tiptap/pm": "^3.0.7",
    "@tiptap/starter-kit": "^3.0.7",
    "@tiptap/vue-3": "^3.0.7",
    "firebase": "^10.12.2",
    "pinia": "^3.0.3",
    "vue": "^3.4.27",
    "vue-i18n": "^11.1.11",
    "vue-router": "^4.3.3",
    "vuetify": "^3.6.8"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^5.0.5",
    "vite": "^5.2.13",
    "vite-plugin-pwa": "^0.20.5",
    "vite-plugin-vuetify": "^2.0.3"
  }
}

```

### vite.config.js
```
// vite.config.js
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';
import vuetify, { transformAssetUrls } from 'vite-plugin-vuetify';
import { VitePWA } from 'vite-plugin-pwa';
import path from 'path';

export default defineConfig({
  plugins: [
    vue({ 
      template: { transformAssetUrls }
    }),
    vuetify({
      autoImport: true,
    }),
    VitePWA({
      registerType: 'prompt',
      injectRegister: 'auto',
      strategies: 'generateSW',
      workbox: {
        cleanupOutdatedCaches: true,
        globPatterns: ['**/*.{js,css,html,ico,png,svg,json,vue,txt,woff2,webmanifest}'],
      },
      // ✅ Мы УДАЛИЛИ опцию manifestFile/manifestFilename.
      // Плагин по умолчанию создаст manifest.webmanifest, что нам и нужно.
      manifest: {
        name: 'Мае малітвы',
        short_name: 'Малітвы',
        description: 'Личный сборник молитв и заметок',
        theme_color: '#1867C0',
        background_color: '#ffffff',
        display: 'standalone',
        start_url: '.',
        icons: [
          {
            src: 'pwa-192x192.png',
            sizes: '192x192',
            type: 'image/png'
          },
          {
            src: 'pwa-512x512.png',
            sizes: '512x512',
            type: 'image/png'
          },
          {
            src: 'pwa-512x512.png',
            sizes: '512x512',
            type: 'image/png',
            purpose: 'maskable'
          }
        ]
      }
    })
  ],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});
```

### firebase.json
```
{
  "hosting": {
    "public": "dist",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "/manifest.webmanifest",
        "destination": "/manifest.webmanifest"
      },
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  }
}
```

### index.html
```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <!-- ================================================================== -->
    <!-- ✅ ОБНОВЛЕННЫЙ БЛОК ДЛЯ PWA И УСТАНОВКИ НА iOS + ANDROID          -->
    <!-- ================================================================== -->

    <!-- 1. Манифест для Android и стандартных браузеров -->
    <link rel="manifest" href="/manifest.webmanifest">

    <!-- 2. Основной цвет темы (влияет на цвет UI браузера) -->
    <meta name="theme-color" content="#1867C0">

    <!-- 3. Ключевой тег для iOS: иконка на домашнем экране -->
    <!-- Убедитесь, что файл 'apple-touch-icon.png' лежит в папке /public -->
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">

    <!-- 4. Мета-теги для полноэкранного режима на iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Малітвы">

    <!-- 5. Подключение шрифтов (без изменений) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@400;700&family=Kurale&family=Old+Standard+TT:ital,wght@0,400;0,700;1,400&family=Pacifico&family=Yeseva+One&display=swap" rel="stylesheet">
    
    <title>Мае Молітвы</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
```

### seed-db.js
```
const { initializeApp } = require("firebase/app");
const { getFirestore, collection, getDocs, writeBatch, addDoc, serverTimestamp, updateDoc, doc } = require("firebase/firestore");

const firebaseConfig = {
  apiKey: "AIzaSyDF2TD4MTcKiBChKRssauvL-nNyT4Am9N0",
  authDomain: "molitwy.firebaseapp.com",
  projectId: "molitwy",
  storageBucket: "molitwy.firebasestorage.app",
  messagingSenderId: "654293224787",
  appId: "1:654293224787:web:5f4fce64abf5ba1b1ea5a6"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// ✅ ИЗМЕНЕНИЕ: структура данных теперь использует titleVersions
const prayersData = [
  { id: "pater_noster", titleVersions: { ru: "Отче наш", be: "Ойча наш", la: "Pater Noster" }, tags: ["основные"], textVersions: { ru: "<p>Текст...</p>", be: "<p>Тэкст...</p>", la: "<p>Text...</p>" } },
  { id: "ave_maria", titleVersions: { ru: "Радуйся, Мария", be: "Вітай, Марыя", la: "Ave Maria" }, tags: ["основные", "марианские"], textVersions: { ru: "<p>Текст...</p>", be: "<p>Тэкст...</p>", la: "<p>Text...</p>" } },
  { id: "credo", titleVersions: { ru: "Символ веры", be: "Сімвал веры", la: "Credo" }, tags: ["основные"], textVersions: { ru: "<p>Текст...</p>", be: "<p>Тэкст...</p>", la: "<p>Text...</p>" }, linkedNoteIds: ["pater_noster", "ave_maria"] },
  { id: "gloria_patri", titleVersions: { ru: "Слава", be: "Хвала", la: "Gloria Patri" }, tags: ["основные"], textVersions: { ru: "<p>Текст...</p>", be: "<p>Тэкст...</p>", la: "<p>Text...</p>" }, linkedNoteIds: ["pater_noster"] },
];

async function clearCollection(db, collectionPath) {
  const collectionRef = collection(db, collectionPath);
  const snapshot = await getDocs(collectionRef);
  if (snapshot.empty) { console.log(`Коллекция '${collectionPath}' уже пуста.`); return; }
  const batch = writeBatch(db);
  snapshot.docs.forEach(doc => { batch.delete(doc.ref); });
  await batch.commit();
  console.log(`Все документы в коллекции '${collectionPath}' были удалены.`);
}

async function seedDatabase() {
  try {
    console.log("Очистка коллекции 'items'...");
    await clearCollection(db, 'items');
    console.log("Наполнение базы новыми данными...");
    const itemsCollection = collection(db, 'items');
    const addedIds = {};

    for (const prayer of prayersData) {
      // ✅ ИЗМЕНЕНИЕ: Собираем данные с titleVersions
      const dataToAdd = {
        titleVersions: prayer.titleVersions,
        tags: prayer.tags,
        textVersions: prayer.textVersions,
        createdAt: serverTimestamp()
      };
      const docRef = await addDoc(itemsCollection, dataToAdd);
      addedIds[prayer.id] = docRef.id;
      console.log(`- Добавлена: "${prayer.titleVersions.be || prayer.titleVersions.ru}"`);
    }

    console.log("Обновление связей...");
    for (const prayer of prayersData) {
        if (prayer.linkedNoteIds && prayer.linkedNoteIds.length > 0) {
            const realLinkedIds = prayer.linkedNoteIds.map(tempId => addedIds[tempId]);
            const realDocId = addedIds[prayer.id];
            await updateDoc(doc(db, "items", realDocId), { linkedNoteIds: realLinkedIds });
            console.log(`- Обновлены связи для "${prayer.titleVersions.be || prayer.titleVersions.ru}"`);
        }
    }
    console.log("Наполнение базы завершено!");
  } catch (error) {
    console.error("КРИТИЧЕСКАЯ ошибка:", error);
  }
}

seedDatabase();
```

### src/App.vue
```
<template>
  <v-app :theme="settings.currentTheme">
    <v-navigation-drawer v-model="isDrawerOpen" temporary>
      
      <!-- ✅ --- ФИНАЛЬНАЯ ВЕРСИЯ БЛОКА С ИЗОБРАЖЕНИЕМ --- ✅ -->
      <!-- Картинка теперь просто шапка, без текста внутри -->
        <v-img
        height="70"
        cover
      >
        <div class="d-flex flex-column justify-end h-100 pa-4">
         <h2 class="font-weight-bold app-title non-selectable">{{ $t('appTitle') }}</h2>
        </div>
      </v-img>
      
      <v-divider></v-divider>
      <!-- Основная навигация -->
      <v-list nav>
        <v-list-item 
          prepend-icon="mdi-format-list-text" 
          :title="$t('allPrayers')"
          @click="navigateToCategory(null)"
        ></v-list-item>
        
        <v-list-item
          v-for="category in settings.menuCategories"
          :key="category.name"
          prepend-icon="mdi-label-outline"
          :title="category.name"
          @click="navigateToCategory(category)"
        ></v-list-item>
        <v-divider></v-divider>
        <v-list-item 
          prepend-icon="mdi-book-open-variant" 
          :title="$t('myPrayerRule')"
          :to="{ name: 'PrayerRule' }"
        ></v-list-item>
        <v-divider></v-divider>
        <v-list-item 
  prepend-icon="mdi-cross"
  :title="$t('holyMass')"
  :to="{ name: 'HolyMass' }"
></v-list-item>
 <v-divider></v-divider>
        <v-list-item 
          prepend-icon="mdi-cog-outline" 
          :title="$t('settings')"
          :to="{ name: 'Settings' }"
        ></v-list-item>
        <v-list-item 
          v-if="authStore.user"
          prepend-icon="mdi-shield-crown-outline" 
          :title="$t('admin')"
          :to="{ name: 'Admin' }"
        ></v-list-item>
        <v-list-item 
          prepend-icon="mdi-information-outline" 
          :title="$t('about')"
          :to="{ name: 'About' }"
        ></v-list-item>
        <v-divider></v-divider>
        <v-list-item
          v-if="authStore.user"
          prepend-icon="mdi-logout"
          :title="$t('logout')"
          @click="handleLogout"
        ></v-list-item>
         <v-list-item
          v-else
          prepend-icon="mdi-login"
          :title="$t('login')"
          :to="{ name: 'Login' }"
        ></v-list-item>
      </v-list>
    </v-navigation-drawer>

      <v-app-bar 
    :elevation="2" 
    app
    :scroll-behavior="isItemViewPage ? 'hide' : undefined"
  >
    <!-- Кнопка назад или меню-гамбургер -->
    <v-btn v-if="showBackButton" icon="mdi-arrow-left" @click="router.back()"></v-btn>
    <v-btn v-else icon="mdi-menu" @click="isDrawerOpen = !isDrawerOpen"></v-btn>
    <!-- Поле поиска, которое появляется при активации -->
    <v-expand-x-transition>
        <v-text-field
            v-if="isSearchActive"
            v-model="search"
            :placeholder="$t('searchPlaceholder')"
            variant="solo-inverted"
            flat
            hide-details
            autofocus
            density="compact"
            class="mr-2"
            @blur="isSearchActive = false"
            clearable  
            @click:clear="isSearchActive = false; search = '';"
        ></v-text-field>
    </v-expand-x-transition>
    <!-- Заголовок приложения -->
    <v-toolbar-title 
      v-if="!isSearchActive" 
      @click="goHome" 
      style="cursor: pointer;"
      class="font-weight-medium"
    >
     <span class="wrappable-toolbar-title app-title non-selectable">{{ $t('appTitle') }}</span>
    </v-toolbar-title>
    <!-- Динамическая правая часть AppBar -->
    <template v-if="!isSearchActive">
        <!-- ===== КНОПКИ ДЛЯ ГЛАВНОЙ СТРАНИЦЫ ===== -->
        <template v-if="isHomePage">
          <v-btn icon="mdi-magnify" @click="isSearchActive = true"></v-btn>
          <v-btn icon="mdi-filter-variant" @click="isFilterSheetOpen = true"></v-btn>
        </template>
        <!-- ===== ✅✅✅ НОВОЕ ВЫПАДАЮЩЕЕ МЕНЮ ДЛЯ СТРАНИЦЫ ПРОСМОТРА ЗАМЕТКИ ✅✅✅ ===== -->
        <template v-if="isItemViewPage">
          <!-- Оборачиваем все действия в компонент v-menu -->
          <v-menu location="bottom end" transition="slide-y-transition">
              <template v-slot:activator="{ props }">
                  <!-- Единственная видимая кнопка - "три точки" -->
                  <v-btn icon="mdi-dots-vertical" v-bind="props"></v-btn>
              </template>
              <!-- Содержимое выпадающего списка -->
              <v-list density="compact" class="pa-0">
                  <!-- 1. Поделиться -->
                  <v-list-item @click="shareCurrentItem"  >
                      <template v-slot:prepend>
                          <v-icon>mdi-share-variant-outline</v-icon>
                      </template>
                      <v-list-item-title>{{ $t('share') }}</v-list-item-title>
                  </v-list-item>
                  <!-- 2. Закрепить/Открепить -->
                  <v-list-item @click="settings.togglePin(currentItemId)" >
                      <template v-slot:prepend>
                          <v-icon :color="settings.isPinned(currentItemId) ? 'primary' : ''">
                              {{ settings.isPinned(currentItemId) ? 'mdi-pin' : 'mdi-pin-outline' }}
                          </v-icon>
                      </template>
                      <v-list-item-title>{{ settings.isPinned(currentItemId) ? $t('unpin') : $t('pin') }}</v-list-item-title>
                  </v-list-item>
                  <!-- 3. Настройки текста -->
                  <v-list-item @click="openTextSettings" >
                      <template v-slot:prepend>
                          <v-icon>mdi-tune-variant</v-icon>
                      </template>
                      <v-list-item-title>{{ $t('textSettings') }}</v-list-item-title>
                  </v-list-item>
                  <!-- 4. Редактировать (только для админа) -->
                  <v-list-item
                      v-if="authStore.user"
                      @click="router.push({ name: 'ItemEdit', params: { id: currentItemId } })"
                  >
                      <template v-slot:prepend>
                          <v-icon>mdi-pencil-outline</v-icon>
                      </template>
                      <v-list-item-title>{{ $t('edit') }}</v-list-item-title>
                  </v-list-item>
              </v-list>
          </v-menu>
        </template>
        <!-- ===== ОСТАЛЬНЫЕ КНОПКИ (ДЛЯ ДРУГИХ СТРАНИЦ) ===== -->
        
        <!-- Кнопка сохранения для страниц /add и /edit -->
        <v-btn v-if="showSaveButton" icon="mdi-check" @click="triggerSave"></v-btn>
        <!-- Кнопка редактирования для страницы "Молитвенное правило" -->
        <v-btn
          v-if="showPrayerRuleEditButton"
          @click="toggleEditing"
        >
          <v-icon>{{ isEditing ? 'mdi-check' : 'mdi-pencil' }}</v-icon>
        </v-btn>
    </template>
  </v-app-bar>


    <v-main>
      <router-view v-if="!authStore.loading" />
      <!-- Показываем красивый индикатор загрузки в центре, пока приложение готовится -->
      <div v-else class="d-flex justify-center align-center fill-height">
        <v-progress-circular indeterminate color="primary" size="64"></v-progress-circular>
      </div>
      <FilterSheet />
      <TextSettingsSheet />
      
    </v-main>
    <NotificationSnackbar ref="snackbar" />
      <ReloadPrompt /> <!-- ✅ ДОБАВЬТЕ ЭТУ СТРОКУ -->
      <!-- ✅ НОВЫЙ ДИАЛОГ-ПРЕДЛОЖЕНИЕ НОВЕННЫ -->
    <v-dialog 
      :model-value="!!suggestion" 
      max-width="500px" 
      persistent
    >
      <v-card v-if="suggestion" class="pa-2">
        <v-card-title class="d-flex align-center">
          <v-icon color="primary" start>mdi-lightbulb-on-outline</v-icon>
          <span class="text-h5">{{ $t('novenaSuggestionTitle') }}</span>
        </v-card-title>
        <v-card-text class="text-body-1 py-4">
          {{ $t('novenaSuggestionText', { title: getTitle(suggestion.item), days: suggestion.days }) }}
        </v-card-text>
        <v-card-actions>
          <v-spacer></v-spacer>
          <v-btn
            variant="text"
            color="grey"
            @click="dismissSuggestion(true)"
          >
            {{ $t('decline') }}
          </v-btn>
          <v-btn
            variant="text"
            @click="dismissSuggestion(false)"
          >
            {{ $t('remindLater') }}
          </v-btn>
          
          <v-btn
            color="primary"
            variant="flat"
            @click="viewSuggestedNovena"
          >
            {{ $t('viewPrayer') }}
          </v-btn>
        </v-card-actions>
      </v-card>
    </v-dialog>
  </v-app>
</template>

<script setup>
import { ref, onMounted, provide, computed, watch } from 'vue';
import { useRouter, useRoute } from 'vue-router';

import { useItems } from '@/composables/useItems';
import { useSettingsStore } from '@/stores/settings';
import { useAppBar } from '@/composables/useAppBar';
import { useFilters } from '@/composables/useFilters';

import { usePageMode } from '@/composables/usePageMode'; // ✅ Импорт
import { useAuthStore } from '@/stores/auth';
import { notifier } from '@/composables/useNotifier';
import { useNovenaSuggestions } from '@/composables/useNovenaSuggestions';
import FilterSheet from '@/components/FilterSheet.vue';
import NotificationSnackbar from '@/components/NotificationSnackbar.vue';
import TextSettingsSheet from '@/components/TextSettingsSheet.vue'; // ✅ ИМПОРТ
import { getTitleByLang } from '@/utils/i18n'; // Добавьте этот импорт
import ReloadPrompt from '@/components/ReloadPrompt.vue'; // ✅ ДОБАВЬТЕ ЭТОТ ИМПОРТ

const getTitle = (item) => getTitleByLang(item); // Добавьте эту строку

const settings = useSettingsStore();
const router = useRouter();
const route = useRoute();
const authStore = useAuthStore();

const { items, isLoading } = useItems();
const { isDrawerOpen, isSearchActive, isFilterSheetOpen, isTextSettingsSheetOpen  } = useAppBar();
const { selectedTags, search } = useFilters();
const { suggestion, checkSuggestions, viewSuggestedNovena, dismissSuggestion } = useNovenaSuggestions();
const { isEditing, toggleEditing } = usePageMode(); // ✅ Получаем состояние

const snackbar = ref(null);
const showPrayerRuleEditButton = computed(() => route.name === 'PrayerRule');
const isHomePage = computed(() => route.name === 'ItemsList');
const showBackButton = computed(() => !isHomePage.value);
const showSaveButton = computed(() => ['ItemEdit', 'ItemAdd'].includes(route.name));

const isItemViewPage = computed(() => route.name === 'ItemView');
const currentItemId = computed(() => route.params.id); //
const currentItem = computed(() => {
  if (!currentItemId.value || !items.value) return null;
  return items.value.find(i => i.id === currentItemId.value);
});

// ✅ ЛОГИКА ДЛЯ ФУНКЦИИ "ПОДЕЛИТЬСЯ"
async function shareCurrentItem() {
  if (!currentItem.value) return;
  // ✅ СОЗДАЕМ КОРОТКУЮ ССЫЛКУ
  const shareUrl = `${window.location.origin}/p/${currentItem.value.id}`;

  const shareData = {
    title: getTitle(currentItem.value),
    text: `Прочитайте молитву "${getTitle(currentItem.value)}"`,
    url: shareUrl,
  };
  if (navigator.share) {
    try {
      await navigator.share(shareData);
    } catch (err) {
      console.error('Share failed:', err);
    }
  } else {
    // Fallback: копирование в буфер обмена
    try {
      await navigator.clipboard.writeText(shareUrl);
      showSuccess(t('linkCopied'));
    } catch (err) {
      showError(t('shareError'));
    }
  }
}



function openTextSettings() {
  console.log(`[App.vue] Button clicked. 'isTextSettingsSheetOpen' is currently: ${isTextSettingsSheetOpen.value}`);
  isTextSettingsSheetOpen.value = true;
  console.log(`[App.vue] State changed. 'isTextSettingsSheetOpen' is now: ${isTextSettingsSheetOpen.value}`);
}

watch(isLoading, (newIsLoading) => {
  if (!newIsLoading && settings.novenaNotificationsEnabled) {
    checkSuggestions();
  }
});

watch(() => route.name, (newName) => {
  console.group(`[App.vue WATCHER] Имя маршрута изменилось!`);
  console.log(`Новое имя маршрута: %c'${newName}'`, 'color: blue; font-weight: bold;');
  const isPrayerRule = newName === 'PrayerRule';
  console.log(`Сравнение с 'PrayerRule' дает: %c${isPrayerRule}`, `color: ${isPrayerRule ? 'green' : 'red'}; font-weight: bold;`);
  console.log(`Итоговое значение showPrayerRuleEditButton: %c${showPrayerRuleEditButton.value}`, `color: ${showPrayerRuleEditButton.value ? 'green' : 'red'}; font-weight: bold;`);
  console.groupEnd();
}, { immediate: true }); // immediate: true выполнит проверку сразу при загрузке
const saveAction = ref(null);
const triggerSave = () => {
  if (saveAction.value) saveAction.value();
};
provide('registerSaveAction', (action) => {
  saveAction.value = action;
});


onMounted(() => {
  notifier.value = snackbar.value;
});

function goHome() {
  if (!isHomePage.value) {
    router.push({ name: 'ItemsList' });
  }
}

function navigateToCategory(category) {
  selectedTags.value = category ? (category.tags || []) : [];
  goHome();
  isDrawerOpen.value = false;
}

async function handleLogout() {
    isDrawerOpen.value = false;
    await authStore.logout();
}
</script>
<style>
.non-selectable {
  -webkit-user-select: none; /* Safari */
  -ms-user-select: none; /* IE 10+ */
  user-select: none; /* Standard syntax */
}
</style>
```

### src/components/AboutView.vue
```
<template>
  <v-container>
    <v-card>
      <v-card-title class="text-h5">{{ $t('about') }}</v-card-title>
      <v-card-text>
        <p>{{ $t('aboutText') }}</p>
        <p class="mt-4">{{ $t('version') }}</p>
        <p>{{ $t('devWithLove') }}</p>
      </v-card-text>
    </v-card>
  </v-container>
</template>

<script setup>
// Скрипт больше не нужен, так как AppBar управляется глобально
</script>
```

### src/components/AddCategoryDialog.vue
```
<!-- src/components/dialogs/AddCategoryDialog.vue -->
<template>
  <v-dialog
    :model-value="modelValue"
    @update:modelValue="$emit('update:modelValue', $event)"
    max-width="600px"
    :fullscreen="$vuetify.display.mobile"
    scrollable
  >
    <v-card>
      <v-card-title>{{ $t('addCategory') }}</v-card-title>
      <v-card-text>
        <v-form @submit.prevent="onAddCategory">
          <v-text-field
            v-model="newCategory.name"
            :label="$t('categoryName')"
            variant="outlined"
            class="mb-4"
          ></v-text-field>
          <v-combobox
            v-model="newCategory.tags"
            :items="allTags"
            :label="$t('categoryTags')"
            variant="outlined"
            multiple
            chips
            clearable
          ></v-combobox>
        </v-form>
      </v-card-text>
      <v-card-actions>
        <v-spacer></v-spacer>
        <v-btn text @click="$emit('update:modelValue', false)">{{ $t('cancel') }}</v-btn>
        <v-btn color="primary" variant="flat" @click="onAddCategory">{{ $t('add') }}</v-btn>
      </v-card-actions>
    </v-card>
  </v-dialog>
</template>

<script setup>
import { ref } from 'vue';
import { useSettingsStore } from '@/stores/settings';
import { useItems } from '@/composables/useItems';

defineProps({ modelValue: Boolean });
const emit = defineEmits(['update:modelValue']);

const settings = useSettingsStore();
const { allTags } = useItems();
const newCategory = ref({ name: '', tags: [] });

function onAddCategory() {
  if (newCategory.value.name && newCategory.value.tags.length > 0) {
    settings.addCategory({ ...newCategory.value });
    newCategory.value = { name: '', tags: [] };
    emit('update:modelValue', false); // Закрываем диалог
  }
}
</script>
```

### src/components/AdminView.vue
```
<template>
  <v-container>
    <v-card>
      <v-card-title class="text-h5">{{ $t('admin') }}</v-card-title>
      <v-card-text>
        <p>
          {{ $t('adminText') }}
        </p>
      </v-card-text>
    </v-card>

    <!-- Секция общих настроек -->
    <v-list lines="two" subheader class="mt-4">
      <v-list-subheader>{{ $t('generalSettings') }}</v-list-subheader>
      <v-list-item 
        :title="$t('showHiddenNotes')" 
        :subtitle="$t('showHiddenNotesHint')"
      >
        <template v-slot:prepend><v-icon>mdi-eye-off-outline</v-icon></template>
        <template v-slot:append>
          <v-switch
            :model-value="settings.showHiddenItems"
            @update:model-value="settings.toggleShowHiddenItems"
            color="primary"
            inset
            hide-details
          ></v-switch>
        </template>
      </v-list-item>
    </v-list>
    
    <!-- ✅ НОВАЯ СЕКЦИЯ: Управление данными -->
    <v-list lines="one" subheader class="mt-2">
        <v-list-subheader>{{ $t('dataManagement') }}</v-list-subheader>
        <v-card variant="tonal" class="mx-2 pa-2">
            <div class="d-flex flex-wrap ga-2">
                 <v-btn @click="exportToJson" prepend-icon="mdi-code-json" color="primary" variant="outlined">{{ $t('exportToJson') }}</v-btn>
                 <v-btn @click="exportToCsv" prepend-icon="mdi-file-delimited-outline">{{ $t('exportToCsv') }}</v-btn>
                 <v-spacer />
                 <v-btn @click="triggerImport" prepend-icon="mdi-application-import" color="secondary" variant="flat">{{ $t('importFromFile') }}</v-btn>
                 <input ref="fileInput" type="file" hidden @change="handleFileSelect">
            </div>
        </v-card>
    </v-list>

    <!-- Диалог подтверждения импорта -->
    <v-dialog v-model="isImportDialogVisible" max-width="500px" persistent>
        <v-card v-if="importFile">
            <v-card-title class="text-h5">{{ $t('importConfirmationTitle') }}</v-card-title>
            <v-card-text>
                <p class="mb-2">{{ $t('importConfirmationMessage', { count: previewItems.length, fileName: importFile.name }) }}</p>
                <p class="text-medium-emphasis text-caption">{{ $t('importWarning') }}</p>
                
                <v-radio-group v-model="importMode" inline class="mt-4">
                    <template v-slot:label><div>{{ $t('importModeLabel') }}</div></template>
                    <v-radio :label="$t('importMode.add')" value="add"></v-radio>
                    <v-radio :label="$t('importMode.overwrite')" value="overwrite"></v-radio>
                </v-radio-group>
            </v-card-text>
            <v-card-actions>
                <v-spacer></v-spacer>
                <v-btn text @click="cancelImport">{{ $t('cancel') }}</v-btn>
                <v-btn color="primary" variant="flat" @click="confirmImport" :loading="isImporting">{{ $t('import') }}</v-btn>
            </v-card-actions>
        </v-card>
    </v-dialog>

  </v-container>
</template>

<script setup>
import { ref } from 'vue';
import { useSettingsStore } from '@/stores/settings';
import { useDataManagement } from '@/composables/useDataManagement';

const settings = useSettingsStore();
const fileInput = ref(null);

const { 
  exportToCsv, 
  exportToJson, 
  importFromFile,
  isImporting,
  isImportDialogVisible,
  importFile,
  previewItems,
  importMode,
  confirmImport,
  cancelImport
} = useDataManagement();

const triggerImport = () => {
    fileInput.value.click();
};

const handleFileSelect = (event) => {
    const file = event.target.files[0];
    if (file) {
        importFromFile(file);
    }
};
</script>
```

### src/components/Editor.vue
```
<template>
  <div>
    <div v-if="editor" class="editor-wrapper">
      <div class="editor-toolbar">
        <v-menu offset-y>
          <template v-slot:activator="{ props }">
            <v-btn v-bind="props" density="compact" class="mr-2" style="min-width: 140px;">
              {{ currentStyleLabel }}
              <v-icon right>mdi-menu-down</v-icon>
            </v-btn>
          </template>
          <v-list density="compact">
            <v-list-item @click="editor.chain().focus().setNode('paragraph', { class: null, dayMarker: null, marker: null }).run()" :active="editor.isActive('paragraph')">
              <v-list-item-title>{{ $t('style.normal') }}</v-list-item-title>
            </v-list-item>
            <v-list-item @click="editor.chain().focus().toggleHeading({ level: 2 }).run()" :active="editor.isActive('heading', { level: 2 })">
              <v-list-item-title>{{ $t('style.h2') }}</v-list-item-title>
            </v-list-item>
            <v-list-item @click="editor.chain().focus().toggleHeading({ level: 3 }).run()" :active="editor.isActive('heading', { level: 3 })">
              <v-list-item-title>{{ $t('style.h3') }}</v-list-item-title>
            </v-list-item>
            <v-list-item 
              @click="editor.chain().focus().toggleRubric().run()" 
              :active="editor?.value?.getAttributes('paragraph')?.class === 'rubric'">
              <v-list-item-title>{{ $t('style.rubric') }}</v-list-item-title>
            </v-list-item>
          </v-list>
        </v-menu>

        <v-divider vertical class="mx-1"></v-divider>

        <v-btn-toggle v-bind="null" multiple density="compact" variant="text">
          <v-btn @click="editor.chain().focus().toggleBold().run()" :active="editor.isActive('bold')" icon="mdi-format-bold"></v-btn>
          <v-btn @click="editor.chain().focus().toggleItalic().run()" :active="editor.isActive('italic')" icon="mdi-format-italic"></v-btn>
        </v-btn-toggle>

        <v-divider vertical class="mx-1"></v-divider>

        <v-btn-toggle v-bind="null" multiple density="compact" variant="text">
          <v-btn @click="editor.chain().focus().toggleBulletList().run()" :active="editor.isActive('bulletList')" icon="mdi-format-list-bulleted"></v-btn>
          <v-btn @click="editor.chain().focus().toggleOrderedList().run()" :active="editor.isActive('orderedList')" icon="mdi-format-list-numbered"></v-btn>
        </v-btn-toggle>

        <v-divider vertical class="mx-1"></v-divider>

        <v-btn-toggle v-bind="null" multiple density="compact" variant="text">
          <v-btn @click="editor.chain().focus().setTextAlign('left').run()" :active="editor.isActive({ textAlign: 'left' })" icon="mdi-format-align-left"></v-btn>
          <v-btn @click="editor.chain().focus().setTextAlign('center').run()" :active="editor.isActive({ textAlign: 'center' })" icon="mdi-format-align-center"></v-btn>
          <v-btn @click="editor.chain().focus().setTextAlign('justify').run()" :active="editor.isActive({ textAlign: 'justify' })" icon="mdi-format-align-justify"></v-btn>
        </v-btn-toggle>

        <v-divider vertical class="mx-1"></v-divider>

        <v-btn 
          @click="openLinkDialog" 
          :disabled="editor?.state?.selection?.empty"
          icon="mdi-link-variant-plus"
          density="compact"
          variant="text"
        ></v-btn>

        <v-divider vertical class="mx-1"></v-divider>

        <!-- Размер / цвет -->
        <div class="d-flex align-center">
          <v-btn icon density="compact" variant="text" title="Увеличить размер" @click="increaseSelectionFontSize">
            <v-icon>mdi-arrow-up-bold</v-icon>
          </v-btn>
          <v-btn icon density="compact" variant="text" title="Уменьшить размер" @click="decreaseSelectionFontSize">
            <v-icon>mdi-arrow-down-bold</v-icon>
          </v-btn>

          <v-btn icon density="compact" variant="text" :color="isSelectionRed ? 'error' : undefined" title="Сделать красным / Убрать красный" @click="toggleRedColor">
            <v-icon>mdi-format-color-text</v-icon>
          </v-btn>
        </div>

        <v-divider vertical class="mx-1"></v-divider>

        <template v-if="isNovena">
          <v-divider vertical class="mx-1"></v-divider>
          <div class="d-flex align-center ga-2">
            <v-btn-toggle
                :model-value="currentMarker"
                @update:model-value="setMarker"
                density="compact"
                variant="outlined"
            >
              <v-btn value="start" title="Пазначыць як уступ">
                <v-icon>mdi-play-circle-outline</v-icon>
              </v-btn>
              <v-btn value="finish" title="Пазначыць як заканчэнне">
                <v-icon>mdi-flag-checkered</v-icon>
              </v-btn>
            </v-btn-toggle>
            <div class="d-flex align-center ga-1">
              <span class="text-caption mr-1 text-disabled">Дзень:</span>
              <v-btn-toggle
                :model-value="currentDayMarker"
                @update:model-value="setDayMarker"
                density="compact"
                variant="outlined"
                divided
              >
                <v-btn v-for="day in 9" :key="day" :value="day" size="x-small">{{ day }}</v-btn>
              </v-btn-toggle>
              <v-btn
                icon="mdi-eraser-variant"
                density="compact"
                variant="text"
                title="Сцерці метку дня"
                @click="setDayMarker(null)"
              ></v-btn>
            </div>
          </div>
        </template>
      </div>

      <div class="editor-content-wrapper">
        <EditorContent :editor="editor" />
      </div>
    </div>

    <v-dialog v-model="isLinkDialogOpen" max-width="600px" scrollable>
       <v-card>
        <v-card-title class="headline">{{ $t('linkedNotesSelect') }}</v-card-title>
        <v-card-text class="pa-4">
          <v-text-field
            v-model="searchQuery"
            :placeholder="$t('searchPlaceholder')"
            variant="outlined"
            density="compact"
            autofocus
            hide-details
            class="mb-4"
          ></v-text-field>
          <v-list v-if="filteredNotes.length > 0">
            <v-list-item
              v-for="note in filteredNotes"
              :key="note.id"
              :title="getTitle(note)"
              @click="setLink(note.id)"
            >
              <template v-slot:prepend>
                <v-icon>mdi-note-text-outline</v-icon>
              </template>
            </v-list-item>
          </v-list>
          <div v-else class="text-center text-grey py-4">{{ $t('noNotesFound') }}</div>
        </v-card-text>
      </v-card>
    </v-dialog>
  </div>
</template>

<script setup>
import { ref, computed, watch, onBeforeUnmount } from 'vue';
import { useEditor, EditorContent } from '@tiptap/vue-3';
import StarterKit from '@tiptap/starter-kit';
import TextAlign from '@tiptap/extension-text-align';
import Link from '@tiptap/extension-link';
import Paragraph from '@tiptap/extension-paragraph'; // default import
import * as TextStyleModule from '@tiptap/extension-text-style';
import * as ColorModule from '@tiptap/extension-color';
const TextStyle = TextStyleModule.default ?? TextStyleModule.TextStyle ?? TextStyleModule;
const Color = ColorModule.default ?? ColorModule.Color ?? ColorModule;

import { useI18n } from 'vue-i18n';
import { useItems } from '@/composables/useItems';

const { t } = useI18n();

const props = defineProps({
  modelValue: { type: String, default: '' },
  isNovena: { type: Boolean, default: false }
});
const emit = defineEmits(['update:modelValue']);
const { items, getTitle } = useItems();

// Custom paragraph extension
const CustomParagraph = Paragraph.extend({
  addAttributes() {
    return {
      textAlign: {
        default: 'left',
        renderHTML: attributes => ({ style: `text-align: ${attributes.textAlign}` }),
        parseHTML: element => element.style.textAlign || 'left',
      },
      class: {
        default: null,
        parseHTML: element => element.getAttribute('class'),
        renderHTML: attributes => (attributes.class ? { class: attributes.class } : {}),
      },
      dayMarker: {
        default: null,
        parseHTML: element => element.getAttribute('data-day'),
        renderHTML: attributes => (attributes.dayMarker ? { 'data-day': attributes.dayMarker } : {}),
      },
      marker: {
        default: null,
        parseHTML: element => element.getAttribute('data-marker'),
        renderHTML: attributes => (attributes.marker ? { 'data-marker': attributes.marker } : {}),
      },
    };
  },
  addCommands() {
    return {
      toggleRubric: () => ({ commands, state }) => {
        const currentClass = state.selection?.$from?.parent?.attrs?.class ?? null;
        return commands.updateAttributes('paragraph', { class: currentClass === 'rubric' ? null : 'rubric' });
      },
      setDayMarker: (day) => ({ commands }) => {
        return commands.updateAttributes('paragraph', { dayMarker: day });
      },
      setMarker: (type) => ({ commands }) => {
        return commands.updateAttributes('paragraph', { marker: type, dayMarker: null });
      }
    };
  },
});

const editor = useEditor({
  content: props.modelValue,
  extensions: [
    StarterKit.configure({
      heading: { levels: [2, 3] },
      paragraph: false,
      link: false,
    }),
    CustomParagraph,
    TextStyle.configure?.({}),
    Color.configure?.({}),
    TextAlign.configure({
      types: ['heading', 'paragraph'],
    }),
    Link.configure({
      openOnClick: false,
      autolink: true,
    }),
  ],
  onUpdate: () => {
    emit('update:modelValue', editor.value.getHTML());
  },
});

// Toolbar label
const currentStyleLabel = computed(() => {
  if (!editor.value) return '';
  if (editor.value.isActive('heading', { level: 2 })) return t('style.h2');
  if (editor.value.isActive('heading', { level: 3 })) return t('style.h3');
  if (editor.value.getAttributes('paragraph')?.class === 'rubric') return t('style.rubric');
  return t('style.normal');
});

// Link dialog state
const isLinkDialogOpen = ref(false);
const searchQuery = ref('');
const filteredNotes = computed(() => {
  if (!searchQuery.value) return items.value;
  return items.value.filter(note => getTitle(note).toLowerCase().includes(searchQuery.value.toLowerCase()));
});
function openLinkDialog() {
  if (editor.value.isActive('link')) {
    editor.value.chain().focus().unsetLink().run();
  } else {
    isLinkDialogOpen.value = true;
  }
}
function setLink(noteId) {
  const url = `/item/${noteId}`;
  editor.value.chain().focus().extendMarkRange('link').setLink({ href: url }).run();
  isLinkDialogOpen.value = false;
  searchQuery.value = '';
}

// Novena markers
const currentDayMarker = computed(() => {
  if (!editor.value || !editor.value.isActive('paragraph')) return null;
  return editor.value.getAttributes('paragraph').dayMarker;
});
const currentMarker = computed(() => {
  if (!editor.value || !editor.value.isActive('paragraph')) return null;
  return editor.value.getAttributes('paragraph').marker;
});
function setDayMarker(day) {
  if (currentDayMarker.value === day) {
    editor.value.chain().focus().setDayMarker(null).run();
  } else {
    editor.value.chain().focus().setDayMarker(day).run();
  }
}
function setMarker(type) {
  if (currentMarker.value === type) {
    editor.value.chain().focus().setMarker(null).run();
  } else {
    editor.value.chain().focus().setMarker(type).run();
  }
}

// Font size / color helpers
function parseStyleString(style = '') {
  const obj = {};
  style.split(';').map(s => s.trim()).filter(Boolean).forEach(pair => {
    const [k, v] = pair.split(':').map(s => s.trim());
    if (k && v) obj[k] = v;
  });
  return obj;
}
function styleObjectToString(obj = {}) {
  return Object.entries(obj).map(([k, v]) => `${k}: ${v}`).join('; ');
}
const DEFAULT_BASE_PX = 16;
const SIZE_STEP_PX = 2;
const MIN_FONT_PX = 10;

function getCurrentTextStyleObj() {
  const attrs = editor.value?.getAttributes('textStyle') || {};
  const styleStr = attrs.style || '';
  return parseStyleString(styleStr);
}

function applyFontSizePx(newPx) {
  const styleObj = getCurrentTextStyleObj();
  styleObj['font-size'] = `${newPx}px`;
  const newStyle = styleObjectToString(styleObj);
  editor.value.chain().focus().extendMarkRange('textStyle').setMark('textStyle', { style: newStyle }).run();
  // debug
  // console.log('[Editor] applied textStyle:', editor.value.getAttributes('textStyle'));
}

function increaseSelectionFontSize() {
  if (!editor.value) return;
  if (editor.value.state.selection.empty) {
    // optionally select word: editor.value.chain().focus().selectWord().run();
    console.warn('[Editor] selection is collapsed — select text to change existing font-size.');
  }
  const styleObj = getCurrentTextStyleObj();
  let font = styleObj['font-size'] || null;
  let currentPx = null;
  if (font) {
    const m = font.match(/([\d.]+)(px|rem|em)/);
    if (m) {
      const value = parseFloat(m[1]);
      const unit = m[2];
      if (unit === 'px') currentPx = value;
      else if (unit === 'rem' || unit === 'em') currentPx = Math.round(value * DEFAULT_BASE_PX);
    }
  }
  if (!currentPx) currentPx = DEFAULT_BASE_PX;
  const newPx = Math.round(currentPx + SIZE_STEP_PX);
  applyFontSizePx(newPx);
}

function decreaseSelectionFontSize() {
  if (!editor.value) return;
  if (editor.value.state.selection.empty) {
    console.warn('[Editor] selection is collapsed — select text to change existing font-size.');
  }
  const styleObj = getCurrentTextStyleObj();
  let font = styleObj['font-size'] || null;
  let currentPx = null;
  if (font) {
    const m = font.match(/([\d.]+)(px|rem|em)/);
    if (m) {
      const value = parseFloat(m[1]);
      const unit = m[2];
      if (unit === 'px') currentPx = value;
      else if (unit === 'rem' || unit === 'em') currentPx = Math.round(value * DEFAULT_BASE_PX);
    }
  }
  if (!currentPx) currentPx = DEFAULT_BASE_PX;
  const newPx = Math.max(MIN_FONT_PX, Math.round(currentPx - SIZE_STEP_PX));
  applyFontSizePx(newPx);
}

const isSelectionRed = computed(() => {
  if (!editor.value) return false;
  const attrs = editor.value.getAttributes('textStyle') || {};
  const styleObj = parseStyleString(attrs.style || '');
  const color = styleObj.color || attrs.color;
  if (!color) return false;
  return color === 'red' || color === '#ff0000' || color.startsWith('rgb(255,0,0');
});

function toggleRedColor() {
  if (!editor.value) return;
  try {
    if (isSelectionRed.value) {
      const styleObj = getCurrentTextStyleObj();
      delete styleObj.color;
      const newStyle = styleObjectToString(styleObj);
      if (newStyle) {
        editor.value.chain().focus().extendMarkRange('textStyle').setMark('textStyle', { style: newStyle }).run();
      } else {
        editor.value.chain().focus().unsetMark('textStyle').run();
        try { editor.value.chain().focus().unsetColor().run(); } catch (e) {}
      }
    } else {
      try {
        editor.value.chain().focus().setColor('red').run();
      } catch {
        const styleObj = getCurrentTextStyleObj();
        styleObj.color = 'red';
        const newStyle = styleObjectToString(styleObj);
        editor.value.chain().focus().extendMarkRange('textStyle').setMark('textStyle', { style: newStyle }).run();
      }
    }
  } catch (e) {
    console.error('toggleRedColor error', e);
  }
}

watch(() => props.modelValue, (value) => {
  if (editor.value && editor.value.getHTML() !== value) {
    editor.value.commands.setContent(value, false);
  }
});

onBeforeUnmount(() => {
  if (editor.value) editor.value.destroy();
});
</script>

<style scoped>
.editor-wrapper {
  border: 1px solid rgba(var(--v-border-color), var(--v-border-opacity));
  border-radius: 4px;
  position: relative;
  display: flex;
  flex-direction: column;
  max-height: 70vh;
}
.editor-toolbar {
  position: sticky;
  top: 0;
  z-index: 10;
  background-color: rgb(var(--v-theme-surface));
  border-bottom: 1px solid rgba(var(--v-border-color), var(--v-border-opacity));
  flex-shrink: 0;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  padding: 4px 8px;
  gap: 4px;
}
.editor-content-wrapper {
  overflow-y: auto;
  flex-grow: 1;
}
.editor-content-wrapper > :deep(.ProseMirror) {
  padding: 8px 12px;
}
</style>
```

### src/components/FilterSheet.vue
```
<template>
  <v-bottom-sheet v-model="isFilterSheetOpen">
    <v-card class="pa-4">
      <v-card-title>{{ $t('filters') }}</v-card-title> <!-- Изменили заголовок -->
      <v-card-text>
        <!-- ✅ НОВЫЙ БЛОК ДЛЯ ФИЛЬТРА ПО ЯЗЫКАМ -->
        <!-- <div class="text-subtitle-1 font-weight-medium mb-2">{{ $t('language') }}</div> -->
        <div v-if="allLangs.length === 0" class="text-grey pa-2">Нет языков для выбора</div>
        <v-chip-group v-else v-model="selectedLangs" column multiple>
          <v-chip
            v-for="lang in allLangs"
            :key="lang"
            :value="lang"
            filter
            variant="outlined"
            class="ma-1 text-uppercase"
            size="small"
          >
            {{ lang }}
          </v-chip>
        </v-chip-group>

        <v-divider class="my-4"></v-divider>

        <!-- Существующий блок для тегов -->
        <!-- <div class="text-subtitle-1 font-weight-medium mb-2">{{ $t('tags') }}</div> -->
        <div v-if="allTags.length === 0" class="text-grey pa-2">Нет тегов для выбора</div>
        <v-chip-group v-else v-model="selectedTags" column multiple>
          <v-chip
            v-for="tag in allTags"
            :key="tag"
            :value="tag"
            filter
            variant="outlined"
            class="ma-1"
            size="default"
          >
            {{ tag }}
          </v-chip>
        </v-chip-group>
      </v-card-text>
      <v-card-actions>
        <v-spacer></v-spacer>
        <v-btn color="primary" variant="text" @click="isFilterSheetOpen = false">{{ $t('done') }}</v-btn>
      </v-card-actions>
    </v-card>
  </v-bottom-sheet>
</template>

<script setup>
import { useAppBar } from '@/composables/useAppBar';
import { useFilters } from '@/composables/useFilters';
import { useItems } from '@/composables/useItems';

const { isFilterSheetOpen } = useAppBar();
const { selectedTags, selectedLangs } = useFilters(); // ✅ Получаем selectedLangs
const { allTags, allLangs } = useItems(); // ✅ Получаем allLangs
</script>
```

### src/components/HolyMassView.vue
```
<template>
  <div class="holy-mass-container">
    <div v-if="isLoading" class="text-center mt-16">
        <v-progress-circular indeterminate color="primary" size="64"></v-progress-circular>
    </div>
    <div v-else-if="!massItem" class="text-center mt-16">
        <v-icon size="64" class="mb-4">mdi-text-box-remove-outline</v-icon>
        <h2 class="text-h5 mb-4">{{ $t('noteNotFound') }}</h2>
        <p>{{ $t('noteNotFoundMessage') }}</p>
    </div>
    <div v-else ref="contentArea" class="content-wrapper">
        <!-- ✅✅✅ ДОБАВЛЕН БЛОК ПЕРЕКЛЮЧЕНИЯ ЯЗЫКОВ ✅✅✅ -->
        <v-chip-group class="mb-6">
          <v-chip
            v-for="version in allLanguageVersions"
            :key="version.id"
            label
            :variant="version.id === massItem.id ? 'flat' : 'outlined'"
            :color="version.id === massItem.id ? 'primary' : ''"
            @click="router.push({ params: { id: version.id } })"
          >
            <strong class="text-uppercase mr-1">{{ version.lang }}</strong>
            
          </v-chip>
        </v-chip-group>

        <h2 class="text-h4 font-weight-bold mb-6">{{ getTitle(massItem) }}</h2>
        <div v-html="massItem.text" class="note-content-area"></div>
    </div>

    <!-- ПЛАВАЮЩИЕ КНОПКИ НАВИГАЦИИ -->
    <div v-if="headings.length > 1" class="fab-container-mass">
        <v-btn icon="mdi-chevron-up" class="mb-2" @click="scrollToHeading('prev')" :disabled="currentHeadingIndex <= 0"></v-btn>
        <v-btn icon="mdi-chevron-down" @click="scrollToHeading('next')" :disabled="currentHeadingIndex >= headings.length - 1"></v-btn>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted, watch, nextTick } from 'vue'; // ✅ 1. Импортируем nextTick
import { useRoute, useRouter } from 'vue-router';
import { useItems } from '@/composables/useItems';
import { useI18n } from 'vue-i18n';

const route = useRoute();
const router = useRouter();
const { t } = useI18n();

// ❗️ ВАЖНО: Укажите здесь ID "главной" версии Мессы
const HOLY_MASS_BASE_ID = 'wPt0x7dgurGCe74hdl6C'; // Я вставил пример ID, замените на свой

const { items, isLoading, getTitle } = useItems();

const currentItemId = computed(() => route.params.id || HOLY_MASS_BASE_ID);
const massItem = computed(() => items.value.find(i => i.id === currentItemId.value));
const translations = computed(() => {
    const baseItem = items.value.find(i => i.id === HOLY_MASS_BASE_ID);
    return baseItem?.translationIds?.map(id => items.value.find(note => note.id === id)).filter(Boolean) || [];
});
const allLanguageVersions = computed(() => {
  const base = items.value.find(i => i.id === HOLY_MASS_BASE_ID);
  if (!base) return [];
  const all = [base, ...translations.value];
  return all.sort((a, b) => a.lang.localeCompare(b.lang));
});


const contentArea = ref(null);
const headings = ref([]);
const currentHeadingIndex = ref(-1);

const findHeadings = () => {
    if (contentArea.value) {
        headings.value = Array.from(contentArea.value.querySelectorAll('.note-content-area h3'));
        currentHeadingIndex.value = -1;
        console.log(`[HolyMassView] Found ${headings.value.length} headings.`);
    }
};

// ✅ 2. Используем watch вместо onMounted для поиска заголовков
watch(massItem, (newItem) => {
    // Этот наблюдатель сработает как при первой загрузке данных, так и при смене языка
    if (newItem && newItem.text) {
        // nextTick гарантирует, что мы будем искать заголовки
        // ПОСЛЕ того, как Vue обновил v-html
        nextTick(() => {
            findHeadings();
        });
    }
}, { immediate: true }); // immediate: true заставит watch сработать при первой же загрузке компонента

const scrollToHeading = (direction) => {
    if (headings.value.length === 0) return;
    let nextIndex = currentHeadingIndex.value;
    if (direction === 'next') {
        nextIndex = Math.min(headings.value.length - 1, nextIndex + 1);
    } else {
        nextIndex = Math.max(0, nextIndex - 1);
    }
    headings.value[nextIndex]?.scrollIntoView({ behavior: 'smooth', block: 'start' });
};

// Отслеживание текущего заголовка
const onScroll = () => {
    if(headings.value.length === 0) return;
    const scrollPosition = window.scrollY + window.innerHeight / 2;
    const newIndex = headings.value.findIndex(h => h.offsetTop > scrollPosition) - 1;
    currentHeadingIndex.value = newIndex < 0 ? headings.value.length - 1 : newIndex;
};


// ✅ 3. Упрощаем onMounted - теперь он только добавляет слушатель скролла
onMounted(() => {
    window.addEventListener('scroll', onScroll, { passive: true });
});

onUnmounted(() => {
    window.removeEventListener('scroll', onScroll);
});
</script>

<style scoped>
.holy-mass-container {
    padding: 16px;
    max-width: 800px;
    margin: 0 auto;
}
.content-wrapper {
    padding-bottom: 100px; /* Отступ снизу, чтобы кнопки не перекрывали текст */
}
.fab-container-mass {
    position: fixed;
    bottom: 24px;
    right: 24px;
    display: flex;
    flex-direction: column;
    z-index: 5;
}
</style>
```

### src/components/ItemForm.vue
```
<template>
  <v-container>
    <v-form v-if="isFormReady" @submit.prevent="handleSave">

      <!-- ✅ НОВЫЙ БЛОК: Выбор языка и основной заголовок -->
      <v-select
        v-model="form.lang"
        :items="langOptions"
        item-title="title"
        item-value="value"
        :label="$t('noteLanguage')"
        variant="outlined"
        class="mb-4"
        :disabled="isEditMode"
        :hint="isEditMode ? $t('languageCannotBeChanged') : ''"
        persistent-hint
      ></v-select>
      
      <v-text-field
        v-model="form.title"
        :label="$t('title')"
        variant="outlined"
        class="mb-4"
      ></v-text-field>

      <Editor v-model="form.text" :is-novena="form.isNovenaPrayer" />

      <v-combobox
        v-model="form.tags"
        :items="allTags"
        :label="$t('tags')"
        multiple
        chips
        clearable
        variant="outlined"
        class="mt-4"
      ></v-combobox>
      
      <v-divider class="my-4"></v-divider>

      <!-- ✅ НОВЫЙ БЛОК: Управление переводами -->
      <h3 class="text-subtitle-1 mb-2">{{ $t('translations') }}</h3>
      <div v-if="currentlyLinkedTranslations.length > 0" class="mb-3">
        <v-chip
          v-for="trans in currentlyLinkedTranslations"
          :key="trans.id"
          class="mr-2 mb-2"
          closable
          @click:close="removeTranslation(trans.id)"
        >
    <v-avatar color="grey-lighten-1" start size="22">
    <span class="text-uppercase font-weight-bold text-white" style="font-size: 0.7rem;">{{ trans.lang }}</span>
  </v-avatar>   
        {{ getTitle(trans) }}
        </v-chip>
      </div>
      <v-btn @click="isTranslationDialogOpen = true" prepend-icon="mdi-translate">{{ $t('addTranslation') }}</v-btn>

      <v-divider class="my-4"></v-divider>
      
      <!-- Блок связанных заметок (остается без изменений) -->
      <h3 class="text-subtitle-1 mb-2">{{ $t('linkedNotesAdd') }}</h3>
      <div v-if="form.linkedNoteIds && form.linkedNoteIds.length > 0" class="mb-3">
        <v-chip
          v-for="linkedNote in currentlyLinkedNotes"
          :key="linkedNote.id"
          class="mr-2 mb-2"
          closable
          @click:close="removeLink(linkedNote.id)"
        >
          {{ getTitle(linkedNote) }}
        </v-chip>
      </div>
      <v-btn @click="isLinkDialogOpen = true" prepend-icon="mdi-link-plus">{{ $t('linkedNotesAdd') }}</v-btn>

      <v-divider class="my-4"></v-divider>
      <v-text-field v-model="form.source" :label="$t('source')" variant="outlined" class="mb-4" clearable></v-text-field>
      
      <v-divider class="my-4"></v-divider>
      <h3 class="text-subtitle-1 mb-2">{{ $t('novenaSettings') }}</h3>
      <v-switch v-model="form.isNovenaPrayer" :label="$t('isNovenaPrayerLabel')" color="primary" inset class="mb-2"></v-switch>
      <v-expand-transition>
        <div v-if="form.isNovenaPrayer">
          <v-text-field v-model="form.recommendedDate" :label="$t('recommendedDateLabel')" :hint="$t('recommendedDateHint')" type="date" variant="outlined" clearable></v-text-field>
        </div>
      </v-expand-transition>

      <v-divider class="my-4"></v-divider>
      <v-switch v-model="form.hidden" :label="$t('hiddenNote')" color="primary" inset class="mb-2"></v-switch>
    </v-form>

    <div v-else class="text-center mt-16">
      <v-progress-circular indeterminate color="primary"></v-progress-circular>
    </div>

    <!-- Диалог для переводов -->
    <v-dialog v-model="isTranslationDialogOpen" max-width="500px">
      <v-card>
        <v-card-title>{{ $t('selectTranslation') }}</v-card-title>
        <v-text-field v-model="translationSearchQuery" :placeholder="$t('searchPlaceholder')" variant="filled" density="compact" hide-details autofocus class="mx-4 mb-2"></v-text-field>
        <v-list>
          <v-list-item
            v-for="note in availableNotesToTranslate"
            :key="note.id"
            :title="getTitle(note)"
            :subtitle="`Язык: ${note.lang}`"
            @click="addTranslation(note.id)"
          >
           <template v-slot:prepend>
   <!-- ✅ ИЗМЕНЕНИЕ: Используем v-avatar -->
    <v-avatar color="grey-lighten-3" size="32" class="mr-4">
        <span class="text-uppercase font-weight-bold text-grey-darken-1">{{ note.lang }}</span>
    </v-avatar>  
  
          </template>
          </v-list-item>
        </v-list>
      </v-card>
    </v-dialog>

    <!-- Диалог для связей (остается) -->
   <v-dialog v-model="isLinkDialogOpen" max-width="500px">
      <v-card>
        <v-card-title>{{ $t('linkedNotesSelect') }}</v-card-title>
         <v-text-field v-model="linkSearchQuery" :placeholder="$t('searchPlaceholder')" variant="filled" density="compact" hide-details autofocus class="mx-4 mb-2"></v-text-field>
        <v-list>
          <v-list-item
            v-for="note in availableNotesToLink"
            :key="note.id"
            :title="getTitle(note)" 
            @click="addLink(note.id)"
          ></v-list-item>
        </v-list>
      </v-card>
    </v-dialog>
  </v-container>
</template>
<script setup>
import { ref, watch, onMounted, onUnmounted, computed, inject } from 'vue';
import { useRouter } from 'vue-router';
import { useItems } from '@/composables/useItems';
import Editor from '@/components/Editor.vue';
import { useI18n } from 'vue-i18n';
import { useNotifier } from '@/composables/useNotifier';

const props = defineProps({ id: { type: String, required: false } });
const router = useRouter();
const { t } = useI18n();
const { items, addItem, updateItem, allTags, getTitle, linkTranslations } = useItems();
const { showSuccess } = useNotifier();
const registerSaveAction = inject('registerSaveAction');

const isEditMode = computed(() => !!props.id);
const isFormReady = ref(false);

const langOptions = ref([
    { title: 'Беларуская', value: 'be'},
    { title: 'Русский', value: 'ru'},
    { title: 'Latina', value: 'la'},
    { title: 'Polski', value: 'pl'},
]);


const form = ref({
  title: '',
  text: '',
  lang: 'be',
  tags: [],
  source: '',
  linkedNoteIds: [],
  translationIds: [],
  isNovenaPrayer: false,
  recommendedDate: null,
  hidden: false,
});

// --- Логика для управления связями ---
const isLinkDialogOpen = ref(false);
const linkSearchQuery = ref('');
const currentlyLinkedNotes = computed(() => form.value.linkedNoteIds?.map(id => items.value.find(item => item.id === id)).filter(Boolean) || []);
const availableNotesToLink = computed(() => {
    return items.value.filter(item => {
        const isNotSelf = item.id !== props.id;
        const isNotLinked = !form.value.linkedNoteIds?.includes(item.id);
        const matchesSearch = linkSearchQuery.value ? getTitle(item).toLowerCase().includes(linkSearchQuery.value.toLowerCase()) : true;
        return isNotSelf && isNotLinked && matchesSearch;
    });
});
function addLink(noteId) { if (!form.value.linkedNoteIds) form.value.linkedNoteIds = []; form.value.linkedNoteIds.push(noteId); isLinkDialogOpen.value = false; linkSearchQuery.value = ''; }
function removeLink(noteId) { form.value.linkedNoteIds = form.value.linkedNoteIds.filter(id => id !== noteId); }

// --- Логика Управления переводами ---
const isTranslationDialogOpen = ref(false);
const translationSearchQuery = ref('');
const currentlyLinkedTranslations = computed(() => form.value.translationIds?.map(id => items.value.find(item => item.id === id)).filter(Boolean) || []);
const availableNotesToTranslate = computed(() => {
  return items.value.filter(item => {
    if (item.id === props.id) return false;
    if (form.value.translationIds?.includes(item.id)) return false;
    if (item.lang === form.value.lang) return false;
    const matchesSearch = translationSearchQuery.value ? getTitle(item).toLowerCase().includes(translationSearchQuery.value.toLowerCase()) : true;
    return matchesSearch;
  });
});

async function addTranslation(noteId) {
    if (!form.value.translationIds) form.value.translationIds = [];
    form.value.translationIds.push(noteId);
    await linkTranslations(props.id, noteId);
    showSuccess(t('translationLinked'));
    isTranslationDialogOpen.value = false;
    translationSearchQuery.value = '';
}

async function removeTranslation(noteId) {
    form.value.translationIds = form.value.translationIds.filter(id => id !== noteId);
    await linkTranslations(props.id, noteId, true);
    showSuccess(t('translationUnlinked'));
}

async function handleSave() {
  if (!form.value.title || !form.value.title.trim()) {
    alert(t('titleRequired'));
    return;
  }
  
  const dataToSave = { ...form.value };

  if (isEditMode.value) {
    await updateItem(props.id, dataToSave);
  } else {
    const newDocRef = await addItem(dataToSave);
    if (dataToSave.translationIds.length > 0) {
        for (const transId of dataToSave.translationIds) {
            await linkTranslations(newDocRef.id, transId);
        }
    }
  }
  showSuccess(t('noteSavedSuccess'));
  router.push({ name: 'ItemsList' });
}

// ✅ ✅ ✅ ИСПРАВЛЕННЫЙ БЛОК ✅ ✅ ✅
onMounted(() => {
  registerSaveAction(handleSave);
  if (isEditMode.value) {
    // Объявляем переменную, которая будет хранить функцию для остановки наблюдателя
    let unwatch = null;

    // Присваиваем результат вызова watch этой переменной
    unwatch = watch(items, (newItems) => {
      const itemToEdit = newItems.find(i => i.id === props.id);
      if (itemToEdit) {
        form.value = { 
          title: itemToEdit.title || '',
          text: itemToEdit.text || '',
          lang: itemToEdit.lang || 'be',
          tags: itemToEdit.tags || [],
          source: itemToEdit.source || '',
          linkedNoteIds: itemToEdit.linkedNoteIds || [],
          translationIds: itemToEdit.translationIds || [],
          isNovenaPrayer: itemToEdit.isNovenaPrayer || false,
          recommendedDate: itemToEdit.recommendedDate || null,
          hidden: itemToEdit.hidden || false
        };
        isFormReady.value = true;
        
        // Проверяем, существует ли функция, и вызываем ее, чтобы остановить наблюдение
        if (unwatch) {
          unwatch();
        }
      }
    }, { immediate: true });
  } else {
    isFormReady.value = true;
  }
});

onUnmounted(() => {
  registerSaveAction(null);
});
</script>
```

### src/components/ItemsList.vue
```
<template>
  <v-container class="items-list-container">
    <div v-if="isLoading">
      <v-skeleton-loader v-for="n in 3" :key="n" type="card" class="mb-4"></v-skeleton-loader>
    </div>
    <div v-else>
      <div v-if="settings.viewMode === 'card'">
        <v-card v-for="item in filteredItems" :key="item.id" class="mb-4" elevation="2">
          <!-- ✅ ИЗМЕНЕНИЕ: Используем хелпер getTitle -->
          <v-card-title class="font-weight-bold d-flex align-center">
            <v-icon v-if="novenaStore.isNovenaActive(item.id)" color="primary" class="mr-2">mdi-calendar-check</v-icon>
            <v-btn :icon="settings.isPinned(item.id) ? 'mdi-pin' : 'mdi-pin-outline'" :color="settings.isPinned(item.id) ? 'primary' : 'grey'" variant="text" size="small" class="mr-2" @click.stop="settings.togglePin(item.id)"></v-btn>
            <span @click="viewItem(item.id)" class="flex-grow-1" style="cursor: pointer;">{{ getTitle(item) }}</span>
       <!-- ✅ ИЗМЕНЕНИЕ: Текстовая метка языка -->
  <v-chip size="x-small" variant="tonal" class="ml-2 text-uppercase">{{ item.lang }}</v-chip>
</v-card-title>
          <v-card-text class="pb-0" @click="viewItem(item.id)" style="cursor: pointer;">
            <p class="mb-4 text-medium-emphasis">{{ getPreviewText(item) }}</p>
            <v-chip-group><v-chip v-for="tag in item.tags" :key="tag" size="small" color="primary" variant="tonal">{{ tag }}</v-chip></v-chip-group>
          </v-card-text>
          <v-card-actions v-if="authStore.user">
            <v-icon v-if="item.hidden" color="grey" class="ml-2">mdi-eye-off-outline</v-icon>
            <v-spacer></v-spacer>
            <v-btn color="grey-darken-1" variant="text" @click.stop="navigateToEdit(item.id)">{{ $t('edit') }}</v-btn>
            <v-btn color="error" variant="text" @click.stop="openDeleteDialog(item.id)">{{ $t('delete') }}</v-btn>
          </v-card-actions>
        </v-card>
      </div>
      <v-list v-else-if="settings.viewMode === 'compact'" lines="one" density="compact">
        <v-list-item v-for="item in filteredItems" :key="item.id" @click="viewItem(item.id)">
          <template v-slot:prepend>
            <v-btn :icon="settings.isPinned(item.id) ? 'mdi-pin' : 'mdi-pin-outline'" :color="settings.isPinned(item.id) ? 'primary' : 'grey'" variant="text" size="medium" class="mr-2" @click.stop="settings.togglePin(item.id)"></v-btn>
          </template>
          <!-- ✅ ИЗМЕНЕНИЕ: Используем хелпер getTitle -->
          <v-list-item-title>{{ getTitle(item) }}</v-list-item-title>
          <template v-if="!authStore.user" v-slot:append>
        <!-- ✅ ИЗМЕНЕНИЕ: Текстовая метка языка -->
        <v-chip size="x-small" variant="text" class="text-uppercase mr-2">{{ item.lang }}</v-chip>
       
            <v-progress-circular v-if="novenaStore.isNovenaActive(item.id)" :model-value="getNovenaProgress(item.id).percentage" :color="getNovenaProgress(item.id).color" size="24" width="2" class="ml-2"><small>{{ getNovenaProgress(item.id).completed }}</small></v-progress-circular>
            <v-icon v-if="item.hidden" color="grey" class="ml-2">mdi-eye-off-outline</v-icon>
          </template>
          <template v-if="authStore.user" v-slot:append>
           <!-- ✅ ИЗМЕНЕНИЕ: Текстовая метка языка -->
        <v-chip size="x-small" variant="text" class="text-uppercase mr-2">{{ item.lang }}</v-chip>
     
            <v-icon v-if="item.hidden" color="grey" class="ml-2">mdi-eye-off-outline</v-icon>
            <v-progress-circular v-if="novenaStore.isNovenaActive(item.id)" :model-value="getNovenaProgress(item.id).percentage" :color="getNovenaProgress(item.id).color" size="24" width="2" class="ml-2"><small>{{ getNovenaProgress(item.id).completed }}</small></v-progress-circular>
            <v-btn icon="mdi-pencil" variant="text" size="small" @click.stop="navigateToEdit(item.id)"></v-btn>
            <v-btn icon="mdi-delete" variant="text" size="small" @click.stop="openDeleteDialog(item.id)"></v-btn>
          </template>
        </v-list-item>
      </v-list>
      <div v-if="!isLoading && filteredItems.length === 0" class="text-center text-grey-darken-1 mt-16">
        <v-icon size="48" class="mb-2">mdi-note-off-outline</v-icon>
        <p>{{ $t('noNotesFound') }}</p>
      </div>
    </div>
    <v-btn v-if="authStore.user" icon location="bottom right" size="large" color="primary" position="fixed" variant="elevated" elevation="8" class="ma-4" @click="router.push({ name: 'ItemAdd' })">
      <v-icon>mdi-plus</v-icon>
    </v-btn>
    <v-dialog v-model="isDeleteDialogOpen" persistent max-width="400px">
      <v-card>
        <v-card-title class="text-h5">{{ $t('confirmDeletion') }}</v-card-title>
        <!-- ✅ ИЗМЕНЕНИЕ: Используем хелпер getTitle -->
        <v-card-text>{{ $t('deleteConfirmationMessage', { title: getTitle(itemToDelete) }) }}</v-card-text>
        <v-card-actions>
          <v-spacer></v-spacer>
          <v-btn variant="text" @click="closeDeleteDialog">{{ $t('cancel') }}</v-btn>
          <v-btn color="error" variant="flat" @click="confirmDeletion">{{ $t('delete') }}</v-btn>
        </v-card-actions>
      </v-card>
    </v-dialog>
  </v-container>
</template>

<script setup>
import { ref, computed } from 'vue';
import { useRouter } from 'vue-router';
import { useItems } from '@/composables/useItems';
import { useFilters } from '@/composables/useFilters';
import { useI18n } from 'vue-i18n';
import { useSettingsStore } from '@/stores/settings';
import { useAuthStore } from '@/stores/auth';
import { useNotifier } from '@/composables/useNotifier';
import { useNovenaStore } from '@/stores/novena';

const router = useRouter();
const { t } = useI18n();
const { items, isLoading, deleteItem, getTitle } = useItems();
const { search, selectedTags, selectedLangs } = useFilters();
const settings = useSettingsStore();
const authStore = useAuthStore();
const novenaStore = useNovenaStore();
const { showSuccess } = useNotifier();

const isDeleteDialogOpen = ref(false);
const itemToDeleteId = ref(null);
const itemToDelete = computed(() => itemToDeleteId.value ? items.value.find(item => item.id === itemToDeleteId.value) : null);

function getNovenaProgress(noteId) {
    const data = novenaStore.getNovenaData(noteId);
    if (!data || !data.totalDays) return { percentage: 0, color: 'grey', completed: 0 };
    const todayStr = novenaStore.getTodayDateString();
    const isTodayCompleted = data.completedDates.includes(todayStr);
    return {
        percentage: (data.completedDates.length / data.totalDays) * 100,
        completed: data.completedDates.length,
        color: isTodayCompleted ? 'success' : 'warning'
    };
}

function openDeleteDialog(id) {
  itemToDeleteId.value = id;
  isDeleteDialogOpen.value = true;
}

function closeDeleteDialog() {
  isDeleteDialogOpen.value = false;
  itemToDeleteId.value = null;
}

async function confirmDeletion() {
  if (itemToDeleteId.value) {
    await deleteItem(itemToDeleteId.value);
    showSuccess(t('noteDeletedSuccess'));
  }
  closeDeleteDialog();
}

function getPreviewText(item) {
  if (!item.textVersions) return 'Нет содержимого';
  const htmlContent = item.textVersions.be || item.textVersions.ru || item.textVersions.la || Object.values(item.textVersions).find(v => v) || '';
  if (!htmlContent) return 'Нет содержимого';
  const doc = new DOMParser().parseFromString(htmlContent, 'text/html');
  const text = (doc.body.textContent || "").trim();
  return text.length > 150 ? text.substring(0, 150) + '...' : text;
}
const filteredItems = computed(() => {
  if (isLoading.value) return [];
  return items.value.filter(item => {
    // Фильтр по скрытым заметкам
    if (!settings.showHiddenItems && item.hidden) {
      return false;
    }
    
    // ✅ ФИЛЬТР ПО ЯЗЫКАМ
    const langMatch = selectedLangs.value.length === 0 || selectedLangs.value.includes(item.lang);
    if (!langMatch) return false;
    // Фильтр по тегам
    const tagMatch = selectedTags.value.length === 0 || 
                     (item.tags && selectedTags.value.every(tag => item.tags.includes(tag)));
    if (!tagMatch) return false;
    // Фильтр по поисковому запросу
    const searchLower = search.value.toLowerCase().trim();
    if (searchLower) {
      const fullText = (item.title + ' ' + item.text).toLowerCase();
      return fullText.includes(searchLower);
    }
    
    return true; // Если все проверки пройдены
  });
});

function viewItem(id) { router.push({ name: 'ItemView', params: { id } }); }
function navigateToEdit(id) { router.push({ name: 'ItemEdit', params: { id } }); }
</script>
```

### src/components/ItemView.vue
```
<template>
  <v-container class="note-view-container">
    <div v-if="!isLoading && item">
      <!-- ✅ ИЗМЕНЕННЫЙ БЛОК С ФЛАГАМИ -->
      <div class="d-flex align-center justify-space-between flex-wrap gap-1">
        <!-- ✅ ИЗМЕНЕННЫЙ БЛОК ЯЗЫКОВ -->
<v-chip-group class="mb-2">
  <v-chip
    v-for="version in allLanguageVersions"
    :key="version.id"
    :to="{ name: 'ItemView', params: { id: version.id } }"
    label
    :variant="version.id === item.id ? 'flat' : 'outlined'"
    :color="version.id === item.id ? 'primary' : ''"
  >
    <strong class="text-uppercase mr-1">{{ version.lang }}</strong>
    
  </v-chip>
</v-chip-group>
      </div>

      <!-- Заголовок -->
      <h2 class="text-h5 font-weight-bold mb-4 note-content-area">{{ getTitle(item) }}</h2>


      <!-- Панель Новенны -->
      <v-expansion-panels v-if="novenaStore.isNovenaActive(props.id)" class="my-6">
        <v-expansion-panel>
          <v-expansion-panel-title>
            <div class="d-flex align-center justify-space-between w-100">
              <div class="d-flex align-center">
                <v-icon start color="primary">mdi-calendar-check</v-icon>
                <span class="font-weight-medium">{{ $t('prayerNovena') }}</span>
              </div>
              <div class="d-flex align-center mr-2">
                <v-progress-circular :model-value="novenaProgress.percentage" :color="novenaProgress.color" size="24"
                  width="2" class="mr-2">
                  <small>{{ novenaProgress.completed }}</small>
                </v-progress-circular>
                <span class="text-body-2 text-medium-emphasis">
                  {{ novenaProgress.completed }} / {{ novenaProgress.total }}
                </span>
              </div>
            </div>
          </v-expansion-panel-title>
          <v-expansion-panel-text>
            <NovenaTracker :note-id="props.id" />
          </v-expansion-panel-text>
        </v-expansion-panel>
      </v-expansion-panels>


      <!-- Текст молитвы (теперь только один) -->
      <div class="mb-4" @click="handleContentClick">
        <div v-html="processedHtml" class="note-content-area"></div>
      </div>


      <!-- Связанные заметки -->
      <div v-if="linkedNotes.length > 0" class="mt-8">
        <v-divider class="mb-4"></v-divider>
        <v-list lines="one" density="compact" class="pa-0 bg-transparent linked-notes-list">
          <v-list-item v-for="linkedNote in linkedNotes" :key="linkedNote.id"
            @click="router.push({ name: 'ItemView', params: { id: linkedNote.id } })" class="mb-1">
            <template v-slot:prepend>
              <v-icon color="grey-darken-1">mdi-link-variant</v-icon>
            </template>
            <v-list-item-title class="text-primary font-weight-medium">{{ getTitle(linkedNote) }}</v-list-item-title>
          </v-list-item>
        </v-list>
      </div>

      <!-- Кнопка для старта новенны -->
      <div v-if="item.isNovenaPrayer && !novenaStore.isNovenaActive(props.id)" class="text-center my-8">
        <v-btn @click="isNovenaDialogVisible = true" color="primary" variant="tonal" size="large"
          prepend-icon="mdi-play-circle-outline">
          {{ $t('startNovena') }}
        </v-btn>
      </div>

      <!-- Источник и теги -->
      <div class="mt-6 text-body-2 text-medium-emphasis">
        <div v-if="item.source">
          <v-divider class="my-3"></v-divider>
          <strong>{{ $t('sourceLabel') }}</strong> {{ item.source }}
        </div>
        <div v-if="item.tags && item.tags.length > 0" class="mt-3">
          <strong>{{ $t('tagsLabel') }}</strong> {{ item.tags.join(', ') }}
        </div>
      </div>
    </div>

    <!-- Загрузка и состояние "не найдено" -->
    <div v-else-if="!isLoading && !item" class="text-center mt-16">
      <v-icon size="64" class="mb-4">mdi-file-question-outline</v-icon>
      <h2 class="text-h5 mb-4">{{ $t('noteNotFound') }}</h2>
      <p class="text-medium-emphasis mb-6">{{ $t('noteNotFoundMessage') }}</p>
      <v-btn color="primary" :to="{ name: 'ItemsList' }">{{ $t('backToHome') }}</v-btn>
    </div>
    <div v-else class="text-center text-grey-darken-1 mt-16">
      <v-progress-circular indeterminate color="primary"></v-progress-circular>
    </div>

    <!-- БЛОК С ПЛАВАЮЩИМИ КНОПКАМИ "РИТУАЛА" -->
    <div v-if="isNovenaActiveAndInProgress && !isTodayCompleted" class="fab-container">
      <!-- Кнопка "К началу" -->
      <v-btn v-if="hasStartMarker" icon="mdi-cross" :color="hasScrolledToStart ? 'success' : 'secondary'"
        variant="tonal" class="mb-2" @click="executeScrollStep('start')" title="Да ўступу"></v-btn>

      <!-- Кнопка "К текущему дню" -->
      <v-btn v-if="currentNovenaDay" icon="mdi-crosshairs-gps" :color="hasScrolledToDay ? 'success' : 'secondary'"
        :disabled="!hasScrolledToStart" variant="tonal" class="mb-2" @click="executeScrollStep('day')"
        title="Да сённяшняга дня"></v-btn>

      <!-- Кнопка "К окончанию" -->
      <v-btn v-if="hasFinishMarker" icon="mdi-flag-checkered" :color="hasScrolledToFinish ? 'success' : 'secondary'"
        :disabled="!hasScrolledToDay" variant="tonal" class="mb-2" @click="executeScrollStep('finish')"
        title="Да заканчэння"></v-btn>

      <!-- Кнопка "Завершить день" -->
      <v-expand-transition>
        <v-btn v-if="showCompleteButton" icon="mdi-calendar-check" color="primary" variant="flat"
          @click="novenaStore.toggleDayCompletion(props.id, novenaStore.getTodayDateString())"
          title="Адзначыць дзень як выкананы"></v-btn>
      </v-expand-transition>
    </div>

    <!-- Если день уже завершен, показываем одну кнопку-галочку -->
    <div v-if="isNovenaActiveAndInProgress && isTodayCompleted" class="fab-container">
      <v-btn icon="mdi-calendar-check" color="success" variant="flat" title="Дзень выкананы!"
        @click="novenaStore.toggleDayCompletion(props.id, novenaStore.getTodayDateString())"></v-btn>
    </div>


    <!-- Диалог старта новенны -->
    <v-dialog v-model="isNovenaDialogVisible" max-width="400px">
      <v-card>
        <v-card-title>{{ $t('novenaDurationTitle') }}</v-card-title>
        <v-card-text>
          <p class="text-subtitle-1 mb-2">{{ $t('novenaDurationChoice') }}</p>
          <v-chip-group v-model="novenaDays" mandatory class="mb-4">
            <v-chip v-for="d in [7, 9, 33, 54]" :key="d" :value="d" filter>{{ d }} {{ $t('days') }}</v-chip>
          </v-chip-group>
          <p class="text-subtitle-1 mb-2">{{ $t('novenaDurationInput') }}</p>
          <v-text-field v-model.number="novenaDays" :label="$t('novenaDaysLabel')" type="number" variant="outlined"
            autofocus></v-text-field>
        </v-card-text>
        <v-card-actions>
          <v-spacer></v-spacer>
          <v-btn text @click="isNovenaDialogVisible = false">{{ $t('cancel') }}</v-btn>
          <v-btn color="primary" variant="flat" @click="handleStartNovena">{{ $t('start') }}</v-btn>
        </v-card-actions>
      </v-card>
    </v-dialog>

  </v-container>
</template>

<script setup>
import { ref, computed, watch, onBeforeUpdate, watchEffect, onUnmounted } from 'vue';
import { useRouter, onBeforeRouteLeave } from 'vue-router';
import { useItems } from '@/composables/useItems';
import { useSettingsStore } from '@/stores/settings';
import { useWakeLock } from '@/composables/useWakeLock';
import { useI18n } from 'vue-i18n';
import { useNovenaStore } from '@/stores/novena';
import NovenaTracker from '@/components/NovenaTracker.vue';



const props = defineProps({ id: { type: String, required: true } });
const router = useRouter();
const { t } = useI18n();
const { items, isLoading, getTitle } = useItems();
const novenaStore = useNovenaStore();
const settings = useSettingsStore();
const { requestWakeLock, releaseWakeLock } = useWakeLock();

const item = computed(() => items.value.find(i => i.id === props.id));
const translations = computed(() => item.value?.translationIds?.map(id => items.value.find(note => note.id === id)).filter(Boolean) || []);

// ✅ НОВОЕ COMPUTED СВОЙСТВО: Объединяем текущую заметку и ее переводы в один массив
const allLanguageVersions = computed(() => {
  if (!item.value) return [];
  const all = [item.value, ...translations.value];
  // Сортируем, чтобы всегда был одинаковый порядок, например, по коду языка
  return all.sort((a, b) => a.lang.localeCompare(b.lang));
});

const isNovenaDialogVisible = ref(false);
const novenaDays = ref(9);

// --- Логика для связанных заметок и ссылок в тексте ---
const linkedNotes = computed(() => item.value?.linkedNoteIds?.map(id => items.value.find(note => note.id === id)).filter(Boolean) || []);

function handleContentClick(event) {
  const link = event.target.closest('a');
  if (link && link.pathname.startsWith('/item/')) {
    event.preventDefault();
    router.push(link.pathname);
  }
}

// --- Логика Новенн ---
const isNovenaActiveAndInProgress = computed(() => novenaStore.isNovenaActive(props.id));

const currentNovenaDay = computed(() => {
  if (!isNovenaActiveAndInProgress.value) return null;
  const data = novenaStore.getNovenaData(props.id);
  if (!data) return null;
  const startDate = new Date(data.startDate);
  const today = new Date(novenaStore.getTodayDateString());
  const diffTime = Math.abs(today.getTime() - startDate.getTime());
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  const dayNumber = diffDays + 1;
  return dayNumber > 0 && dayNumber <= data.totalDays ? dayNumber : null;
});

// Логика "Ритуала"
const hasScrolledToStart = ref(false);
const hasScrolledToDay = ref(false);
const hasScrolledToFinish = ref(false);
const hasStartMarker = ref(false);
const hasFinishMarker = ref(false);

const isTodayCompleted = computed(() => {
  if (!currentNovenaDay.value) return false;
  const data = novenaStore.getNovenaData(props.id);
  const todayStr = novenaStore.getTodayDateString();
  return data?.completedDates.includes(todayStr) || false;
});

const showCompleteButton = computed(() => {
  return hasScrolledToStart.value && hasScrolledToDay.value && hasScrolledToFinish.value;
});

function executeScrollStep(step) {
  if (step === 'start') {
    scrollToMarker('start');
    hasScrolledToStart.value = true;
  } else if (step === 'day') {
    scrollToCurrentDay();
    hasScrolledToDay.value = true;
  } else if (step === 'finish') {
    scrollToMarker('finish');
    hasScrolledToFinish.value = true;
  }
}

function resetRitualState() {
  hasScrolledToStart.value = false;
  hasScrolledToDay.value = false;
  hasScrolledToFinish.value = false;
}

onBeforeRouteLeave(() => { resetRitualState(); });
onUnmounted(() => { resetRitualState(); });

// ✅ ИСПРАВЛЕННЫЙ БЛОК
watchEffect(() => {
  if (typeof window === 'undefined' || !item.value || !item.value.text) {
    hasStartMarker.value = false;
    hasFinishMarker.value = false;
    return;
  }

  const parser = new DOMParser();
  const doc = parser.parseFromString(item.value.text, 'text/html');

  hasStartMarker.value = !!doc.querySelector('[data-marker="start"]');
  hasFinishMarker.value = !!doc.querySelector('[data-marker="finish"]');
});

const processedHtml = computed(() => {
  const dayToHighlight = currentNovenaDay.value;
  const originalHtml = item.value?.text || '';
  if (!dayToHighlight || !originalHtml) return originalHtml;

  const parser = new DOMParser();
  const doc = parser.parseFromString(originalHtml, 'text/html');
  const element = doc.querySelector(`[data-day="${dayToHighlight}"]`);
  if (element) {
    element.classList.add('current-day-marker');
  }
  return doc.body.innerHTML;
});

const novenaProgress = computed(() => {
  const data = novenaStore.getNovenaData(props.id);
  if (!data || !data.totalDays) return { percentage: 0, color: 'grey', completed: 0, total: 0 };
  const todayStr = novenaStore.getTodayDateString();
  const isTodayCompleted = data.completedDates.includes(todayStr);
  return {
    percentage: (data.completedDates.length / data.totalDays) * 100,
    completed: data.completedDates.length,
    total: data.totalDays,
    color: isTodayCompleted ? 'success' : 'warning'
  };
});

function handleStartNovena() {
  novenaStore.startNovena(props.id, novenaDays.value);
  isNovenaDialogVisible.value = false;
}

function scrollToCurrentDay() {
  const el = document.querySelector('.current-day-marker');
  if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

function scrollToMarker(markerType) {
  const el = document.querySelector(`[data-marker="${markerType}"]`);
  if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

watchEffect(() => {
  if (settings.keepScreenOn) requestWakeLock();
  else releaseWakeLock();
});

</script>

<style scoped>
.note-view-container {
  padding-left: 8px;
  padding-right: 8px;
}

.fab-container {
  position: fixed;
  bottom: 24px;
  right: 24px;
  display: flex;
  flex-direction: column;
  z-index: 5;
}
</style>
```

### src/components/LoginView.vue
```
<template>
  <v-container class="fill-height justify-center">
    <v-card width="100%" max-width="400">
      <v-card-title class="text-center text-h5 py-4">{{ $t('loginTitle') }}</v-card-title>
      <v-card-text>
        <v-form @submit.prevent="handleLogin">
          <v-text-field
            v-model="email"
            :label="$t('email')"
            type="email"
            variant="outlined"
            class="mb-2"
            :rules="[v => !!v || $t('emailRequired')]"
            required
          ></v-text-field>
          <v-text-field
            v-model="password"
            :label="$t('password')"
            type="password"
            variant="outlined"
            :rules="[v => !!v || $t('passwordRequired')]"
            required
          ></v-text-field>
          <v-alert v-if="error" type="error" density="compact" class="mt-4" text>{{ error }}</v-alert>
          <v-btn type="submit" color="primary" block size="large" class="mt-6" :loading="isLoggingIn">{{ $t('login') }}</v-btn>
        </v-form>
      </v-card-text>
    </v-card>
  </v-container>
</template>

<script setup>
import { ref } from 'vue';
import { useAuthStore } from '@/stores/auth';
import { useI18n } from 'vue-i18n';

const { t } = useI18n();
const email = ref('');
const password = ref('');
const error = ref(null);
const isLoggingIn = ref(false);
const authStore = useAuthStore();

const handleLogin = async () => {
  isLoggingIn.value = true;
  error.value = null;
  try {
    await authStore.login(email.value, password.value);
  } catch (e) {
    error.value = t('loginError');
  } finally {
    isLoggingIn.value = false;
  }
};
</script>
```

### src/components/NotificationSnackbar.vue
```
<template>
  <v-snackbar
    v-model="visible"
    :color="color"
    :timeout="timeout"
    location="bottom right"
    variant="elevated"
  >
    {{ message }}
    <template v-slot:actions>
      <v-btn icon="mdi-close" @click="hide"></v-btn>
    </template>
  </v-snackbar>
</template>

<script setup>
import { ref } from 'vue';

const visible = ref(false);
const message = ref('');
const color = ref('success');
const timeout = ref(3000);

// Глобальная функция для показа уведомления
function show(newMessage, newColor = 'success') {
  message.value = newMessage;
  color.value = newColor;
  visible.value = true;
}

function hide() {
  visible.value = false;
}

// Делаем функцию show доступной извне через ref
defineExpose({ show });
</script>
```

### src/components/NovenaBuilder.vue
```
<template>
  <v-card variant="outlined" class="pa-3 mb-3">
    <div class="d-flex align-center ga-3 flex-wrap mb-2">
      <v-text-field
        v-model.number="novena.totalDays"
        type="number" min="1" max="99"
        density="compact"
        :label="$t('novenaDaysLabel')"
        style="max-width: 160px"
      />
      <v-chip-group v-model="selectedDay" class="ml-2" mandatory>
        <v-chip v-for="d in novena.totalDays" :key="`d-${lang}-${d}`" :value="d" size="small" filter>{{ d }}</v-chip>
      </v-chip-group>

      <v-spacer />

      <v-switch
        v-model="novena.useSingleText"
        class="ml-auto"
        inset
        :label="$t('singleTextMode')"
      />
    </div>

    <h4 class="text-subtitle-1 mb-2">{{ $t('opening') }}</h4>
    <Editor v-model="novena.openingTextVersions[lang]" class="mb-4" />

    <template v-if="novena.useSingleText">
      <h4 class="text-subtitle-1 mb-2">{{ $t('day') }} 1…{{ novena.totalDays }}</h4>
      <Editor v-model="novena.singleTextVersions[lang]" class="mb-4" />
    </template>
    <template v-else>
      <h4 class="text-subtitle-1 mb-2">{{ $t('day') }} {{ selectedDay }}</h4>
      <Editor v-model="dayModel" class="mb-4" />
    </template>

    <h4 class="text-subtitle-1 mb-2">{{ $t('closing') }}</h4>
    <Editor v-model="novena.closingTextVersions[lang]" />
  </v-card>
</template>

<script setup>
import { computed, ref, watch } from 'vue';
import Editor from '@/components/Editor.vue';

const props = defineProps({
  modelValue: { type: Object, required: true }, // novena
  lang: { type: String, required: true },
});

const emit = defineEmits(['update:modelValue']);

const novena = computed({
  get: () => props.modelValue,
  set: (v) => emit('update:modelValue', v),
});

const selectedDay = ref(1);

// Дневной текст для текущего дня/языка
const dayModel = computed({
  get() {
    const key = String(selectedDay.value);
    return novena.value.dailyTextVersions?.[key]?.[props.lang] || '';
  },
  set(v) {
    const key = String(selectedDay.value);
    if (!novena.value.dailyTextVersions[key]) novena.value.dailyTextVersions[key] = {};
    novena.value.dailyTextVersions[key][props.lang] = v;
  }
});

// Инициализация структур
watch(() => props.lang, () => {
  if (!novena.value.openingTextVersions) novena.value.openingTextVersions = {};
  if (!novena.value.closingTextVersions) novena.value.closingTextVersions = {};
  if (!novena.value.singleTextVersions) novena.value.singleTextVersions = {};
  if (!novena.value.dailyTextVersions) novena.value.dailyTextVersions = {};
}, { immediate: true });
</script>
```

### src/components/NovenaTracker.vue
```
<!-- src/components/NovenaTracker.vue -->
<template>
  <div class="pa-2">
    <div class="d-flex justify-space-between align-center mb-4">
      <h3 class="text-h6 font-weight-medium">{{ $t('prayerNovena') }}</h3>
      <v-chip color="primary" variant="flat" label>
        <v-icon start>mdi-flag-checkered</v-icon>
        {{ progressText }}
      </v-chip>
    </div>

    <p class="text-body-2 text-medium-emphasis mb-6">
      {{ $t('novenaTrackerHint') }}
    </p>

    <!-- Новый трекер в виде сетки -->
    <div class="grid-container">
      <div
        v-for="day in daySlots"
        :key="day.date"
        :class="['day-cell', day.status, { 'today': day.isToday }]"
        @click="onDayClick(day)"
      >
        <div class="day-number">{{ day.dayNumber }}</div>
        <div class="day-date">{{ formatDate(day.date) }}</div>
        <v-icon v-if="day.status === 'completed'" class="day-icon" size="small">mdi-check-circle</v-icon>
        <v-icon v-if="day.status === 'missed'" class="day-icon" size="small">mdi-alert-circle</v-icon>
      </div>
    </div>
    
    <v-divider class="my-4"></v-divider>
    
    <v-btn 
      @click="novenaStore.endNovena(noteId)"
      variant="text" 
      color="error" 
      block
    >
      {{ $t('endNovena') }}
    </v-btn>

</div>
</template>

<script setup>
import { computed } from 'vue';
import { useNovenaStore } from '@/stores/novena';
import { useI18n } from 'vue-i18n';

const props = defineProps({ noteId: { type: String, required: true } });
const { t, d } = useI18n(); // d - для форматирования дат
const novenaStore = useNovenaStore();
const today = new Date(novenaStore.getTodayDateString());

const novena = computed(() => novenaStore.getNovenaData(props.noteId));

// Главная логика вычисления статуса каждого дня
const daySlots = computed(() => {
  if (!novena.value) return [];
  const slots = [];
  const startDate = new Date(novena.value.startDate);

  for (let i = 0; i < novena.value.totalDays; i++) {
    const currentDate = new Date(startDate);
    currentDate.setDate(startDate.getDate() + i);
    const dateString = currentDate.toISOString().split('T')[0];
    
    let status = 'pending';
    const isCompleted = novena.value.completedDates.includes(dateString);

    if (isCompleted) {
      status = 'completed';
    } else if (currentDate < today) {
      status = 'missed';
    } else if (currentDate > today) {
      status = 'future';
    } else {
      status = 'today';
    }

    slots.push({
      dayNumber: i + 1,
      date: dateString,
      status: status, // 'completed', 'missed', 'today', 'future'
      isToday: dateString === novenaStore.getTodayDateString(),
    });
  }
  return slots;
});

const onDayClick = (day) => {
  // Позволяем кликать только по прошедшим и сегодняшним дням
  if (day.status === 'future') return;
  novenaStore.toggleDayCompletion(props.noteId, day.date);
};

const completedCount = computed(() => novena.value?.completedDates.length || 0);
const progressText = computed(() => `${completedCount.value} / ${novena.value?.totalDays || 0}`);

const formatDate = (dateString) => {
  // Форматируем дату, например "14 авг"
  const date = new Date(dateString);
  return d(date, 'short'); // Используем i18n для форматирования
};
</script>

<style scoped>
.grid-container {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
  gap: 8px;
}
.day-cell {
  border: 1px solid rgba(0,0,0,0.12);
  border-radius: 8px;
  padding: 8px;
  text-align: center;
  position: relative;
  transition: all 0.2s ease-in-out;
  cursor: pointer;
}
.day-cell.future {
  opacity: 0.5;
  cursor: not-allowed;
  background-color: rgba(0,0,0,0.02);
}
.day-cell.today {
  border-width: 2px;
  border-color: rgba(var(--v-theme-primary));
}
.day-cell.completed {
  background-color: rgba(var(--v-theme-primary), 0.1);
  border-color: transparent;
  color: rgb(var(--v-theme-primary));
}
.day-cell.missed {
  border-color: rgba(var(--v-theme-error), 0.5);
}
.day-cell:not(.future):hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}
.day-number {
  font-size: 0.8rem;
  font-weight: 500;
  opacity: 0.7;
}
.day-date {
  font-size: 1rem;
  font-weight: bold;
}
.day-icon {
  position: absolute;
  top: 4px;
  right: 4px;
  opacity: 0.8;
}
</style>
```

### src/components/PrayerRuleView.vue
```
<template>
  <v-container>
     <h2 class="text-h5 font-weight-medium mb-6">{{ $t('myPrayerRule') }}</h2>
    <!-- РЕЖИМ РЕДАКТИРОВАНИЯ -->
    <div v-if="isEditing">
      <div v-if="prayerRule.ruleItems.length === 0" class="text-center mt-16">
        <p class="text-h6">{{ $t('ruleIsEmpty') }}</p>
        <p class="text-medium-emphasis">{{ $t('ruleIsEmptyHint') }}</p>
      </div>
      <div v-else>
        <!-- ✅✅✅ Рендерим карточки с кнопками управления порядком ✅✅✅ -->
        <div v-for="(item, index) in ruleItemsWithDetails" :key="item.id" class="prayer-item-container">
            <v-card variant="outlined" class="pa-4">
              <div class="d-flex align-center mb-4">
                <h3 class="text-h5">{{ getTitle(item) }}</h3>
                <v-spacer></v-spacer>
                <!-- Кнопки перемещения -->
                <v-btn icon="mdi-arrow-up" variant="text" size="small" :disabled="index === 0" @click="prayerRule.moveItem(index, index - 1)"></v-btn>
                <v-btn icon="mdi-arrow-down" variant="text" size="small" :disabled="index === ruleItemsWithDetails.length - 1" @click="prayerRule.moveItem(index, index + 1)"></v-btn>
                <!-- Кнопка удаления -->
                <v-btn icon="mdi-delete-outline" variant="text" size="small" @click="prayerRule.removeItem(index)"></v-btn>
              </div>
              <div v-html="getItemContent(item)" class="note-content-area ProseMirror"></div>
            </v-card>
            <v-divider class="my-4"></v-divider>
        </div>
      </div>
      <v-btn icon="mdi-plus" location="bottom right" size="large" color="primary" position="fixed" variant="elevated" elevation="8" class="ma-4" @click="isAddDialogOpen = true"></v-btn>
    </div>
    <!-- РЕЖИМ ПРОСМОТРА -->
    <div v-else>
      <div v-if="prayerRule.ruleItems.length > 0">
        <div v-for="item in ruleItemsWithDetails" :key="`view-${item.id}`">
          <h3 class="text-h5 mb-3">{{ getTitle(item) }}</h3>
          <div v-html="getItemContent(item)" class="note-content-area ProseMirror"></div>
          <v-divider class="my-8"></v-divider>
        </div>
      </div>
      <div v-else class="text-center mt-16">
        <v-icon size="64" class="mb-4 text-medium-emphasis">mdi-book-remove-outline</v-icon>
        <p class="text-h6">{{ $t('noRuleCreated') }}</p>
        <p class="text-medium-emphasis mb-4">{{ $t('noRuleCreatedHint') }}</p>
        <v-btn size="large" color="primary" @click="setEditing(true)">
          <v-icon start>mdi-pencil</v-icon>
          {{ $t('createRule') }}
        </v-btn>
      </div>
    </div>
    <!-- ✅ ИЗМЕНЕНИЕ: НОВЫЙ ДИАЛОГ ВМЕСТО АВТОКОМПЛИТА -->
    <v-dialog
      v-model="isAddDialogOpen"
      max-width="600px"
      :fullscreen="$vuetify.display.mobile"
      scrollable
    >
      <v-card>
        <v-card-title>{{ $t('addPrayerToRule') }}</v-card-title>
        <v-card-text class="pa-4">
          <v-text-field
            v-model="searchQuery"
            :placeholder="$t('findPrayer')"
            variant="outlined"
            density="compact"
            autofocus
            hide-details
            class="mb-4"
          ></v-text-field>

          <v-list v-if="filteredAvailableItems.length > 0">
            <v-list-item
              v-for="item in filteredAvailableItems"
              :key="item.id"
              :title="getTitle(item)"
              @click="handleAddItem(item)"
            >
              <template v-slot:prepend>
                <v-icon>mdi-note-text-outline</v-icon>
              </template>
            </v-list-item>
          </v-list>
          <div v-else class="text-center text-grey py-4">{{ $t('noNotesFound') }}</div>
        </v-card-text>
        <v-card-actions>
            <v-spacer></v-spacer>
            <v-btn text @click="isAddDialogOpen = false">{{ $t('cancel') }}</v-btn>
        </v-card-actions>
      </v-card>
    </v-dialog>

  </v-container>
</template>

<script setup>
import { ref, computed, onUnmounted , onMounted } from 'vue';
import { usePageMode } from '@/composables/usePageMode';
import { usePrayerRuleStore } from '@/stores/prayerRule';
import { useItems } from '@/composables/useItems';
import { useI18n } from 'vue-i18n';
const { isEditing, setEditing } = usePageMode();
const prayerRule = usePrayerRuleStore();
const { items, getTitle } = useItems();
const { t } = useI18n();

const isAddDialogOpen = ref(false);
const searchQuery = ref('');

onUnmounted(() => {
  setEditing(false);
});

// ✅ Возвращаемся к более простой логике: получаем полные объекты на основе ID из стора
const ruleItemsWithDetails = computed(() => {
    return prayerRule.ruleItems.map(itemId => items.value.find(i => i.id === itemId)).filter(Boolean);
});

// ✅ Измененная логика
const availableItems = computed(() => {
    const ruleItemIds = new Set(prayerRule.ruleItems); // Теперь это просто массив ID
    return items.value.filter(item => !ruleItemIds.has(item.id));
});

// ✅ Фильтруем доступные элементы на основе поиска
const filteredAvailableItems = computed(() => {
  if (!searchQuery.value) {
    return availableItems.value;
  }
  return availableItems.value.filter(item =>
    getTitle(item).toLowerCase().includes(searchQuery.value.toLowerCase())
  );
});

const getItemTitle = (itemId) => {
    const item = items.value.find(i => i.id === itemId);
    return item ? getTitle(item) : `[${t('noteNotFound')}]`;
};

// ✅ Измененная логика
// const getItemContent = (itemId) => {
//     const fullItem = items.value.find(i => i.id === itemId);
//     if (!fullItem) return `[${t('noteNotFound')}]`;
//     return fullItem.text || `[${t('noTextInLang')}]`; // Просто берем поле text
// };
const getItemContent = (item) => {
    if (!item) return `[${t('noteNotFound')}]`;
    return item.text || `[${t('noTextInLang')}]`;
};

// ✅ Обновленная функция добавления
function handleAddItem(item) {
    if (!item) return;
    prayerRule.addItem(item);
    searchQuery.value = ''; // Сбрасываем поиск
    isAddDialogOpen.value = false; // Закрываем диалог
}

</script>

<style scoped>
.control-panel {
  border: 1px solid rgba(var(--v-border-color), var(--v-border-opacity));
  border-radius: 8px;
  background-color: rgba(var(--v-theme-surface-variant), 0.2);
}
.prayer-item-container:last-of-type .v-divider, 
div[v-else] > div > div:last-of-type .v-divider {
  display: none;
}
</style>
```

### src/components/ReloadPrompt.vue
```
<!-- src/components/ReloadPrompt.vue -->
<template>
  <v-snackbar
    :model-value="needRefresh"
    color="primary"
    variant="elevated"
    :timeout="-1"
    location="bottom right"
    class="mb-4"
  >
    <div class="text-subtitle-1">
      Доступна новая версия приложения!
    </div>

    <template v-slot:actions>
      <v-btn
        variant="text"
        @click="updateServiceWorker()"
      >
        Обновить
      </v-btn>
       <v-btn
        icon="mdi-close"
        variant="text"
        @click="close"
      >
      </v-btn>
    </template>
  </v-snackbar>
</template>

<script setup>
import { useRegisterSW } from 'virtual:pwa-register/vue';

// useRegisterSW - это специальная функция из плагина VitePWA
// needRefresh - станет true, когда новый SW будет готов
// updateServiceWorker - функция, которая активирует новый SW и перезагрузит страницу
const {
  needRefresh,
  updateServiceWorker,
} = useRegisterSW();

const close = () => {
  needRefresh.value = false;
};
</script>
```

### src/components/SettingsView.vue
```
<template>
  <v-container>
    
    <v-list lines="two" subheader>
      <!-- ✅ ВРЕМЕННЫЙ БЛОК ДЛЯ ТЕСТИРОВАНИЯ НОВЕНН
    <v-list-subheader>Инструменты разработчика</v-list-subheader>
    <v-card variant="outlined" class="pa-4 mt-2">
       <h3 class="text-subtitle-1 mb-3">Тестирование предложений новенн</h3>
       <v-text-field
            v-model="simulatedDate"
            label="Симулировать дату"
            type="date"
            variant="outlined"
            density="compact"
            class="mb-2"
        ></v-text-field>
        <v-btn @click="runTestCheck" block>Запустить проверку для даты</v-btn>
    </v-card>
    <v-divider class="my-4"></v-divider> -->
    
      <v-list-subheader>{{ $t('generalSettings') }}</v-list-subheader>
      <v-list-item :title="$t('keepScreenOn')" :subtitle="$t('keepScreenOnHint')">
        <template v-slot:prepend><v-icon>mdi-lightbulb-on-outline</v-icon></template>
        <template v-slot:append>
          <v-switch 
            :model-value="settings.keepScreenOn" 
            @update:model-value="settings.setKeepScreenOn" 
            inset color="primary" hide-details>
          </v-switch>
        </template>
      </v-list-item>

      <v-list-subheader>{{ $t('appearance') }}</v-list-subheader>
      
      <v-list-item :title="$t('fontFamily')" :subtitle="$t('fontFamilyHint')">
        <template v-slot:prepend><v-icon>mdi-format-font</v-icon></template>
      </v-list-item>
      <v-chip-group 
        class="px-4 pb-2"
        :model-value="settings.fontFamily" 
        @update:model-value="settings.setFontFamily"
        mandatory
      >
        <v-chip v-for="font in fontOptions" :key="font.value" :value="font.value" filter variant="outlined" :style="{ fontFamily: font.value }">
          {{ font.title }}
        </v-chip>
      </v-chip-group>

    <v-list-item :title="$t('fontSize')" :subtitle="$t('fontSizeHint')">
        <template v-slot:prepend><v-icon>mdi-format-font-size-increase</v-icon></template>
        <template v-slot:append>
          <div class="d-flex align-center">
            <v-btn icon="mdi-minus" variant="text" size="small" @click="settings.decreaseFontSize" :disabled="settings.fontSizeMultiplier <= 0.8"></v-btn>
            <span class="mx-2 font-weight-bold" style="width: 40px; text-align: center;">{{ Math.round(settings.fontSizeMultiplier * 100) }}%</span>
            <v-btn icon="mdi-plus" variant="text" size="small" @click="settings.increaseFontSize" :disabled="settings.fontSizeMultiplier >= 1.5"></v-btn>
          </div>
        </template>
      </v-list-item>
      
      <!-- ✅ --- БЛОК ПРЕДПРОСМОТРА РАЗМЕРА ШРИФТА --- ✅ -->
      <div class="px-4 pb-2">
        <v-card variant="outlined" class="pa-4">
          <div class="note-content-area">
            <p>{{ $t('previewText') }}</p>
          </div>
        </v-card>
      </div>

      <v-list-item :title="$t('darkTheme')" :subtitle="$t('themeIs', { themeName: $t('themeNames.' + settings.currentTheme) })">
        <template v-slot:prepend><v-icon>mdi-theme-light-dark</v-icon></template>
        <template v-slot:append><v-switch :model-value="settings.currentTheme === 'dark'" @update:model-value="settings.toggleTheme" inset color="primary" hide-details></v-switch></template>
      </v-list-item>
      
      <v-list-item :title="$t('viewMode')" :subtitle="$t('viewModeHint')">
        <template v-slot:prepend><v-icon>mdi-view-dashboard-outline</v-icon></template>
        <template v-slot:append>
          <v-btn-toggle :model-value="settings.viewMode" @update:model-value="settings.toggleViewMode" mandatory variant="outlined" density="compact">
            <v-btn value="card"><v-icon>mdi-view-grid</v-icon></v-btn>
            <v-btn value="compact"><v-icon>mdi-view-list</v-icon></v-btn>
          </v-btn-toggle>
        </template>
      </v-list-item>
    </v-list>
    
    <!-- Остальная часть файла с языком и категориями остается без изменений -->
    <v-divider class="my-4"></v-divider>
    <v-list-subheader>{{ $t('language') }}</v-list-subheader>
    <v-item-group mandatory :model-value="settings.currentLanguage" @update:model-value="settings.setLanguage" class="pa-2">
      <v-item v-for="lang in langOptions" :key="lang.value" :value="lang.value" v-slot="{ isSelected, toggle }">
        <v-btn :variant="isSelected ? 'tonal' : 'outlined'" @click="toggle" class="mr-2 mb-2">{{ lang.title }}</v-btn>
      </v-item>
    </v-item-group>

    <v-divider class="my-4"></v-divider>

     <!-- ✅ НОВЫЙ ПЕРЕКЛЮЧАТЕЛЬ ДЛЯ УВЕДОМЛЕНИЙ -->
      <v-list-item :title="$t('enableNovenaSuggestions')" :subtitle="$t('enableNovenaSuggestionsHint')">
        <template v-slot:prepend>
          <v-icon>mdi-bell-ring-outline</v-icon>
        </template>
        <template v-slot:append>
          <v-switch
            v-model="settings.novenaNotificationsEnabled"
            color="primary"
            inset
            hide-details
          ></v-switch>
        </template>
      </v-list-item>
    <v-divider class="my-4"></v-divider>
      <!-- ✅ --- ВОЗВРАЩАЕМ ЛОГИКУ ДОБАВЛЕНИЯ КАТЕГОРИЙ --- ✅ -->
    <v-list-subheader>{{ $t('menuCategories') }}</v-list-subheader>
    <v-list-item v-for="(cat, index) in settings.menuCategories" :key="index">
      <v-list-item-title>{{ cat.name }}</v-list-item-title>
      <v-list-item-subtitle>Фильтр по тегам: `{{ cat.tags?.join(', ') }}`</v-list-item-subtitle>
      <template v-slot:append>
        <v-btn icon="mdi-delete-outline" variant="text" color="grey" @click="settings.removeCategory(index)"></v-btn>
      </template>
    </v-list-item>
    <div class="pa-2">
       <v-btn color="primary" block @click="isAddCategoryDialogOpen = true">{{ $t('addCategory') }}</v-btn>
    </div>

    <AddCategoryDialog v-model="isAddCategoryDialogOpen" />
  </v-container>
</template>

<script setup>
import { ref } from 'vue';
import { useSettingsStore } from '@/stores/settings';
import { useItems } from '@/composables/useItems';
import AddCategoryDialog from '@/components/AddCategoryDialog.vue';
const settings = useSettingsStore();
const { allTags } = useItems();
const isAddCategoryDialogOpen = ref(false);

const fontOptions = ref([
  { title: 'Системный', value: settings.systemFont },
  { title: 'Yeseva One', value: 'Yeseva One' },
  { title: 'Comfortaa', value: 'Comfortaa' },
  { title: 'Old Standard TT', value: 'Old Standard TT' },
  { title: 'Kurale', value: 'Kurale' },
  { title: 'Pacifico', value: 'Pacifico' },
]);

const langOptions = ref([
  { title: 'Беларуская', value: 'be' },
  { title: 'Русский', value: 'ru' },
]);

import { useNovenaSuggestions } from '@/composables/useNovenaSuggestions'; // ✅ Импортируем
// ... (остальные ref'ы и функции)
const { checkSuggestions } = useNovenaSuggestions(); // ✅ Получаем функцию
const simulatedDate = ref(new Date().toISOString().split('T')[0]); // ✅ Сегодня по умолчанию
function runTestCheck() {
    if (simulatedDate.value) {
        console.log(`--- Запуск теста для даты: ${simulatedDate.value} ---`);
        checkSuggestions(simulatedDate.value);
    }
}
</script>
```

### src/components/TextSettingsSheet.vue
```
<template>
  <v-bottom-sheet v-model="isTextSettingsSheetOpen">
    <v-card class="pa-4" rounded="t-xl">
      <v-list lines="two" subheader>
       

        <!-- Настройка размера -->
<v-list-subheader>{{ $t('fontSize') }}</v-list-subheader>
<v-list-item>
  <div class="d-flex align-center justify-space-between">
    <!-- Кнопка уменьшения -->
    <v-btn 
      variant="tonal" 
      @click="settings.decreaseFontSize" 
      :disabled="settings.fontSizeMultiplier <= 0.8"
      class="font-size-button"
    >
      <span class="text-h6 font-weight-bold">A</span>
      <v-icon right>mdi-minus</v-icon>
    </v-btn>

    <!-- Текущее значение в процентах -->
    <span class="mx-4 font-weight-bold text-h6 text-center" style="min-width: 80px;">
      {{ Math.round(settings.fontSizeMultiplier * 100) }}%
    </span>

    <!-- Кнопка увеличения -->
    <v-btn 
      variant="tonal" 
      @click="settings.increaseFontSize" 
      :disabled="settings.fontSizeMultiplier >= 1.5"
      class="font-size-button"
    >
      <span class="text-h5 font-weight-bold">A</span>
      <v-icon right>mdi-plus</v-icon>
    </v-btn>
  </div>
</v-list-item>
 <!-- Настройка шрифта -->
        <v-list-subheader>{{ $t('fontFamily') }}</v-list-subheader>
        <v-list-item class="px-1">
          <v-chip-group 
            :model-value="settings.fontFamily" 
            @update:model-value="settings.setFontFamily"
            mandatory
          >
            <v-chip v-for="font in fontOptions" :key="font.value" :value="font.value" filter variant="outlined" :style="{ fontFamily: font.value }">
              {{ font.title }}
            </v-chip>
          </v-chip-group>
        </v-list-item>
        <v-list-item :title="$t('keepScreenOn')" :subtitle="$t('keepScreenOnHint')">
          <template v-slot:prepend><v-icon>mdi-lightbulb-on-outline</v-icon></template>
          <template v-slot:append>
            <v-switch 
              :model-value="settings.keepScreenOn" 
              @update:model-value="settings.setKeepScreenOn" 
              inset color="primary" hide-details>
            </v-switch>
          </template>
        </v-list-item>
      </v-list>
      <!-- <v-card-actions>
        <v-spacer></v-spacer>
        <v-btn color="primary" variant="text" @click="isTextSettingsSheetOpen = false">{{ $t('done') }}</v-btn>
      </v-card-actions> -->
    </v-card>
  </v-bottom-sheet>
</template>

<script setup>
import { ref, watch } from 'vue';
import { useSettingsStore } from '@/stores/settings';
import { useAppBar } from '@/composables/useAppBar';

const settings = useSettingsStore();
const { isTextSettingsSheetOpen } = useAppBar();

// // ✅ ЛОГ 4: Отслеживаем, получает ли этот компонент обновление состояния
// watch(isTextSettingsSheetOpen, (newValue, oldValue) => {
//   console.log(`%c[TextSettingsSheet.vue WATCHER] 'isTextSettingsSheetOpen' changed from ${oldValue} to ${newValue}`, 'color: green; font-weight: bold;');
// });

const fontOptions = ref([
  { title: 'Системный', value: "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif" },
  { title: 'Kurale', value: 'Kurale' },
  { title: 'Yeseva One', value: 'Yeseva One' },
  { title: 'Old Standard TT', value: 'Old Standard TT' },
  { title: 'Pacifico', value: 'Pacifico' },
  { title: 'Comfortaa', value: 'Comfortaa' },
]);
</script>
```

### src/composables/useAppBar.js
```
import { ref } from 'vue';

// Глобальные реактивные переменные
const showBackButton = ref(false);
const isDrawerOpen = ref(false);
const isSearchActive = ref(false);
const isFilterSheetOpen = ref(false);
const isTextSettingsSheetOpen = ref(false); // ✅ ДОБАВЛЯЕМ НОВОЕ СОСТОЯНИЕ


console.log('[useAppBar.js] Module loaded. Creating reactive variables.');

export function useAppBar() {
  // Эта функция будет просто переключать видимость кнопки "Назад"
  const setBackButtonVisibility = (visible) => {
    showBackButton.value = visible;
  };

  return { 
    showBackButton,
    setBackButtonVisibility,
    isDrawerOpen, 
    isSearchActive, 
    isFilterSheetOpen, 
    isTextSettingsSheetOpen 
  };
}
```

### src/composables/useDataManagement.js
```
// src/composables/useDataManagement.js
import { ref } from 'vue';
import { collection, doc, writeBatch, getDocs } from 'firebase/firestore';
import { db } from '@/firebase';
import { useItems } from '@/composables/useItems';
import { useNotifier } from '@/composables/useNotifier';
import { useI18n } from 'vue-i18n';

export function useDataManagement() {
  const { items } = useItems(); // Нам нужны items только для экспорта
  const { showSuccess, showError } = useNotifier();
  const { t } = useI18n();

  const isImporting = ref(false);
  const isImportDialogVisible = ref(false);
  const importFile = ref(null);
  const previewItems = ref([]);
  const importMode = ref('add'); // 'add' или 'overwrite'

  const exportToJson = () => {
    try {
      // Удаляем реактивность и лишние поля перед экспортом
      const dataToExport = JSON.parse(JSON.stringify(items.value));
      const dataStr = JSON.stringify(dataToExport, null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `prayers_backup_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      showSuccess(t('exportSuccess'));
    } catch (e) {
      console.error("JSON Export Error:", e);
      showError(t('exportError'));
    }
  };
  
  // Мы удаляем экспорт в CSV, так как он не подходит для новой структуры
  const exportToCsv = () => {
    showError('Экспорт в CSV больше не поддерживается.');
  };

  const importFromFile = (file) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = JSON.parse(e.target.result);
        if (!Array.isArray(data)) throw new Error("JSON must be an array.");

        previewItems.value = data;
        importFile.value = file;
        isImportDialogVisible.value = true;
      } catch (e) {
        console.error("Import Error:", e);
        showError(t('importParseError'));
      }
    };
    reader.readAsText(file);
  };
  
  const confirmImport = async () => {
    isImporting.value = true;
    const batch = writeBatch(db);
    const itemsCollectionRef = collection(db, 'items');
    
    let addedCount = 0;
    let updatedCount = 0;

    try {
      // Если режим "перезаписать", нам нужно получить текущие ID из базы
      let existingIds = new Set();
      if (importMode.value === 'overwrite') {
        const querySnapshot = await getDocs(itemsCollectionRef);
        querySnapshot.forEach(doc => existingIds.add(doc.id));
      }

      for (const item of previewItems.value) {
        // У каждой записи должен быть ID. Если его нет, пропускаем.
        if (!item.id) continue;
        
        const docRef = doc(db, 'items', item.id);

        if (existingIds.has(item.id)) {
          // Если ID существует и режим 'overwrite'
          if (importMode.value === 'overwrite') {
            batch.set(docRef, item); // set полностью перезаписывает документ
            updatedCount++;
          }
        } else {
          // Если ID не существует, всегда добавляем
          batch.set(docRef, item);
          addedCount++;
        }
      }

      await batch.commit();
      showSuccess(t('importSuccess', { added: addedCount, updated: updatedCount }));

    } catch (e) {
      console.error("Error during Firestore batch operation:", e);
      showError(t('importDbError'));
    } finally {
      cancelImport();
      isImporting.value = false;
    }
  };

  const cancelImport = () => {
    isImportDialogVisible.value = false;
    importFile.value = null;
    previewItems.value = [];
    importMode.value = 'add';
  };

  return { 
    exportToJson, 
    exportToCsv,
    importFromFile,
    isImporting,
    isImportDialogVisible,
    importFile,
    previewItems,
    importMode,
    confirmImport,
    cancelImport
  };
}
```

### src/composables/useFilters.js
```
import { ref } from 'vue';

// Создаем реактивные переменные для наших фильтров
const search = ref('');
const selectedTags = ref([]);

const selectedLangs = ref([]); // ✅ ДОБАВЬТЕ ЭТУ СТРОКУ

// Экспортируем функцию, которая будет предоставлять доступ
// к этим переменным в любом компоненте
export function useFilters() {
  return {
    search,
    selectedTags,
    selectedLangs, // ✅ И ЭТУ
  };
}
```

### src/composables/useItems.js
```
import { ref, computed } from 'vue';
import { db } from '@/firebase';
import { 
  collection, 
  onSnapshot, 
  addDoc, 
  deleteDoc, 
  updateDoc, 
  doc,
  serverTimestamp,
  query,
  orderBy
} from 'firebase/firestore';
import { useSettingsStore } from '@/stores/settings';
import { getTitleByLang } from '@/utils/i18n'; // ✅ 1. ИМПОРТИРУЕМ

const items = ref([]);
const allTags = ref([]);
const isLoading = ref(true); // ✅ Добавляем состояние загрузки

const itemsCollection = collection(db, 'items');
const itemsQuery = query(itemsCollection, orderBy('createdAt', 'desc'));

onSnapshot(itemsQuery, (snapshot) => {
  items.value = snapshot.docs.map(doc => ({
    id: doc.id,
    ...doc.data()
  }));
  allTags.value = [...new Set(items.value.flatMap(item => item.tags || []))].sort();
  isLoading.value = false; // ✅ Выключаем загрузку, когда данные получены
}, (error) => {
  console.error("Ошибка получения данных из Firestore: ", error);
  isLoading.value = false;
});

export function useItems() {
  const settings = useSettingsStore();

  // ✅ Создаем вычисляемое свойство для сортировки по закрепленным заметкам
  const sortedItems = computed(() => {
    if (!items.value) return [];
    return [...items.value].sort((a, b) => (settings.isPinned(b.id) - settings.isPinned(a.id)));
  });

  // ✅ ПРЕВРАЩАЕМ allTags В COMPUTED СВОЙСТВО
  const allTags = computed(() => {
    // Сначала фильтруем заметки
    const visibleItems = items.value.filter(item => 
      settings.showHiddenItems ? true : !item.hidden
    );
    // Затем собираем теги только из видимых заметок
    const tags = visibleItems.flatMap(item => item.tags || []);
    return [...new Set(tags)].sort();
  });

  const addItem = async (data) => {
    const docRef = await addDoc(itemsCollection, {
      ...data,
      createdAt: serverTimestamp()
    });
    return docRef;
  };

  const deleteItem = async (id) => {
    await deleteDoc(doc(db, 'items', id));
  };

  const updateItem = async (id, data) => {
    const dataToUpdate = { ...data };
    delete dataToUpdate.id; 
    await updateDoc(doc(db, 'items', id), dataToUpdate);
  };

   const linkTranslations = async (docId1, docId2, remove = false) => {
    const doc1Ref = doc(db, 'items', docId1);
    const doc2Ref = doc(db, 'items', docId2);
    const doc1 = items.value.find(i => i.id === docId1);
    const doc2 = items.value.find(i => i.id === docId2);
    if (!doc1 || !doc2) return;
    // Обновляем первый документ
    let newTrans1 = doc1.translationIds ? [...doc1.translationIds] : [];
    if (remove) {
      newTrans1 = newTrans1.filter(id => id !== docId2);
    } else if (!newTrans1.includes(docId2)) {
      newTrans1.push(docId2);
    }
    await updateDoc(doc1Ref, { translationIds: newTrans1 });
    // Обновляем второй документ
    let newTrans2 = doc2.translationIds ? [...doc2.translationIds] : [];
    if (remove) {
      newTrans2 = newTrans2.filter(id => id !== docId1);
    } else if (!newTrans2.includes(docId1)) {
      newTrans2.push(docId1);
    }
    await updateDoc(doc2Ref, { translationIds: newTrans2 });
  };

   const allLangs = computed(() => {
    if (!items.value) return [];
    // Собираем все уникальные языки из заметок
    const langs = items.value.map(item => item.lang);
    // Возвращаем отсортированный массив уникальных значений
    return [...new Set(langs)].sort();
  });


  const getTitle = (item) => {
    return item?.title || '';
  };


  return {
    items: sortedItems, // ✅ Экспортируем уже отсортированный массив
    allTags,
    isLoading, // ✅ Экспортируем состояние загрузки
    addItem,
    deleteItem,
    updateItem,
    getTitle, // ✅ 3. ЭКСПОРТИРУЕМ
  linkTranslations,
  allLangs
  };
}
```

### src/composables/useNotifier.js
```
import { ref } from 'vue';

// Эта переменная будет хранить ссылку на наш компонент уведомлений
export const notifier = ref(null);

export function useNotifier() {
  const showSuccess = (message) => {
    if (notifier.value) {
      notifier.value.show(message, 'success');
    }
  };

  const showError = (message) => {
    if (notifier.value) {
      notifier.value.show(message, 'error');
    }
  };

  return { showSuccess, showError };
}   
```

### src/composables/useNovenaSuggestions.js
```
// src/composables/useNovenaSuggestions.js
import { ref } from 'vue';
import { useItems } from '@/composables/useItems';
import { useNovenaStore } from '@/stores/novena';
import { useRouter } from 'vue-router';


const suggestion = ref(null); // { item, days }

export function useNovenaSuggestions() {
  const { items } = useItems();
  const novenaStore = useNovenaStore();
  const router = useRouter();

   // Загружаем отклоненные предложения из localStorage
  const dismissedSuggestions = ref(JSON.parse(localStorage.getItem('dismissedSuggestions') || '{}'));

  /**
   * Проверяет предложения по новеннам.
   * @param {Date} [simulatedDate=new Date()] - Опциональная дата для симуляции "сегодняшнего дня" при тестировании.
   */
  const checkSuggestions = (simulatedDate) => {
    const today = simulatedDate ? new Date(simulatedDate) : new Date();
    today.setHours(0, 0, 0, 0); // Обнуляем время для точного сравнения дат

    for (const item of items.value) {
      if (item.isNovenaPrayer && item.recommendedDate && !novenaStore.isNovenaActive(item.id)) {
        
        const recommended = new Date(item.recommendedDate);
        const recommendedMonth = recommended.getMonth();
        const recommendedDay = recommended.getDate();

        // Проверяем для текущего и следующего года, чтобы обработать переходы через год
        for (const year of [today.getFullYear(), today.getFullYear() + 1]) {
            const targetDate = new Date(year, recommendedMonth, recommendedDay);

            // Проверяем новенны на 9 дня
            for (const days of [9]) {
                const startDate = new Date(targetDate);
                startDate.setDate(targetDate.getDate() - (days - 1));

                if (startDate.getTime() === today.getTime()) {
                    const suggestionId = `${item.id}-${days}-${year}`;
                    
            // ✅ Проверяем, не было ли это предложение уже отклонено
            if (!dismissedSuggestions.value[suggestionId]) {
                suggestion.value = { item, days, id: suggestionId };
                return;
            }
                }
            }
        }
      }
    }
    console.log('Подходящих предложений по новеннам не найдено.');
  };

    // ✅ НОВАЯ ЛОГИКА для кнопки "Посмотреть"
  const viewSuggestedNovena = () => {
    if (!suggestion.value) return;
    const { item } = suggestion.value;
    // Переходим на страницу молитвы
    router.push({ name: 'ItemView', params: { id: item.id } });
    // Запоминаем, что это предложение было принято (или просмотрено)
    dismissSuggestion(true); 
  };
  
  // ✅ НОВАЯ ЛОГИКА для кнопки "Закрыть"
  const dismissSuggestion = (permanently = false) => {
    if (permanently && suggestion.value) {
        // Добавляем ID предложения в список отклоненных с меткой времени
        dismissedSuggestions.value[suggestion.value.id] = Date.now();
        localStorage.setItem('dismissedSuggestions', JSON.stringify(dismissedSuggestions.value));
    }
    suggestion.value = null;
  };

  return {
    suggestion,
    checkSuggestions,
    dismissSuggestion,
    viewSuggestedNovena, // ✅ Экспортируем новую функцию
  };
}
```

### src/composables/usePageMode.js
```
// src/composables/usePageMode.js
import { ref } from 'vue';

// Объявляем состояние ВНЕ функции, чтобы оно было синглтоном (единым для всех)
const isEditing = ref(false);

// ✅ ИСПРАВЛЕНИЕ ЗДЕСЬ: Добавлено слово 'export'
export function usePageMode() {
  const toggleEditing = () => {
    isEditing.value = !isEditing.value;
  };

  const setEditing = (value) => {
    isEditing.value = value;
  };

  return {
    isEditing,
    toggleEditing,
    setEditing,
  };
}
```

### src/composables/useWakeLock.js
```
// src/composables/useWakeLock.js
import { onUnmounted } from 'vue';

let wakeLock = null;

// Асинхронная функция для запроса блокировки
const requestWakeLock = async () => {
  // Проверяем, поддерживается ли API
  if ('wakeLock' in navigator) {
    try {
      wakeLock = await navigator.wakeLock.request('screen');
      console.log('Screen Wake Lock is active.');
      // Полезно слушать событие, когда система сама отпускает блокировку (например, при сворачивании)
      wakeLock.addEventListener('release', () => {
        console.log('Screen Wake Lock was released by the system.');
        wakeLock = null;
      });
    } catch (err) {
      console.error(`Wake Lock request failed: ${err.name}, ${err.message}`);
    }
  } else {
    console.warn('Wake Lock API is not supported by this browser.');
  }
};

// Асинхронная функция для снятия блокировки
const releaseWakeLock = async () => {
  if (wakeLock !== null) {
    try {
      await wakeLock.release();
      wakeLock = null;
      console.log('Screen Wake Lock released.');
    } catch (err) {
      console.error(`Wake Lock release failed: ${err.name}, ${err.message}`);
    }
  }
};

// Экспортируем основную функцию composable
export function useWakeLock() {
  // При уничтожении компонента, который использует эту логику, мы гарантированно снимаем блокировку
  onUnmounted(() => {
    releaseWakeLock();
  });

  return {
    requestWakeLock,
    releaseWakeLock,
  };
}
```

### src/firebase.js
```
import { initializeApp } from "firebase/app";
// ✅ Возвращаем правильную инициализацию Firestore с поддержкой оффлайн-кэширования
import { initializeFirestore, persistentLocalCache } from "firebase/firestore";

const firebaseConfig = {
  apiKey: "AIzaSyDF2TD4MTcKiBChKRssauvL-nNyT4Am9N0",
  authDomain: "molitwy.firebaseapp.com",
  projectId: "molitwy",
  storageBucket: "molitwy.firebasestorage.app",
  messagingSenderId: "654293224787",
  appId: "1:654293224787:web:5f4fce64abf5ba1b1ea5a6"
};

const app = initializeApp(firebaseConfig);

// ✅ Используем НОВЫЙ метод инициализации с настройками кэша,
// который заменяет и getFirestore(), и enableIndexedDbPersistence()
const db = initializeFirestore(app, {
  localCache: persistentLocalCache({})
});

// Экспортируем db, как и раньше
export { db };
```

### src/i18n.js
```
import { createI18n } from 'vue-i18n';
import ru from './locales/ru.json';
import be from './locales/be.json';

const savedLanguage = localStorage.getItem('language') || 'ru';

const i18n = createI18n({
  legacy: false, 
  locale: savedLanguage,
  fallbackLocale: 'be',
  messages: {
    ru,
    be
  },
  datetimeFormats: {
    'ru': { short: { day: 'numeric', month: 'short' } },
    'be': { short: { day: 'numeric', month: 'short' } }
  }
});

export default i18n;
```

### src/locales/be.json
```
{
  "appTitle": "Мае малітвы",
  "allPrayers": "Усе малітвы",
  "myPrayerRule": "Малітоўнае правіла",

  "searchPlaceholder": "Пошук...",
  "filterByTags": "Фільтр па тэгах",
  "viewMode": "Выгляд спісу",
  "viewModeHint": "Карткі ці кампактны спіс",

  "done": "Гатова",
  "edit": "Рэдагаваць",
  "delete": "Выдаліць",
  "cancel": "Адмена",
  "add": "Дадаць",
  "start": "Пачаць",
  "days": "дзён",

  "pin": "Замацаваць",
  "unpin": "Адмацаваць",
  "loading": "Загрузка...",
  "backToHome": "Вярнуцца на галоўную",

  "title": "Назва",
  "source": "Крыніца",
  "tags": "Тэгі",
  "sourceLabel": "Крыніца:",
  "tagsLabel": "Тэгі:",
  "newNote": "Новая нататка",
  "editing": "Рэдагаванне",
  "noteSavedSuccess": "Нататка паспяхова захавана!",
  "noteDeletedSuccess": "Нататка паспяхова выдалена!",
  "hiddenNote": "Нататка схаваная (не бачная іншым)",
  "noNotesFound": "Нататак не знойдзена",
  "noteNotFound": "Нататка не знойдзена",
  "noteNotFoundMessage": "Магчыма, яна была выдаленая або спасылка няправільная.",
  "confirmDeletion": "Пацвердзіце выдаленне",
  "deleteConfirmationMessage": "Вы ўпэўнены, што хочаце назаўсёды выдаліць нататку \"{title}\"?",

  "style": {
    "normal": "Звычайны",
    "h2": "Загаловак 1",
    "h3": "Загаловак 2",
    "rubric": "Рубрыка"
  },
  "linkedNotesAdd": "Дадаць сувязь",
  "linkedNotesSelect": "Абярыце нататку для сувязі",
  "noTextInLang": "Тэкст на гэтай мове адсутнічае",

  "settings": "Налады",
  "generalSettings": "Агульныя налады",
  "appearance": "Знешні выгляд",
  "darkTheme": "Цёмная тэма",
  "themeIs": "Зараз выкарыстоўваецца {themeName} тэма",
  "themeNames": { "light": "светлая", "dark": "цёмная" },
  "fontSize": "Памер тэксту",
  "fontSizeHint": "Наладзьце памер шрыфту для чытання",
  "fontFamily": "Шрыфт праграмы",
  "fontFamilyHint": "Абярыце асноўны шрыфт для інтэрфейсу",
  "previewText": "Так будзе выглядаць асноўны тэкст вашай нататкі.",
  "keepScreenOn": "Не выключаць экран",
  "keepScreenOnHint": "Карысна падчас малітвы або чытання",
  "language": "Мова",
  "menuCategories": "Катэгорыі ў меню",
  "addCategory": "Дадаць катэгорыю",
  "categoryName": "Назва катэгорыі",
  "categoryTags": "Абярыце або ўвядзіце тэгі",
  "textSettings": "Налады тэксту",

  "admin": "Адмінка",
  "adminText": "Тут будзе панэль адміністратара. Пакуль гэта толькі нарыхтоўка для будучых функцый.",
  "showHiddenNotes": "Паказваць скрытыя нататкі",
  "showHiddenNotesHint": "Уплывае толькі на ваш выгляд спісу",

  "about": "Аб праграме",
  "aboutText": "Гэта праграма створана для асабістага збору малітваў і нататак.",
  "version": "Версія: 1.0.0",
  "devWithLove": "Распрацавана з любоўю.",

  "login": "Уваход",
  "logout": "Выхад",
  "loginTitle": "Уваход для адміністратара",
  "email": "Email",
  "emailRequired": "Email абавязковы",
  "password": "Пароль",
  "passwordRequired": "Пароль абавязковы",
  "loginError": "Няправільны email або пароль.",

  "langLabels": {
    "ru": "Рус",
    "be": "Бел",
    "la": "Lat",
    "pl": "Pl"
  },

  "novenaSettings": "Налады навэнны",
  "isNovenaPrayerLabel": "Гэта малітва-навэнна",
  "recommendedDateLabel": "Дата свята (для прапаноў)",
  "recommendedDateHint": "Пазначце дзень, да якога прывязана навэнна",
  "startNovena": "Пачаць навэнну",
  "endNovena": "Завяршыць навэнну",
  "novenaDurationTitle": "Працягласць навэнны",
  "novenaDaysLabel": "Колькасць дзён",
  "prayerNovena": "Малітоўная навэнна",
  "novenaTrackerHint": "Націскайце на ячэйкі, каб адзначыць выкананыя або прапушчаныя дні.",
  "novenaSuggestionTitle": "Прапанова навэнны",
  "novenaSuggestionText": "Сёння пачынаецца навэнна «{title}» ({days} дзён). Не жадаеце памаліцца?",
  "viewPrayer": "Паглядзець",
  "remindLater": "Пазней",
  "enableNovenaSuggestions": "Прапановы па навэннах",
  "enableNovenaSuggestionsHint": "Паказваць апавяшчэнні, калі падыходзіць час для рэкамендаваных навэнн",

  "addPrayerToRule": "Дадаць малітву ў правіла",
  "findPrayer": "Знайсці малітву...",
  "ruleIsEmpty": "Ваша правіла пакуль пустое.",
  "ruleIsEmptyHint": "Дадайце малітвы, каб скласці сваё правіла.",
  "noRuleCreated": "Малітоўнае правіла яшчэ не створана",
  "noRuleCreatedHint": "Націсніце кнопку ніжэй, каб скласці свой спіс штодзённых малітваў.",
  "createRule": "Стварыць правіла",
  "decline": "Адхіліць",

  "novenaDurationChoice": "Выберы колькасць дзён",
  "novenaDurationInput": "Альбо, напішы",
  "dataManagement": "Кіраванне данымі",
  "exportToJson": "Экспарт у JSON",
  "exportToCsv": "Экспарт у CSV",
  "importFromFile": "Імпарт з файла",
  "exportSuccess": "Экспарт паспяхова завершаны!",
  "exportError": "Памылка падчас экспарту.",
  "importParseError": "Не атрымалася прачытаць файл. Пераканайцеся, што гэта карэктны JSON-файл.",
  "importDbError": "Адбылася памылка пры захаванні даных.",
  "importSuccess": "Імпарт завершаны. Дададзена: {added}, Абноўлена: {updated}.",
  "importConfirmationTitle": "Пацвярджэнне імпарту",
  "importConfirmationMessage": "Вы збіраецеся імпартаваць {count} запісаў з файла {fileName}.",
  "importWarning": "Гэта дзеянне нельга адмяніць. Існуючыя запісы могуць быць перазапісаны ў залежнасці ад абранага рэжыму.",
  "importModeLabel": "Рэжым імпарту:",
  "importMode": {
    "add": "Дадаваць толькі новыя",
    "overwrite": "Дадаваць новыя і перазапісваць існуючыя"
  },
  "import": "Імпартаваць",
"noteLanguage": "Мова",
"languageCannotBeChanged": "Мову нельга змяніць пасля стварэння.",
"translations": "Пераклады",
"addTranslation": "Дадаць пераклад",
"selectTranslation": "Выберыце пераклад",
"translationLinked": "Пераклад паспяхова прывязаны!",
"translationUnlinked": "Сувязь з перакладам выдалена.",
"titleRequired": "Калі ласка, ўвядзіце назву.",
"langLabelsFull": {
    "ru": "Русский",
    "be": "Беларуская",
    "la": "Latina",
    "pl": "Polski"
},
 "share": "Падзяліцца",
  "copyLink": "Капіяваць спасылку",
  "linkCopied": "Спасылка скапіявана ў буфер абмену!",
  "shareError": "Не атрымалася падзяліцца. Магчыма, ваш браўзер не падтрымлівае гэту функцыю.",
  "filters": "Фільтры",
  "holyMass": "Святая Імша"
}
```

### src/locales/ru.json
```
{
  "appTitle": "Мои молитвы",
  "allPrayers": "Все молитвы",
  "myPrayerRule": "Молитвенное правило",

  "searchPlaceholder": "Поиск...",
  "filterByTags": "Фильтр по тегам",
  "viewMode": "Вид списка",
  "viewModeHint": "Карточки или компактный список",

  "done": "Готово",
  "edit": "Редактировать",
  "delete": "Удалить",
  "cancel": "Отмена",
  "add": "Добавить",
  "start": "Начать",
  "days": "дней",

  "pin": "Закрепить",
  "unpin": "Открепить",
  "loading": "Загрузка...",
  "backToHome": "Вернуться на главную",

  "title": "Название",
  "source": "Источник",
  "tags": "Теги",
  "sourceLabel": "Источник:",
  "tagsLabel": "Теги:",
  "newNote": "Новая заметка",
  "editing": "Редактирование",
  "noteSavedSuccess": "Заметка успешно сохранена!",
  "noteDeletedSuccess": "Заметка успешно удалена!",
  "hiddenNote": "Заметка скрыта (не видна другим)",
  "noNotesFound": "Заметок не найдено",
  "noteNotFound": "Заметка не найдена",
  "noteNotFoundMessage": "Возможно, она была удалена или ссылка неверна.",
  "confirmDeletion": "Подтвердите удаление",
  "deleteConfirmationMessage": "Вы уверены, что хотите навсегда удалить заметку \"{title}\"?",

  "style": {
    "normal": "Обычный",
    "h2": "Заголовок 1",
    "h3": "Заголовок 2",
    "rubric": "Рубрика"
  },
  "linkedNotesAdd": "Добавить связь",
  "linkedNotesSelect": "Выберите заметку для связи",
  "noTextInLang": "Текст на этом языке отсутствует",

  "settings": "Настройки",
  "generalSettings": "Общие настройки",
  "appearance": "Внешний вид",
  "darkTheme": "Тёмная тема",
  "themeIs": "Сейчас используется {themeName} тема",
  "themeNames": { "light": "светлая", "dark": "тёмная" },
  "fontSize": "Размер текста",
  "fontSizeHint": "Настройте размер шрифта для чтения",
  "fontFamily": "Шрифт приложения",
  "fontFamilyHint": "Выберите основной шрифт для интерфейса",
  "previewText": "Так будет выглядеть основной текст вашей заметки.",
  "keepScreenOn": "Не выключать экран",
  "keepScreenOnHint": "Полезно во время молитвы или чтения",
  "language": "Язык",
  "menuCategories": "Категории в меню",
  "addCategory": "Добавить категорию",
  "categoryName": "Название категории",
  "categoryTags": "Выберите или введите теги",
  "textSettings": "Настройки текста",

  "admin": "Админка",
  "adminText": "Здесь будет панель администратора. Пока это лишь заготовка для будущих функций.",
  "showHiddenNotes": "Показывать скрытые заметки",
  "showHiddenNotesHint": "Влияет только на ваш вид списка",

  "about": "О приложении",
  "aboutText": "Это приложение создано для личного сбора молитв и заметок.",
  "version": "Версия: 1.0.0",
  "devWithLove": "Разработано с любовью.",

  "login": "Вход",
  "logout": "Выход",
  "loginTitle": "Вход для администратора",
  "email": "Email",
  "emailRequired": "Email обязателен",
  "password": "Пароль",
  "passwordRequired": "Пароль обязателен",
  "loginError": "Неверный email или пароль.",

  "langLabels": {
    "ru": "Рус",
    "be": "Бел",
    "la": "Lat",
    "pl": "Pl"
  },

  "novenaSettings": "Настройки новенны",
  "isNovenaPrayerLabel": "Это молитва-новенна",
  "recommendedDateLabel": "Дата праздника (для предложений)",
  "recommendedDateHint": "Укажите день, к которому привязана новенна",
  "startNovena": "Начать новенну",
  "endNovena": "Завершить новенну",
  "novenaDurationTitle": "Длительность новенны",
  "novenaDaysLabel": "Количество дней",
  "prayerNovena": "Молитвенная новенна",
  "novenaTrackerHint": "Нажимайте на ячейки, чтобы отметить выполненные или пропущенные дни.",
  "novenaSuggestionTitle": "Предложение новенны",
  "novenaSuggestionText": "Сегодня начинается новенна «{title}» ({days} дней). Не хотите помолиться?",
  "viewPrayer": "Посмотреть",
  "remindLater": "Позже",
  "enableNovenaSuggestions": "Предложения по новеннам",
  "enableNovenaSuggestionsHint": "Показывать уведомления, когда подходит время для рекомендованных новенн",

  "addPrayerToRule": "Добавить молитву в правило",
  "findPrayer": "Найти молитву...",
  "ruleIsEmpty": "Ваше правило пока пусто.",
  "ruleIsEmptyHint": "Добавьте молитвы, чтобы составить свое правило.",
  "noRuleCreated": "Молитвенное правило еще не создано",
  "noRuleCreatedHint": "Нажмите кнопку ниже, чтобы составить свой список ежедневных молитв.",
  "createRule": "Создать правило",
  "decline": "Отклонить",

  "novenaDurationChoice": "Выбери колличество дней",
  "novenaDurationInput": "Или, введи",
  "dataManagement": "Управление данными",
  "exportToJson": "Экспорт в JSON",
  "exportToCsv": "Экспорт в CSV",
  "importFromFile": "Импорт из файла",
  "exportSuccess": "Экспорт успешно завершен!",
  "exportError": "Ошибка во время экспорта.",
  "importParseError": "Не удалось прочитать файл. Убедитесь, что это корректный JSON-файл.",
  "importDbError": "Произошла ошибка при сохранении данных.",
  "importSuccess": "Импорт завершен. Добавлено: {added}, Обновлено: {updated}.",
  "importConfirmationTitle": "Подтверждение импорта",
  "importConfirmationMessage": "Вы собираетесь импортировать {count} записей из файла {fileName}.",
  "importWarning": "Это действие нельзя отменить. Существующие записи могут быть перезаписаны в зависимости от выбранного режима.",
  "importModeLabel": "Режим импорта:",
  "importMode": {
    "add": "Добавлять только новые",
    "overwrite": "Добавлять новые и перезаписывать существующие"
  },
  "import": "Импортировать"
  ,"noteLanguage": "Язык заметки",
"languageCannotBeChanged": "Язык нельзя изменить после создания.",
"translations": "Переводы",
"addTranslation": "Добавить перевод",
"selectTranslation": "Выберите перевод",
"translationLinked": "Перевод успешно привязан!",
"translationUnlinked": "Связь с переводом удалена.",
"titleRequired": "Пожалуйста, введите название.",
"langLabelsFull": {
    "ru": "Русский",
    "be": "Беларуская",
    "la": "Latina",
    "pl": "Polski"
},
"share": "Поделиться",
  "copyLink": "Копировать ссылку",
  "linkCopied": "Ссылка скопирована в буфер обмена!",
  "shareError": "Не удалось поделиться. Возможно, ваш браузер не поддерживает эту функцию.",
  "filters": "Фильтры",
  "holyMass": "Святая Месса"
}
```

### src/main.js
```
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'
import router from './router'
import vuetify from './plugins/vuetify'
import i18n from './i18n'
import './firebase' // Импортируем для инициализации Firebase
import '@mdi/font/css/materialdesignicons.css'
import './styles/main.css'

const app = createApp(App)

app.use(createPinia())
app.use(router)
app.use(vuetify)
app.use(i18n)

app.mount('#app')
```

### src/plugins/vuetify.js
```

import 'vuetify/styles';
import { createVuetify } from 'vuetify';
import * as components from 'vuetify/components';
import * as directives from 'vuetify/directives';

export default createVuetify({
  components,
  directives,
});


```

### src/router/index.js
```
import { createRouter, createWebHistory } from 'vue-router';
import { getAuth, onAuthStateChanged } from 'firebase/auth';
import { useAuthStore } from '@/stores/auth';

const getCurrentUser = () => {
  return new Promise((resolve, reject) => {
    const removeListener = onAuthStateChanged(
      getAuth(),
      (user) => {
        removeListener();
        resolve(user);
      },
      reject
    );
  });
};

const routes = [
  { path: '/login', name: 'Login', component: () => import('@/components/LoginView.vue') },
  { path: '/', name: 'ItemsList', component: () => import('@/components/ItemsList.vue') },
  { path: '/item/:id', name: 'ItemView', component: () => import('@/components/ItemView.vue'), props: true },
  { path: '/p/:id', name: 'PublicItemView', component: () => import('@/components/ItemView.vue'), props: true },
  { path: '/settings', name: 'Settings', component: () => import('@/components/SettingsView.vue') },
  { path: '/edit/:id', name: 'ItemEdit', component: () => import('@/components/ItemForm.vue'), props: true, meta: { requiresAuth: true } },
  { path: '/add', name: 'ItemAdd', component: () => import('@/components/ItemForm.vue'), meta: { requiresAuth: true } },
  { path: '/admin', name: 'Admin', component: () => import('@/components/AdminView.vue'), meta: { requiresAuth: true } },
  { path: '/about', name: 'About', component: () => import('@/components/AboutView.vue') },
    { path: '/rule', name: 'PrayerRule', component: () => import('@/components/PrayerRuleView.vue') },
     { path: '/mass', name: 'HolyMass', component: () => import('@/components/HolyMassView.vue') },
];

const router = createRouter({
  history: createWebHistory(),
  routes,
  // ✅ ДОБАВЬТЕ ЭТОТ БЛОК
  scrollBehavior(to, from, savedPosition) {
    // Если есть сохраненная позиция (при навигации назад/вперед),
    // то возвращаемся к ней.
    if (savedPosition) {
      return savedPosition;
    }
    // В противном случае (при новой навигации) всегда
    // прокручиваем в начало страницы.
    else {
      return { top: 0, left: 0 };
    }
  },
});

// --- ✅ НАВИГАЦИОННЫЙ СТРАЖ С ПОДРОБНЫМ ЛОГИРОВАНИЕМ ---
router.beforeEach(async (to, from, next) => {

  const authStore = useAuthStore();
  const requiresAuth = to.matched.some(record => record.meta.requiresAuth);
  const userIsLoggedIn = !!authStore.user;
  if (requiresAuth && !userIsLoggedIn) {
    next({ name: 'Login' });
  } else {
    next();
  }
});

export default router;
```

### src/stores/auth.js
```
import { defineStore } from 'pinia';
import { ref } from 'vue';
import { getAuth, signInWithEmailAndPassword, signOut, onAuthStateChanged } from 'firebase/auth';
import router from '@/router';

export const useAuthStore = defineStore('auth', () => {
  const user = ref(null);
  const auth = getAuth();
  const loading = ref(true);

  // --- ✅ ЛОГИРОВАНИЕ ВНУТРИ ХРАНИЛИЩА ---
  if (import.meta.env.DEV) {
    console.log('[AUTH STORE] Initializing...');
  }

  const unsubscribe = onAuthStateChanged(auth, (firebaseUser) => {
    // Этот лог покажет нам КАЖДЫЙ раз, когда Firebase меняет статус
    if (import.meta.env.DEV) {
      console.log(
        `%c[FIREBASE AUTH STATE CHANGED] User status updated.`,
        'color: #881391; font-weight: bold;',
        firebaseUser ? `Logged in as ${firebaseUser.email}` : 'Logged out.'
      );
    }
    user.value = firebaseUser;
    loading.value = false;
  });

  const login = async (email, password) => {
    try {
      await signInWithEmailAndPassword(auth, email, password);
      // После успешного входа, роутер сам перенаправит куда нужно
      // Добавляем небольшой таймаут, чтобы дать роутеру время на обработку нового состояния
      setTimeout(() => {
        const redirectPath = router.currentRoute.value.query.redirect || '/';
        router.push(redirectPath);
      }, 100);

    } catch (error) {
      console.error("Login Error:", error.code);
      throw error;
    }
  };

  const logout = async () => {
    await signOut(auth);
    // При выходе всегда перенаправляем на страницу входа
    router.push({ name: 'Login' });
  };
  
  const unbind = () => {
    unsubscribe();
  };

  return { user, login, logout, unbind, loading };
});
```

### src/stores/novena.js
```
import { defineStore } from 'pinia';
import { ref, watch, computed } from 'vue';
import { useSettingsStore } from './settings'; // ✅ Импортируем хранилище настроек

// Функция для получения даты в формате YYYY-MM-DD
const getTodayDateString = () => new Date().toISOString().split('T')[0];

export const useNovenaStore = defineStore('novenas', () => {
  // Структура: { noteId: { startDate, totalDays, completedDates: ['YYYY-MM-DD'] } }
  const novenas = ref(JSON.parse(localStorage.getItem('prayerNovenas') || '{}'));
const settings = useSettingsStore(); // ✅ Инициализируем settingsStore
  // Автосохранение в localStorage при любых изменениях
  watch(novenas, (newNovenas) => {
    localStorage.setItem('prayerNovenas', JSON.stringify(newNovenas));
  }, { deep: true });

  // --- ACTIONS (Действия) ---

  function startNovena(noteId, totalDays) {
    if (!noteId || !totalDays) return;
    novenas.value[noteId] = {
      startDate: getTodayDateString(),
      totalDays: Number(totalDays),
      completedDates: [],
    };
    // ✅ АВТОМАТИЧЕСКИ ЗАКРЕПЛЯЕМ МОЛИТВУ
    // Проверяем, не закреплена ли она уже, чтобы не открепить случайно
    if (!settings.isPinned(noteId)) {
        settings.togglePin(noteId);
    }
  }

  function endNovena(noteId) {
    delete novenas.value[noteId];
  }

  function toggleDayCompletion(noteId, dateString) {
    const novena = novenas.value[noteId];
    if (!novena) return;
    
    const completedIndex = novena.completedDates.indexOf(dateString);
    if (completedIndex > -1) {
      // Если день уже отмечен, снимаем отметку
      novena.completedDates.splice(completedIndex, 1);
    } else {
      // Иначе, добавляем
      novena.completedDates.push(dateString);
      novena.completedDates.sort(); // Держим массив отсортированным
    }
  }

  // --- GETTERS (Вычисляемые свойства) ---

  const isNovenaActive = computed(() => (noteId) => {
    return !!novenas.value[noteId];
  });
  
  const getNovenaData = computed(() => (noteId) => {
      return novenas.value[noteId];
  });


  return {
    novenas,
    startNovena,
    endNovena,
    toggleDayCompletion,
    isNovenaActive,
    getNovenaData,
    getTodayDateString,
  };
});
```

### src/stores/prayerRule.js
```
import { defineStore } from 'pinia';
import { ref, watch } from 'vue';
export const usePrayerRuleStore = defineStore('prayerRule', () => {
  // Теперь храним только ID заметки
  const ruleItems = ref(JSON.parse(localStorage.getItem('prayerRule') || '[]'));
  watch(ruleItems, (newRule) => {
    localStorage.setItem('prayerRule', JSON.stringify(newRule));
  }, { deep: true });
  function addItem(item) {
    if (!item || ruleItems.value.some(itemId => itemId === item.id)) return;
    ruleItems.value.push(item.id);
  }
  function removeItem(index) {
    ruleItems.value.splice(index, 1);
  }
  
  // Функция updateItemLanguage больше не нужна
  function moveItem(fromIndex, toIndex) {
    if (fromIndex < 0 || fromIndex >= ruleItems.value.length || toIndex < 0 || toIndex >= ruleItems.value.length) {
      return;
    }
    const [item] = ruleItems.value.splice(fromIndex, 1);
    ruleItems.value.splice(toIndex, 0, item);
  }
  return { 
    ruleItems, 
    addItem,
    removeItem,
    moveItem
  };
});
```

### src/stores/settings.js
```
import { defineStore } from 'pinia';
import { ref, watch } from 'vue';
import { useTheme } from 'vuetify';
import { useI18n } from 'vue-i18n';

const defaultCategories = [
  { name: 'Марыйныя', tags: ['Марыя'] },
  { name: 'Літаніі', tags: ['Літанія'] }
];

const systemFont = "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'";

export const useSettingsStore = defineStore('settings', () => {
  const theme = useTheme();
  const { locale } = useI18n();

  // --- Состояния (Refs) ---
  const currentTheme = ref(localStorage.getItem('theme') || 'light');
  const keepScreenOn = ref(JSON.parse(localStorage.getItem('keepScreenOn') || 'false'));
  const fontFamily = ref(localStorage.getItem('fontFamily') || systemFont);
  const fontSizeMultiplier = ref(parseFloat(localStorage.getItem('fontSizeMultiplier')) || 1.2);
  const viewMode = ref(localStorage.getItem('viewMode') || 'compact');
  const currentLanguage = ref(localStorage.getItem('language') || 'be');
  const pinnedIds = ref(JSON.parse(localStorage.getItem('pinnedIds') || '[]'));
  const menuCategories = ref(JSON.parse(localStorage.getItem('menuCategories') || JSON.stringify(defaultCategories)));
  const showHiddenItems = ref(JSON.parse(localStorage.getItem('showHiddenItems') || 'false'));

    // ✅ НОВАЯ НАСТРОЙКА
const novenaNotificationsEnabled = ref(JSON.parse(localStorage.getItem('prayer-novena-notifications') || 'true'));
  // --- Слежение за изменениями и сохранение в localStorage (Watchers) ---
  // ✅ ИСПРАВЛЕНО: Предупреждение Vuetify. Теперь используется актуальный метод.
  watch(currentTheme, (newTheme) => {
    theme.change(newTheme)
    localStorage.setItem('theme', newTheme);
  }, { immediate: true });
  watch(fontFamily, (v) => { document.documentElement.style.setProperty('--app-font-family', v); localStorage.setItem('fontFamily', v); }, { immediate: true });
  watch(fontSizeMultiplier, (newMultiplier) => { 
    document.documentElement.style.setProperty('--font-size-multiplier', newMultiplier);
    localStorage.setItem('fontSizeMultiplier', String(newMultiplier));
  }, { immediate: true }); // immediate: true - применяет стиль при первой же загрузке

  watch(keepScreenOn, (v) => localStorage.setItem('keepScreenOn', v));
  watch(viewMode, (v) => localStorage.setItem('viewMode', v));
  watch(currentLanguage, (v) => { locale.value = v; localStorage.setItem('language', v); }, { immediate: true });
  watch(pinnedIds, (v) => localStorage.setItem('pinnedIds', JSON.stringify(v)), { deep: true });
  watch(menuCategories, (v) => localStorage.setItem('menuCategories', JSON.stringify(v)), { deep: true });
  watch(showHiddenItems, (v) => localStorage.setItem('showHiddenItems', v));

  // --- Функции для изменения состояний (Actions) ---
  function toggleTheme() { currentTheme.value = currentTheme.value === 'light' ? 'dark' : 'light'; }
  function setFontFamily(font) { fontFamily.value = font; }
  function increaseFontSize() { if (fontSizeMultiplier.value < 1.5) fontSizeMultiplier.value = parseFloat((fontSizeMultiplier.value + 0.1).toFixed(2)); }
  function decreaseFontSize() { if (fontSizeMultiplier.value > 0.8) fontSizeMultiplier.value = parseFloat((fontSizeMultiplier.value - 0.1).toFixed(2)); }
  function toggleViewMode() { viewMode.value = viewMode.value === 'card' ? 'compact' : 'card'; }
  function setLanguage(lang) { currentLanguage.value = lang; }
  
  // ✅ --- ИСПРАВЛЕНО: Возвращаем удаленные функции для закрепления ---
  function isPinned(noteId) { return pinnedIds.value.includes(noteId); }
  function togglePin(noteId) {
    const index = pinnedIds.value.indexOf(noteId);
    if (index > -1) pinnedIds.value.splice(index, 1);
    else pinnedIds.value.unshift(noteId);
  }

  function addCategory(cat) { if (cat && cat.name && cat.tags?.length > 0) menuCategories.value.push(cat); }
  function removeCategory(index) { menuCategories.value.splice(index, 1); }
  function toggleShowHiddenItems() { showHiddenItems.value = !showHiddenItems.value; }

  // Управление WakeLock API
  let wakeLock = null;
  const setKeepScreenOn = async (value) => {
    keepScreenOn.value = value;
    if (value && 'wakeLock' in navigator) {
      try { wakeLock = await navigator.wakeLock.request('screen'); } catch (err) { console.error(`${err.name}, ${err.message}`); }
    } else {
      if (wakeLock !== null) wakeLock.release().then(() => { wakeLock = null; });
    }
  };
  watch(keepScreenOn, setKeepScreenOn, { immediate: true });

  return {
    currentTheme, toggleTheme,
    keepScreenOn, setKeepScreenOn,
    fontFamily, setFontFamily, systemFont,
    fontSizeMultiplier, increaseFontSize, decreaseFontSize,
    currentLanguage, setLanguage,
    viewMode, toggleViewMode,
    pinnedIds, isPinned, togglePin, // ✅ Экспортируем isPinned
    menuCategories, addCategory, removeCategory,
    showHiddenItems, toggleShowHiddenItems, novenaNotificationsEnabled
  };
});
```

### src/style.css
```

```

### src/styles/main.css
```
/* ==========================================================================
   ✅ ИСПРАВЛЕНИЯ ДЛЯ МОБИЛЬНЫХ УСТРОЙСТВ И SAMSUNG
   ========================================================================== */

/* 1. Запрещаем "усиление шрифтов" в Chrome и Samsung Internet */
html {
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
  text-size-adjust: 100%;
}

/* 2. Гарантируем, что основной контейнер приложения никогда не будет шире экрана */
#app {
  width: 100%;
  overflow-x: hidden;
}

/* 3. Заставляем текст молитв правильно переноситься */
.note-content-area {
  word-wrap: break-word;     /* Для старых браузеров */
  overflow-wrap: break-word; /* Стандартный способ */
  word-break: break-word;    /* Более "агрессивный" перенос, если нужно */

  /* Дополнительно предотвращаем горизонтальную прокрутку внутри блока */
  overflow-x: hidden;
}

/* ==========================================================================
   Глобальные переменные
   ========================================================================== */
:root {
  --font-size-multiplier: 1.0;
  /* Системный шрифт по умолчанию, если ничего не выбрано */
  --app-font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
}

/* ==========================================================================
   ТОЧЕЧНОЕ ПРИМЕНЕНИЕ ШРИФТОВ
   ========================================================================== */

/* 1. Применяем шрифт к тексту внутри заметок и к редактору */
.note-content-area, .ProseMirror {
  font-family: var(--app-font-family);
}

/* 2. Применяем шрифт к заголовку приложения в AppBar и в боковом меню */
.app-title {
  font-family: var(--app-font-family) !important; /* !important нужен здесь, чтобы перебить Vuetify */
}

/* ==========================================================================
   Стили для контента заметок (где работает изменение размера)
   ========================================================================== */
.note-content-area h2 { font-size: calc(1.5rem * var(--font-size-multiplier)); }
.note-content-area h3 { font-size: calc(1.15rem * var(--font-size-multiplier)); }
.note-content-area p, .note-content-area div { font-size: calc(1rem * var(--font-size-multiplier)); }
/* .note-content-area p {
  margin: 0 0 1em !important; 
} */
/* Убираем лишний отступ у последнего элемента, чтобы не было "висячего" пробела */
.note-content-area > *:last-child {
    margin-bottom: 0 !important;
}
/* ... (остальные стили для .note-content-area и другие правила остаются как были) ... */

/* ✅ РУБРИКА: красный, уменьшенный, курсивный, по центру */
.note-content-area .rubric {
  color: rgb(var(--v-theme-error));
  font-style: italic;
  text-align: center;
  font-size: calc(0.85rem * var(--font-size-multiplier)); /* уменьшенный размер */
}
.note-content-area > *:first-child { margin-top: 0 !important; }

.wrappable-toolbar-title { white-space: normal !important; line-height: 1.25 !important; font-size: 1.15rem !important; }
.lang-label { display: inline-block; padding: 2px 10px; background-color: rgba(var(--v-theme-on-surface), 0.08); color: rgba(var(--v-theme-on-surface), 0.7); border-radius: 12px; font-size: 0.8rem; font-weight: 700; margin-bottom: 12px; text-transform: uppercase; }
.ProseMirror { min-height: 200px; padding: 8px 12px; outline: none; }


.ProseMirror p { 
  margin-bottom: 0; 
}
/* ✅ RUBRIC в редакторе (уменьшенный размер, цвет, курсив, по центру) */
.ProseMirror p.rubric {
  color: rgb(var(--v-theme-error));
  font-size: calc(0.80rem * var(--font-size-multiplier));
}
.ProseMirror-focused { 
  border-color: transparent; 
  box-shadow: none; 
}


/* Улучшенные стили для связанных заметок */
.linked-notes-list .v-list-item__prepend .v-icon { 
  margin-inline-end: 12px; 
}


/* Стили для компактного списка */
.v-list.v-list--density-compact .v-list-item {
  min-height: 52px;
  border-bottom: 1px solid rgba(var(--v-border-color), 0.12);
}

/* Общее правило для переноса длинных заголовков в карточках */
.v-card-title span.flex-grow-1 {
  white-space: normal;
  word-break: break-word;
  line-height: 1.4;
}
/* 
  Правило для заголовков в режиме "Компактный список".
  Используем !important, чтобы гарантированно переопределить стили Vuetify.
*/
.v-list-item-title {
  white-space: normal !important;
  word-break: break-word !important;
  line-height: 1.4 !important;
}


/* ==========================================================================
   СТИЛИ ДЛЯ НОВЕНН
   ========================================================================== */
.note-content-area .current-day-marker {
  background-color: rgba(var(--v-theme-primary), 0.08);
  border-left: 3px solid rgba(var(--v-theme-primary), 0.7);
  /* Плавный переход для красоты */
  transition: all 0.3s ease-in-out;
  /* Отступы, чтобы текст не прилипал к рамке */
  padding-left: 12px;
  /* Компенсация отступа, чтобы текст визуально остался на месте */
  margin-left: -15px; 
}

/* Добавляем немного больше отступа сверху и снизу для выделенного блока */
.note-content-area .current-day-marker {
    margin-top: 1em;
    margin-bottom: 1em;
    padding-top: 4px;
    padding-bottom: 4px;
}
/* Общие стили для всех меток в редакторе */
.ProseMirror p[data-day]::before,
.ProseMirror p[data-marker]::before {
  font-family: "Material Design Icons"; /* ✅ Используем шрифт иконок */
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 1.2em; /* Размер иконки */
  font-weight: normal;
  color: rgb(var(--v-theme-primary));
  background-color: rgba(var(--v-theme-primary), 0.1);
  margin-right: 12px;
  vertical-align: middle;
  width: 26px;
  height: 26px;
  line-height: 26px;
  text-align: center;
  border-radius: 50%;
  border: 1px solid rgba(var(--v-theme-primary), 0.2);
}
/* Иконка для метки дня */
.ProseMirror p[data-day]::before {
  content: attr(data-day); /* Оставляем номер для дней */
  font-family: var(--app-font-family); /* Возвращаем обычный шрифт */
  font-size: 0.8em;
  font-weight: bold;
}
/* Иконка для метки "старт" */
.ProseMirror p[data-marker="start"]::before {
  content: "\F040A"; /* Код иконки mdi-play-circle-outline */
}
/* Иконка для метки "финиш" */
.ProseMirror p[data-marker="finish"]::before {
  content: "\F023C"; /* Код иконки mdi-flag-checkered */
}

/* --- Нормализация отступов параграфов в редакторе (ProseMirror) --- */
/* Устанавливаем аккуратный единообразный отступ между <p> внутри редактора */
.editor-content-wrapper > :deep(.ProseMirror) p {
  margin: 0 0 0.75rem;    /* нижний отступ (регулируйте: 0.5rem..1rem) */
  padding: 0;
  line-height: 1.45;      /* при желании можно подправить интерлиньяж */
}

/* На всякий случай убираем верхний отступ у последующего параграфа,
   чтобы не складывались два отступа вместе */
.editor-content-wrapper > :deep(.ProseMirror) p + p {
  margin-top: 0;
}

/* Если нужно — уменьшаем отступ специально для рубрик внутри редактора */
.editor-content-wrapper > :deep(.ProseMirror) p.rubric {
  margin: 0 0 0.9rem; /* можно чуть больше/меньше, как вам нравится */
}
/* ==========================================================================
   СТИЛИ ДЛЯ ПЛАВАЮЩИХ КНОПОК
   ========================================================================== */
.fab-container {
    position: fixed;
    bottom: 24px;
    right: 24px;
    display: flex;
    flex-direction: column;
    z-index: 5; /* Чуть ниже стандартных диалогов */
}

/* ==========================================================================
   Адаптивные стили для мобильных устройств
   ========================================================================== */

@media (max-width: 600px) {
  .v-main .v-container.items-list-container {
    padding: 8px 0 0 0 !important;
  }
  .items-list-container .v-card {
    margin-left: 8px; 
    margin-right: 8px; 
    margin-top: 12px; 
    border-radius: 8px !important;
  }
  .items-list-container .v-card:first-child { 
    margin-top: 0; 
  }
  .items-list-container .v-list { 
    padding: 0; 
  }
}

```

### src/utils/i18n.js
```
// src/utils/i18n.js

/**
 * Получает заголовок для элемента в соответствии с предпочитаемым языком и резервными вариантами.
 *
 * @param {object} item - Объект заметки, содержащий titleVersions.
 * @param {string[]} langOrder - Массив кодов языков в порядке предпочтения (напр., ['be', 'ru', 'la', 'pl']).
 * @returns {string} - Наиболее подходящий заголовок или пустая строка.
 */
export function getTitleByLang(item, langOrder = ['be', 'ru', 'la', 'pl']) {
  if (!item || !item.titleVersions) {
    return '';
  }

  // 1. Ищем заголовок в соответствии с порядком языков
  for (const lang of langOrder) {
    if (item.titleVersions[lang]) {
      return item.titleVersions[lang];
    }
  }

  // 2. Если ничего не найдено, берем первый доступный заголовок из объекта
  const availableLangs = Object.keys(item.titleVersions).filter(k => item.titleVersions[k]);
  if (availableLangs.length > 0) {
    return item.titleVersions[availableLangs[0]];
  }
  
  // 3. Если заголовков нет вообще
  return '';
}
```
