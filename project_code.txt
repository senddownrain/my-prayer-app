
### package.json
```
{
  "name": "my-prayer-app",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "export-code": "node export-code.js",
    "db:seed": "node seed-db.js"
  },
  "dependencies": {
    "@mdi/font": "^7.4.47",
    "@tiptap/extension-color": "^3.0.7",
    "@tiptap/extension-link": "^3.0.9",
    "@tiptap/extension-text-align": "^3.0.9",
    "@tiptap/extension-text-style": "^3.0.7",
    "@tiptap/pm": "^3.0.7",
    "@tiptap/starter-kit": "^3.0.7",
    "@tiptap/vue-3": "^3.0.7",
    "firebase": "^10.12.2",
    "pinia": "^3.0.3",
    "vue": "^3.4.27",
    "vue-i18n": "^11.1.11",
    "vue-router": "^4.3.3",
    "vuetify": "^3.6.8"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^5.0.5",
    "vite": "^5.2.13",
    "vite-plugin-pwa": "^0.20.5",
    "vite-plugin-vuetify": "^2.0.3"
  }
}

```

### vite.config.js
```
// vite.config.js
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';
import vuetify, { transformAssetUrls } from 'vite-plugin-vuetify';
import { VitePWA } from 'vite-plugin-pwa';
import path from 'path';

export default defineConfig({
  plugins: [
    vue({ 
      template: { transformAssetUrls }
    }),
    vuetify({
      autoImport: true,
    }),
    VitePWA({
      registerType: 'prompt',
      injectRegister: 'auto',
      strategies: 'generateSW',
      workbox: {
        cleanupOutdatedCaches: true,
        globPatterns: ['**/*.{js,css,html,ico,png,svg,json,vue,txt,woff2,webmanifest}'],
      },
      // ✅ Мы УДАЛИЛИ опцию manifestFile/manifestFilename.
      // Плагин по умолчанию создаст manifest.webmanifest, что нам и нужно.
      manifest: {
        name: 'Мае малітвы',
        short_name: 'Малітвы',
        description: 'Личный сборник молитв и заметок',
        theme_color: '#1867C0',
        background_color: '#ffffff',
        display: 'standalone',
        start_url: '.',
        icons: [
          {
            src: 'pwa-192x192.png',
            sizes: '192x192',
            type: 'image/png'
          },
          {
            src: 'pwa-512x512.png',
            sizes: '512x512',
            type: 'image/png'
          },
          {
            src: 'pwa-512x512.png',
            sizes: '512x512',
            type: 'image/png',
            purpose: 'maskable'
          }
        ]
      }
    })
  ],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});
```

### firebase.json
```
{
  "hosting": {
    "public": "dist",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "/manifest.webmanifest",
        "destination": "/manifest.webmanifest"
      },
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  }
}
```

### index.html
```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <!-- ================================================================== -->
    <!-- ✅ ОБНОВЛЕННЫЙ БЛОК ДЛЯ PWA И УСТАНОВКИ НА iOS + ANDROID          -->
    <!-- ================================================================== -->

    <!-- 1. Манифест для Android и стандартных браузеров -->
    <link rel="manifest" href="/manifest.webmanifest">

    <!-- 2. Основной цвет темы (влияет на цвет UI браузера) -->
    <meta name="theme-color" content="#1867C0">

    <!-- 3. Ключевой тег для iOS: иконка на домашнем экране -->
    <!-- Убедитесь, что файл 'apple-touch-icon.png' лежит в папке /public -->
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">

    <!-- 4. Мета-теги для полноэкранного режима на iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Малітвы">

    <!-- 5. Подключение шрифтов (без изменений) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@400;700&family=Kurale&family=Old+Standard+TT:ital,wght@0,400;0,700;1,400&family=Pacifico&family=Yeseva+One&display=swap" rel="stylesheet">
    
    <title>Мае Молітвы</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
```

### seed-db.js
```
const { initializeApp } = require("firebase/app");
const { getFirestore, collection, getDocs, writeBatch, addDoc, serverTimestamp, updateDoc, doc } = require("firebase/firestore");

const firebaseConfig = {
  apiKey: "AIzaSyDF2TD4MTcKiBChKRssauvL-nNyT4Am9N0",
  authDomain: "molitwy.firebaseapp.com",
  projectId: "molitwy",
  storageBucket: "molitwy.firebasestorage.app",
  messagingSenderId: "654293224787",
  appId: "1:654293224787:web:5f4fce64abf5ba1b1ea5a6"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// ✅ ИЗМЕНЕНИЕ: структура данных теперь использует titleVersions
const prayersData = [
  { id: "pater_noster", titleVersions: { ru: "Отче наш", be: "Ойча наш", la: "Pater Noster" }, tags: ["основные"], textVersions: { ru: "<p>Текст...</p>", be: "<p>Тэкст...</p>", la: "<p>Text...</p>" } },
  { id: "ave_maria", titleVersions: { ru: "Радуйся, Мария", be: "Вітай, Марыя", la: "Ave Maria" }, tags: ["основные", "марианские"], textVersions: { ru: "<p>Текст...</p>", be: "<p>Тэкст...</p>", la: "<p>Text...</p>" } },
  { id: "credo", titleVersions: { ru: "Символ веры", be: "Сімвал веры", la: "Credo" }, tags: ["основные"], textVersions: { ru: "<p>Текст...</p>", be: "<p>Тэкст...</p>", la: "<p>Text...</p>" }, linkedNoteIds: ["pater_noster", "ave_maria"] },
  { id: "gloria_patri", titleVersions: { ru: "Слава", be: "Хвала", la: "Gloria Patri" }, tags: ["основные"], textVersions: { ru: "<p>Текст...</p>", be: "<p>Тэкст...</p>", la: "<p>Text...</p>" }, linkedNoteIds: ["pater_noster"] },
];

async function clearCollection(db, collectionPath) {
  const collectionRef = collection(db, collectionPath);
  const snapshot = await getDocs(collectionRef);
  if (snapshot.empty) { console.log(`Коллекция '${collectionPath}' уже пуста.`); return; }
  const batch = writeBatch(db);
  snapshot.docs.forEach(doc => { batch.delete(doc.ref); });
  await batch.commit();
  console.log(`Все документы в коллекции '${collectionPath}' были удалены.`);
}

async function seedDatabase() {
  try {
    console.log("Очистка коллекции 'items'...");
    await clearCollection(db, 'items');
    console.log("Наполнение базы новыми данными...");
    const itemsCollection = collection(db, 'items');
    const addedIds = {};

    for (const prayer of prayersData) {
      // ✅ ИЗМЕНЕНИЕ: Собираем данные с titleVersions
      const dataToAdd = {
        titleVersions: prayer.titleVersions,
        tags: prayer.tags,
        textVersions: prayer.textVersions,
        createdAt: serverTimestamp()
      };
      const docRef = await addDoc(itemsCollection, dataToAdd);
      addedIds[prayer.id] = docRef.id;
      console.log(`- Добавлена: "${prayer.titleVersions.be || prayer.titleVersions.ru}"`);
    }

    console.log("Обновление связей...");
    for (const prayer of prayersData) {
        if (prayer.linkedNoteIds && prayer.linkedNoteIds.length > 0) {
            const realLinkedIds = prayer.linkedNoteIds.map(tempId => addedIds[tempId]);
            const realDocId = addedIds[prayer.id];
            await updateDoc(doc(db, "items", realDocId), { linkedNoteIds: realLinkedIds });
            console.log(`- Обновлены связи для "${prayer.titleVersions.be || prayer.titleVersions.ru}"`);
        }
    }
    console.log("Наполнение базы завершено!");
  } catch (error) {
    console.error("КРИТИЧЕСКАЯ ошибка:", error);
  }
}

seedDatabase();
```

### src/App.vue
```
<template>
  <v-app :theme="settings.currentTheme">
    <v-navigation-drawer v-model="isDrawerOpen" temporary>
      
      <!-- ✅ --- ФИНАЛЬНАЯ ВЕРСИЯ БЛОКА С ИЗОБРАЖЕНИЕМ --- ✅ -->
      <!-- Картинка теперь просто шапка, без текста внутри -->
        <v-img
        height="70"
        cover
      >
        <div class="d-flex flex-column justify-end h-100 pa-4">
         <h2 class="font-weight-bold app-title non-selectable">{{ $t('appTitle') }}</h2>
        </div>
      </v-img>
      
      <v-divider></v-divider>
      <!-- Основная навигация -->
      <v-list nav>
        <v-list-item 
          prepend-icon="mdi-format-list-text" 
          :title="$t('allPrayers')"
          @click="navigateToCategory(null)"
        ></v-list-item>
        
        <v-list-item
          v-for="category in settings.menuCategories"
          :key="category.name"
          prepend-icon="mdi-label-outline"
          :title="category.name"
          @click="navigateToCategory(category)"
        ></v-list-item>
        <v-divider></v-divider>
        <v-list-item 
          prepend-icon="mdi-book-open-variant" 
          :title="$t('myPrayerRule')"
          :to="{ name: 'PrayerRule' }"
        ></v-list-item>
        <v-divider></v-divider>
        <v-list-item 
          prepend-icon="mdi-cog-outline" 
          :title="$t('settings')"
          :to="{ name: 'Settings' }"
        ></v-list-item>
        <v-list-item 
          v-if="authStore.user"
          prepend-icon="mdi-shield-crown-outline" 
          :title="$t('admin')"
          :to="{ name: 'Admin' }"
        ></v-list-item>
        <v-list-item 
          prepend-icon="mdi-information-outline" 
          :title="$t('about')"
          :to="{ name: 'About' }"
        ></v-list-item>
        <v-divider></v-divider>
        <v-list-item
          v-if="authStore.user"
          prepend-icon="mdi-logout"
          :title="$t('logout')"
          @click="handleLogout"
        ></v-list-item>
         <v-list-item
          v-else
          prepend-icon="mdi-login"
          :title="$t('login')"
          :to="{ name: 'Login' }"
        ></v-list-item>
      </v-list>
    </v-navigation-drawer>

    <!-- AppBar остается без изменений -->
    <v-app-bar 
  :elevation="2" 
  app
  :scroll-behavior="isItemViewPage ? 'hide' : undefined"
>
      <v-btn v-if="showBackButton" icon="mdi-arrow-left" @click="router.back()"></v-btn>
      <v-btn v-else icon="mdi-menu" @click="isDrawerOpen = !isDrawerOpen"></v-btn>
      <v-expand-x-transition>
          <v-text-field
              v-if="isSearchActive"
              v-model="search"
              :placeholder="$t('searchPlaceholder')"
              variant="solo-inverted"
              flat
              hide-details
              autofocus
              density="compact"
              class="mr-2"
              @blur="isSearchActive = false"
              clearable  
              @click:clear="isSearchActive = false; search = '';"
          ></v-text-field>
      </v-expand-x-transition>
      <v-toolbar-title 
        v-if="!isSearchActive" 
        @click="goHome" 
        style="cursor: pointer;"
        class="font-weight-medium"
      >
       <span class="wrappable-toolbar-title app-title non-selectable">{{ $t('appTitle') }}</span>
      </v-toolbar-title>
      <template v-if="!isSearchActive">
          <template v-if="isHomePage">
            <v-btn icon="mdi-magnify" @click="isSearchActive = true"></v-btn>
            <v-btn icon="mdi-filter-variant" @click="isFilterSheetOpen = true"></v-btn>
          </template>
          <template v-if="isItemViewPage">
            <v-btn 
              :icon="settings.isPinned(currentItemId) ? 'mdi-pin' : 'mdi-pin-outline'"
              :color="settings.isPinned(currentItemId) ? 'primary' : 'grey'"
              @click="settings.togglePin(currentItemId)"
            ></v-btn>
            <v-btn icon="mdi-tune-variant" @click="openTextSettings"></v-btn>
            <v-btn 
        v-if="isItemViewPage && authStore.user" 
        icon="mdi-pencil" 
        @click="router.push({ name: 'ItemEdit', params: { id: currentItemId } })"
      ></v-btn>
          </template>
          <v-btn v-if="showSaveButton" icon="mdi-check" @click="triggerSave"></v-btn>

          
       <!-- ✅ НАША НОВАЯ КНОПКА РЕДАКТИРОВАНИЯ ПРАВИЛА -->
      <v-btn
        v-if="showPrayerRuleEditButton"
  @click="toggleEditing"
      >
        <v-icon>{{ isEditing ? 'mdi-check' : 'mdi-pencil' }}</v-icon>

      </v-btn>
      </template>

    </v-app-bar>

    <v-main>
      <router-view v-if="!authStore.loading" />
      <!-- Показываем красивый индикатор загрузки в центре, пока приложение готовится -->
      <div v-else class="d-flex justify-center align-center fill-height">
        <v-progress-circular indeterminate color="primary" size="64"></v-progress-circular>
      </div>
      <FilterSheet />
      <TextSettingsSheet />
      
    </v-main>
    <NotificationSnackbar ref="snackbar" />
      <ReloadPrompt /> <!-- ✅ ДОБАВЬТЕ ЭТУ СТРОКУ -->
      <!-- ✅ НОВЫЙ ДИАЛОГ-ПРЕДЛОЖЕНИЕ НОВЕННЫ -->
    <v-dialog 
      :model-value="!!suggestion" 
      max-width="500px" 
      persistent
    >
      <v-card v-if="suggestion" class="pa-2">
        <v-card-title class="d-flex align-center">
          <v-icon color="primary" start>mdi-lightbulb-on-outline</v-icon>
          <span class="text-h5">{{ $t('novenaSuggestionTitle') }}</span>
        </v-card-title>
        <v-card-text class="text-body-1 py-4">
          {{ $t('novenaSuggestionText', { title: getTitle(suggestion.item), days: suggestion.days }) }}
        </v-card-text>
        <v-card-actions>
          <v-spacer></v-spacer>
          <v-btn
            variant="text"
            color="grey"
            @click="dismissSuggestion(true)"
          >
            {{ $t('decline') }}
          </v-btn>
          <v-btn
            variant="text"
            @click="dismissSuggestion(false)"
          >
            {{ $t('remindLater') }}
          </v-btn>
          
          <v-btn
            color="primary"
            variant="flat"
            @click="viewSuggestedNovena"
          >
            {{ $t('viewPrayer') }}
          </v-btn>
        </v-card-actions>
      </v-card>
    </v-dialog>
  </v-app>
</template>

<script setup>
import { ref, onMounted, provide, computed, watch } from 'vue';
import { useRouter, useRoute } from 'vue-router';

import { useItems } from '@/composables/useItems';
import { useSettingsStore } from '@/stores/settings';
import { useAppBar } from '@/composables/useAppBar';
import { useFilters } from '@/composables/useFilters';

import { usePageMode } from '@/composables/usePageMode'; // ✅ Импорт
import { useAuthStore } from '@/stores/auth';
import { notifier } from '@/composables/useNotifier';
import { useNovenaSuggestions } from '@/composables/useNovenaSuggestions';
import FilterSheet from '@/components/FilterSheet.vue';
import NotificationSnackbar from '@/components/NotificationSnackbar.vue';
import TextSettingsSheet from '@/components/TextSettingsSheet.vue'; // ✅ ИМПОРТ
import { getTitleByLang } from '@/utils/i18n'; // Добавьте этот импорт
import ReloadPrompt from '@/components/ReloadPrompt.vue'; // ✅ ДОБАВЬТЕ ЭТОТ ИМПОРТ

const getTitle = (item) => getTitleByLang(item); // Добавьте эту строку

const settings = useSettingsStore();
const router = useRouter();
const route = useRoute();
const authStore = useAuthStore();

const { items, isLoading } = useItems();
const { isDrawerOpen, isSearchActive, isFilterSheetOpen, isTextSettingsSheetOpen  } = useAppBar();
const { selectedTags, search } = useFilters();
const { suggestion, checkSuggestions, viewSuggestedNovena, dismissSuggestion } = useNovenaSuggestions();
const { isEditing, toggleEditing } = usePageMode(); // ✅ Получаем состояние

const snackbar = ref(null);
const showPrayerRuleEditButton = computed(() => route.name === 'PrayerRule');
const isHomePage = computed(() => route.name === 'ItemsList');
const showBackButton = computed(() => !isHomePage.value);
const showSaveButton = computed(() => ['ItemEdit', 'ItemAdd'].includes(route.name));

const isItemViewPage = computed(() => route.name === 'ItemView');
const currentItemId = computed(() => route.params.id); //

function openTextSettings() {
  console.log(`[App.vue] Button clicked. 'isTextSettingsSheetOpen' is currently: ${isTextSettingsSheetOpen.value}`);
  isTextSettingsSheetOpen.value = true;
  console.log(`[App.vue] State changed. 'isTextSettingsSheetOpen' is now: ${isTextSettingsSheetOpen.value}`);
}

watch(isLoading, (newIsLoading) => {
  if (!newIsLoading && settings.novenaNotificationsEnabled) {
    checkSuggestions();
  }
});

watch(() => route.name, (newName) => {
  console.group(`[App.vue WATCHER] Имя маршрута изменилось!`);
  console.log(`Новое имя маршрута: %c'${newName}'`, 'color: blue; font-weight: bold;');
  const isPrayerRule = newName === 'PrayerRule';
  console.log(`Сравнение с 'PrayerRule' дает: %c${isPrayerRule}`, `color: ${isPrayerRule ? 'green' : 'red'}; font-weight: bold;`);
  console.log(`Итоговое значение showPrayerRuleEditButton: %c${showPrayerRuleEditButton.value}`, `color: ${showPrayerRuleEditButton.value ? 'green' : 'red'}; font-weight: bold;`);
  console.groupEnd();
}, { immediate: true }); // immediate: true выполнит проверку сразу при загрузке
const saveAction = ref(null);
const triggerSave = () => {
  if (saveAction.value) saveAction.value();
};
provide('registerSaveAction', (action) => {
  saveAction.value = action;
});


onMounted(() => {
  notifier.value = snackbar.value;
});

function goHome() {
  if (!isHomePage.value) {
    router.push({ name: 'ItemsList' });
  }
}

function navigateToCategory(category) {
  selectedTags.value = category ? (category.tags || []) : [];
  goHome();
  isDrawerOpen.value = false;
}

async function handleLogout() {
    isDrawerOpen.value = false;
    await authStore.logout();
}
</script>
<style>
.non-selectable {
  -webkit-user-select: none; /* Safari */
  -ms-user-select: none; /* IE 10+ */
  user-select: none; /* Standard syntax */
}
</style>
```

### src/components/AboutView.vue
```
<template>
  <v-container>
    <v-card>
      <v-card-title class="text-h5">{{ $t('about') }}</v-card-title>
      <v-card-text>
        <p>{{ $t('aboutText') }}</p>
        <p class="mt-4">{{ $t('version') }}</p>
        <p>{{ $t('devWithLove') }}</p>
      </v-card-text>
    </v-card>
  </v-container>
</template>

<script setup>
// Скрипт больше не нужен, так как AppBar управляется глобально
</script>
```

### src/components/AddCategoryDialog.vue
```
<!-- src/components/dialogs/AddCategoryDialog.vue -->
<template>
  <v-dialog
    :model-value="modelValue"
    @update:modelValue="$emit('update:modelValue', $event)"
    max-width="600px"
    :fullscreen="$vuetify.display.mobile"
    scrollable
  >
    <v-card>
      <v-card-title>{{ $t('addCategory') }}</v-card-title>
      <v-card-text>
        <v-form @submit.prevent="onAddCategory">
          <v-text-field
            v-model="newCategory.name"
            :label="$t('categoryName')"
            variant="outlined"
            class="mb-4"
          ></v-text-field>
          <v-combobox
            v-model="newCategory.tags"
            :items="allTags"
            :label="$t('categoryTags')"
            variant="outlined"
            multiple
            chips
            clearable
          ></v-combobox>
        </v-form>
      </v-card-text>
      <v-card-actions>
        <v-spacer></v-spacer>
        <v-btn text @click="$emit('update:modelValue', false)">{{ $t('cancel') }}</v-btn>
        <v-btn color="primary" variant="flat" @click="onAddCategory">{{ $t('add') }}</v-btn>
      </v-card-actions>
    </v-card>
  </v-dialog>
</template>

<script setup>
import { ref } from 'vue';
import { useSettingsStore } from '@/stores/settings';
import { useItems } from '@/composables/useItems';

defineProps({ modelValue: Boolean });
const emit = defineEmits(['update:modelValue']);

const settings = useSettingsStore();
const { allTags } = useItems();
const newCategory = ref({ name: '', tags: [] });

function onAddCategory() {
  if (newCategory.value.name && newCategory.value.tags.length > 0) {
    settings.addCategory({ ...newCategory.value });
    newCategory.value = { name: '', tags: [] };
    emit('update:modelValue', false); // Закрываем диалог
  }
}
</script>
```

### src/components/AdminView.vue
```
<template>
  <v-container>
    <v-card>
      <v-card-title class="text-h5">{{ $t('admin') }}</v-card-title>
      <v-card-text>
        <p>
          {{ $t('adminText') }}
        </p>
      </v-card-text>
    </v-card>

    <v-list lines="two" subheader class="mt-4">
      <v-list-subheader>{{ $t('generalSettings') }}</v-list-subheader>
      <v-list-item 
        :title="$t('showHiddenNotes')" 
        :subtitle="$t('showHiddenNotesHint')"
      >
        <template v-slot:prepend><v-icon>mdi-eye-off-outline</v-icon></template>
        <template v-slot:append>
          <v-switch
            :model-value="settings.showHiddenItems"
            @update:model-value="settings.toggleShowHiddenItems"
            color="primary"
            inset
            hide-details
          ></v-switch>
        </template>
      </v-list-item>
    </v-list>
  </v-container>
</template>

<script setup>
import { useSettingsStore } from '@/stores/settings';
const settings = useSettingsStore();
</script>
```

### src/components/Editor.vue
```
<template>
  <!-- ✅ ИСПРАВЛЕНИЕ 1: Оборачиваем весь компонент в один родительский div, 
       чтобы решить проблему с "Extraneous non-props attributes" -->
  <div>
    <div v-if="editor" class="editor-wrapper">
      <!-- Панель инструментов -->
      <div class="editor-toolbar">
        <!-- ... (меню стилей, кнопки bold/italic без изменений) ... -->
        <v-menu offset-y>
          <template v-slot:activator="{ props }">
            <v-btn v-bind="props" density="compact" class="mr-2" style="min-width: 130px;">
              {{ currentStyleLabel }}
              <v-icon right>mdi-menu-down</v-icon>
            </v-btn>
          </template>
          <v-list density="compact">
            <v-list-item @click="editor.chain().focus().setParagraph().run()" :active="editor.isActive('paragraph')">
              <v-list-item-title>{{ $t('style.normal') }}</v-list-item-title>
            </v-list-item>
            <v-list-item @click="editor.chain().focus().toggleHeading({ level: 2 }).run()" :active="editor.isActive('heading', { level: 2 })">
              <v-list-item-title>{{ $t('style.h2') }}</v-list-item-title>
            </v-list-item>
            <v-list-item @click="editor.chain().focus().toggleHeading({ level: 3 }).run()" :active="editor.isActive('heading', { level: 3 })">
              <v-list-item-title>{{ $t('style.h3') }}</v-list-item-title>
            </v-list-item>
            <!-- ✅ ИСПРАВЛЕНИЕ 4: Команда для рубрики теперь toggleClass -->
            <v-list-item @click="editor.chain().focus().toggleClass('rubric').run()" :active="editor.isActive({ class: 'rubric' })">
              <v-list-item-title>{{ $t('style.rubric') }}</v-list-item-title>
            </v-list-item>
          </v-list>
        </v-menu>

        <v-divider vertical class="mx-1"></v-divider>
        <!-- (кнопки форматирования, списков, выравнивания) -->
        <v-btn-toggle v-bind="null" multiple density="compact" variant="text">
          <v-btn @click="editor.chain().focus().toggleBold().run()" :active="editor.isActive('bold')" icon="mdi-format-bold"></v-btn>
          <v-btn @click="editor.chain().focus().toggleItalic().run()" :active="editor.isActive('italic')" icon="mdi-format-italic"></v-btn>
        </v-btn-toggle>
        <v-divider vertical class="mx-1"></v-divider>
        <v-btn-toggle v-bind="null" multiple density="compact" variant="text">
          <v-btn @click="editor.chain().focus().toggleBulletList().run()" :active="editor.isActive('bulletList')" icon="mdi-format-list-bulleted"></v-btn>
          <v-btn @click="editor.chain().focus().toggleOrderedList().run()" :active="editor.isActive('orderedList')" icon="mdi-format-list-numbered"></v-btn>
        </v-btn-toggle>
        <v-divider vertical class="mx-1"></v-divider>
        <v-btn-toggle v-bind="null" multiple density="compact" variant="text">
          <v-btn @click="editor.chain().focus().setTextAlign('left').run()" :active="editor.isActive({ textAlign: 'left' })" icon="mdi-format-align-left"></v-btn>
          <v-btn @click="editor.chain().focus().setTextAlign('center').run()" :active="editor.isActive({ textAlign: 'center' })" icon="mdi-format-align-center"></v-btn>
          <v-btn @click="editor.chain().focus().setTextAlign('justify').run()" :active="editor.isActive({ textAlign: 'justify' })" icon="mdi-format-align-justify"></v-btn>
        </v-btn-toggle>
        <v-divider vertical class="mx-1"></v-divider>
        
        <v-btn 
            @click="openLinkDialog" 
            :disabled="editor.state.selection.empty"
            icon="mdi-link-variant-plus"
            density="compact"
            variant="text"
        ></v-btn>
<template v-if="isNovena">
  <v-divider vertical class="mx-1"></v-divider>
  <div class="d-flex align-center ga-2">
    <!-- Кнопки Старт/Финиш -->
    <v-btn-toggle
        :model-value="currentMarker"
        @update:model-value="setMarker"
        density="compact"
        variant="outlined"
    >
      <v-btn value="start" title="Пазначыць як уступ">
        <v-icon>mdi-play-circle-outline</v-icon>
      </v-btn>
      <v-btn value="finish" title="Пазначыць як заканчэнне">
        <v-icon>mdi-flag-checkered</v-icon>
      </v-btn>
    </v-btn-toggle>
    <!-- Кнопки Дней -->
    <div class="d-flex align-center ga-1">
      <span class="text-caption mr-1 text-disabled">Дзень:</span>
      <v-btn-toggle
        :model-value="currentDayMarker"
        @update:model-value="setDayMarker"
        density="compact"
        variant="outlined"
        divided
      >
        <v-btn v-for="day in 9" :key="day" :value="day" size="x-small">{{ day }}</v-btn>
      </v-btn-toggle>
      <v-btn
        icon="mdi-eraser-variant"
        density="compact"
        variant="text"
        title="Сцерці метку дня"
        @click="setDayMarker(null)"
      ></v-btn>
    </div>
  </div>
</template>
      </div>

      <!-- Контент редактора -->
      <div class="editor-content-wrapper">
        <editor-content :editor="editor" />
      </div>
    </div>

    <!-- Диалог для вставки ссылок (без изменений) -->
    <v-dialog v-model="isLinkDialogOpen" max-width="600px" scrollable>
       <v-card>
      <v-card-title class="headline">{{ $t('linkedNotesSelect') }}</v-card-title>
      <v-card-text class="pa-4">
        <v-text-field
          v-model="searchQuery"
          :placeholder="$t('searchPlaceholder')"
          variant="outlined"
          density="compact"
          autofocus
          hide-details
          class="mb-4"
        ></v-text-field>
        <v-list v-if="filteredNotes.length > 0">
          <v-list-item
            v-for="note in filteredNotes"
            :key="note.id"
            :title="getTitle(note)"
            @click="setLink(note.id)"
          >
            <template v-slot:prepend>
              <v-icon>mdi-note-text-outline</v-icon>
            </template>
          </v-list-item>
        </v-list>
        <div v-else class="text-center text-grey py-4">{{ $t('noNotesFound') }}</div>
      </v-card-text>
    </v-card>
    </v-dialog>
  </div>
</template>

<script setup>
import { computed, watch, onBeforeUnmount, ref } from 'vue';
import { useEditor, EditorContent } from '@tiptap/vue-3';
import StarterKit from '@tiptap/starter-kit';
import TextAlign from '@tiptap/extension-text-align';
import Link from '@tiptap/extension-link';
import { Paragraph } from '@tiptap/extension-paragraph';
import { useI18n } from 'vue-i18n';
import { useItems } from '@/composables/useItems';
import { getTitleByLang } from '@/utils/i18n';

const { t } = useI18n();
const props = defineProps({
  modelValue: { type: String, default: '' },
  isNovena: { type: Boolean, default: false }
});
const emit = defineEmits(['update:modelValue']);
const { items, getTitle } = useItems();

// ✅ ИСПРАВЛЕНИЕ 3: Создаем ОДНО кастомное расширение для параграфа,
// которое будет поддерживать и выравнивание, и рубрики, и метки дней новенны.
const CustomParagraph = Paragraph.extend({
  addAttributes() {
    return {
      // Атрибут для выравнивания
      textAlign: {
        default: 'left',
        renderHTML: attributes => ({ style: `text-align: ${attributes.textAlign}` }),
        parseHTML: element => element.style.textAlign || 'left',
      },
      // Атрибут для рубрик (хранится как CSS-класс)
      class: {
        default: null,
        parseHTML: element => element.getAttribute('class'),
        renderHTML: attributes => (attributes.class ? { class: attributes.class } : {}),
      },
      // Атрибут для дней новенны (data-day="...")
      dayMarker: {
        default: null,
        parseHTML: element => element.getAttribute('data-day'),
        renderHTML: attributes => (attributes.dayMarker ? { 'data-day': attributes.dayMarker } : {}),
      },
       marker: {
        default: null,
        parseHTML: element => element.getAttribute('data-marker'),
        renderHTML: attributes => (attributes.marker ? { 'data-marker': attributes.marker } : {}),
      },
    };
  },
  // Добавляем команду для установки метки дня
  addCommands() {
    return {
      setDayMarker: (day) => ({ commands }) => {
        return commands.updateAttributes('paragraph', { dayMarker: day });
      },
      // ✅ НОВАЯ КОМАНДА для установки меток "старт" и "финиш"
      setMarker: (type) => ({ commands }) => {
        return commands.updateAttributes('paragraph', { marker: type, dayMarker: null }); // Сбрасываем дневной маркер
      }
    };
  },
});

const editor = useEditor({
  content: props.modelValue,
  extensions: [
    StarterKit.configure({
      heading: { levels: [2, 3] },
      paragraph: false, // ❗ Важно: отключаем стандартный параграф
      link: false,      // ❗ Важно: отключаем стандартную ссылку
    }),
    Paragraph,
    CustomParagraph,   // ✅ Используем наше кастомное расширение
    TextAlign.configure({
      types: ['heading', 'paragraph'],
    }),
    Link.configure({
      openOnClick: false,
      autolink: true,
    }),
  ],
  onUpdate: () => {
    emit('update:modelValue', editor.value.getHTML());
  },
});

// Вычисляемое свойство для отображения текущего стиля (без изменений)
const currentStyleLabel = computed(() => {
  if (!editor.value) return '';
  if (editor.value.isActive('heading', { level: 2 })) return t('style.h2');
  if (editor.value.isActive('heading', { level: 3 })) return t('style.h3');
  if (editor.value.isActive({ class: 'rubric' })) return t('style.rubric'); // Проверяем по классу
  return t('style.normal');
});

// --- Логика для диалога ссылок (без изменений) ---
const isLinkDialogOpen = ref(false);
const searchQuery = ref('');
const filteredNotes = computed(() => {
  if (!searchQuery.value) {
    return items.value;
  }
  return items.value.filter(note => 
    getTitle(note).toLowerCase().includes(searchQuery.value.toLowerCase())
  );
});

function openLinkDialog() {
  // Команда `isActive('link')` проверяет, стоит ли курсор на ссылке
  // Если да, мы убираем ссылку. Если нет, открываем диалог для её создания.
  if (editor.value.isActive('link')) {
    editor.value.chain().focus().unsetLink().run();
  } else {
    isLinkDialogOpen.value = true;
  }
}
function setLink(noteId) {
  const url = `/item/${noteId}`;
  editor.value.chain().focus().extendMarkRange('link').setLink({ href: url }).run();
  isLinkDialogOpen.value = false;
  searchQuery.value = ''; // Сбрасываем поиск
}


// --- Новая логика для меток дней новенны ---
const currentDayMarker = computed(() => {
  if (!editor.value || !editor.value.isActive('paragraph')) return null;
  return editor.value.getAttributes('paragraph').dayMarker;
});
// ✅ ВЫЧИСЛЯЕМОЕ СВОЙСТВО ДЛЯ МЕТОК "СТАРТ/ФИНИШ"
const currentMarker = computed(() => {
    if (!editor.value || !editor.value.isActive('paragraph')) return null;
    return editor.value.getAttributes('paragraph').marker;
});

function setDayMarker(day) {
  // Если текущая метка совпадает с нажатой, снимаем выделение
  if (currentDayMarker.value === day) {
    editor.value.chain().focus().setDayMarker(null).run();
  } else {
    editor.value.chain().focus().setDayMarker(day).run();
  }
}

// ✅ ФУНКЦИЯ ДЛЯ УСТАНОВКИ МЕТОК "СТАРТ/ФИНИШ"
function setMarker(type) {
    if (currentMarker.value === type) {
        editor.value.chain().focus().setMarker(null).run();
    } else {
        editor.value.chain().focus().setMarker(type).run();
    }
}



watch(() => props.modelValue, (value) => {
  if (editor.value && editor.value.getHTML() !== value) {
    editor.value.commands.setContent(value, false);
  }
});

onBeforeUnmount(() => {
  if (editor.value) {
    editor.value.destroy();
  }
});
</script>

<style scoped>
/* Стили остаются без изменений */
.editor-wrapper {
  border: 1px solid rgba(var(--v-border-color), var(--v-border-opacity));
  border-radius: 4px;
  position: relative; 
  display: flex;
  flex-direction: column;
  max-height: 70vh; 
}
.editor-toolbar {
  position: sticky;
  top: 0;
  z-index: 10;
  background-color: rgb(var(--v-theme-surface));
  border-bottom: 1px solid rgba(var(--v-border-color), var(--v-border-opacity));
  flex-shrink: 0; 
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  padding: 4px 8px;
  gap: 4px;
}
.editor-content-wrapper {
  overflow-y: auto;
  flex-grow: 1;
}
.editor-content-wrapper > :deep(.ProseMirror) {
  padding: 8px 12px;
}
</style>
```

### src/components/FilterSheet.vue
```
<template>
  <v-bottom-sheet v-model="isFilterSheetOpen">
    <v-card class="pa-4">
      <v-card-title>{{ $t('filterByTags') }}</v-card-title>
      <v-card-text>
        <div v-if="allTags.length === 0" class="text-grey pa-2">Нет тегов для выбора</div>
        <v-chip-group v-else v-model="selectedTags" column multiple>
          <v-chip
            v-for="tag in allTags"
            :key="tag"
            :value="tag"
            filter
            variant="outlined"
            class="ma-1"
            size="large"
          >
            {{ tag }}
          </v-chip>
        </v-chip-group>
      </v-card-text>
      <v-card-actions>
        <v-spacer></v-spacer>
        <v-btn color="primary" variant="text" @click="isFilterSheetOpen = false">{{ $t('done') }}</v-btn>
      </v-card-actions>
    </v-card>
  </v-bottom-sheet>
</template>

<script setup>
import { useAppBar } from '@/composables/useAppBar';
import { useFilters } from '@/composables/useFilters';
import { useItems } from '@/composables/useItems';

const { isFilterSheetOpen } = useAppBar();
const { selectedTags } = useFilters();
const { allTags } = useItems();
</script>
```

### src/components/ItemForm.vue
```
<template>
  <v-container>
    <v-form v-if="isFormReady" @submit.prevent="handleSave">
      
      <!-- ✅ ИЗМЕНЕНИЕ: Вкладки теперь контролируют и заголовок, и текст -->
      <v-tabs v-model="currentLangTab" bg-color="primary" class="mb-1">
        <v-tab value="be">Бел</v-tab>
        <v-tab value="ru">Рус</v-tab>
        <v-tab value="la">Lat</v-tab>
        <v-tab value="pl">Pol</v-tab>
      </v-tabs>

      <v-window v-model="currentLangTab">
        <v-window-item value="be">
          <v-text-field v-model="form.titleVersions.be" :label="`${t('title')} (${t('langLabels.be')})`" variant="outlined" class="my-4"></v-text-field>
          <Editor v-model="form.textVersions.be" :is-novena="form.isNovenaPrayer"  />
        </v-window-item>
        <v-window-item value="ru">
          <v-text-field v-model="form.titleVersions.ru" :label="`${t('title')} (${t('langLabels.ru')})`" variant="outlined" class="my-4"></v-text-field>
          <Editor v-model="form.textVersions.ru" :is-novena="form.isNovenaPrayer"  />
        </v-window-item>
        <v-window-item value="la">
          <v-text-field v-model="form.titleVersions.la" :label="`${t('title')} (${t('langLabels.la')})`" variant="outlined" class="my-4"></v-text-field>
          <Editor v-model="form.textVersions.la" :is-novena="form.isNovenaPrayer" />
        </v-window-item>
        <v-window-item value="pl">
           <v-text-field v-model="form.titleVersions.pl" :label="`${t('title')} (${t('langLabels.pl')})`" variant="outlined" class="my-4"></v-text-field>
           <Editor v-model="form.textVersions.pl" :is-novena="form.isNovenaPrayer" />
        </v-window-item>
      </v-window>

      <v-combobox
        v-model="form.tags"
        :items="allTags"
        :label="$t('tags')"
        multiple
        chips
        clearable
        variant="outlined"
        class="mt-4"
      ></v-combobox>

      <!-- Остальная часть формы без изменений... -->
      <v-divider class="my-4"></v-divider>
      <h3 class="text-subtitle-1 mb-2">{{ $t('linkedNotesAdd') }}</h3>
      <div v-if="form.linkedNoteIds && form.linkedNoteIds.length > 0" class="mb-3">
        <v-chip
          v-for="linkedNote in currentlyLinkedNotes"
          :key="linkedNote.id"
          class="mr-2 mb-2"
          closable
          @click:close="removeLink(linkedNote.id)"
        >
          {{ getTitle(linkedNote) }} <!-- Используем хелпер -->
        </v-chip>
      </div>
 <v-btn @click="isLinkDialogOpen = true" prepend-icon="mdi-link-plus">{{ $t('linkedNotesAdd') }}</v-btn>

      <v-divider class="my-4"></v-divider>
      <v-text-field v-model="form.source" :label="$t('source')" variant="outlined" class="mb-4" clearable></v-text-field>

      <v-divider class="my-4"></v-divider>
      <h3 class="text-subtitle-1 mb-2">{{ $t('novenaSettings') }}</h3>
      <v-switch v-model="form.isNovenaPrayer" :label="$t('isNovenaPrayerLabel')" color="primary" inset class="mb-2"></v-switch>
      <v-expand-transition>
        <div v-if="form.isNovenaPrayer">
          <v-text-field v-model="form.recommendedDate" :label="$t('recommendedDateLabel')" :hint="$t('recommendedDateHint')" type="date" variant="outlined" clearable></v-text-field>
        </div>
      </v-expand-transition>

      <v-divider class="my-4"></v-divider>
      <v-switch v-model="form.hidden" :label="$t('hiddenNote')" color="primary" inset class="mb-2"></v-switch>
    </v-form>

    <div v-else class="text-center mt-16">
      <v-progress-circular indeterminate color="primary"></v-progress-circular>
    </div>

    <v-dialog v-model="isLinkDialogOpen" max-width="500px">
      <v-card>
        <v-card-title>{{ $t('linkedNotesSelect') }}</v-card-title>
         <v-text-field v-model="linkSearchQuery" :placeholder="$t('searchPlaceholder')" variant="filled" density="compact" hide-details autofocus class="mx-4 mb-2"></v-text-field>
        <v-list>
          <v-list-item
            v-for="note in availableNotesToLink"
            :key="note.id"
            :title="getTitle(note)" 
            @click="addLink(note.id)"
          ></v-list-item>
        </v-list>
      </v-card>
    </v-dialog>
  </v-container>
</template>

<script setup>
import { ref, watch, onMounted, onUnmounted, computed, inject } from 'vue';
import { useRouter } from 'vue-router';
import { useItems } from '@/composables/useItems';
import Editor from '@/components/Editor.vue';
import { useI18n } from 'vue-i18n';
import { useNotifier } from '@/composables/useNotifier';

const props = defineProps({ id: { type: String, required: false } });
const router = useRouter();
const { t } = useI18n();
const { items, addItem, updateItem, allTags, getTitle } = useItems();
const { showSuccess } = useNotifier();

const registerSaveAction = inject('registerSaveAction');
const isEditMode = computed(() => !!props.id);
const isFormReady = ref(false);
const currentLangTab = ref('be');

// ✅ ИЗМЕНЕНИЕ: Обновляем структуру данных формы
const form = ref({
  titleVersions: { ru: '', be: '', la: '', pl: '' },
  textVersions: { ru: '', be: '', la: '', pl: '' },
  tags: [],
  source: '',
  linkedNoteIds: [],
  isNovenaPrayer: false,
  recommendedDate: null,
  hidden: false
});

const isLinkDialogOpen = ref(false);
const linkSearchQuery = ref('');
const currentlyLinkedNotes = computed(() => form.value.linkedNoteIds?.map(id => items.value.find(item => item.id === id)).filter(Boolean) || []);

const availableNotesToLink = computed(() => {
  return items.value.filter(item => {
    const isNotSelf = item.id !== props.id;
    const isNotLinked = !form.value.linkedNoteIds?.includes(item.id);
    const matchesSearch = linkSearchQuery.value 
      ? getTitle(item).toLowerCase().includes(linkSearchQuery.value.toLowerCase()) // Поиск по отображаемому заголовку
      : true;
    return isNotSelf && isNotLinked && matchesSearch;
  });
});

function addLink(noteId) { 
  if (!form.value.linkedNoteIds) form.value.linkedNoteIds = [];
  form.value.linkedNoteIds.push(noteId); 
  isLinkDialogOpen.value = false; 
  linkSearchQuery.value = '';
}

function removeLink(noteId) { form.value.linkedNoteIds = form.value.linkedNoteIds.filter(id => id !== noteId); }

async function handleSave() {
  // ✅ Проверяем, есть ли хотя бы один заголовок
  const hasAtLeastOneTitle = Object.values(form.value.titleVersions).some(title => title && title.trim() !== '');
  if (!hasAtLeastOneTitle) {
      alert('Пожалуйста, введите название хотя бы для одного языка.'); // Можно заменить на useNotifier
      return;
  }
  
  // Создаем объект для сохранения, только с непустыми полями
  const dataToSave = {
    titleVersions: {},
    textVersions: {},
    tags: form.value.tags || [],
    source: form.value.source || '',
    linkedNoteIds: form.value.linkedNoteIds || [],
    isNovenaPrayer: form.value.isNovenaPrayer || false,
    recommendedDate: form.value.recommendedDate || null,
    hidden: form.value.hidden || false
  };

  for (const lang in form.value.titleVersions) {
    if (form.value.titleVersions[lang]) {
      dataToSave.titleVersions[lang] = form.value.titleVersions[lang];
    }
  }
  for (const lang in form.value.textVersions) {
    if (form.value.textVersions[lang] && form.value.textVersions[lang] !== '<p></p>') {
      dataToSave.textVersions[lang] = form.value.textVersions[lang];
    }
  }

  if (isEditMode.value) {
    await updateItem(props.id, dataToSave);
  } else {
    await addItem(dataToSave);
  }
  showSuccess(t('noteSavedSuccess'));
  router.push({ name: 'ItemsList' });
}

onMounted(() => {
  registerSaveAction(handleSave);
  if (isEditMode.value) {
    let stopWatch;
    stopWatch = watch(items, (newItems) => {
      const itemToEdit = newItems.find(i => i.id === props.id);
      if (itemToEdit) {
        // ✅ ИЗМЕНЕНИЕ: Заполняем новые структуры данных
        form.value = { 
          titleVersions: { 
            be: itemToEdit.titleVersions?.be || '',
            ru: itemToEdit.titleVersions?.ru || '',
            la: itemToEdit.titleVersions?.la || '',
            pl: itemToEdit.titleVersions?.pl || ''
          },
          textVersions: {
            be: itemToEdit.textVersions?.be || '',
            ru: itemToEdit.textVersions?.ru || '',
            la: itemToEdit.textVersions?.la || '',
            pl: itemToEdit.textVersions?.pl || ''
          },
          source: itemToEdit.source || '',
          tags: itemToEdit.tags || [],
          isNovenaPrayer: itemToEdit.isNovenaPrayer || false,
          recommendedDate: itemToEdit.recommendedDate || null,
          linkedNoteIds: itemToEdit.linkedNoteIds || [],
          hidden: itemToEdit.hidden || false
        };
        isFormReady.value = true;
        if(stopWatch) stopWatch();
      }
    }, { immediate: true });
  } else {
    isFormReady.value = true;
  }
});

onUnmounted(() => {
  registerSaveAction(null);
});
</script>
```

### src/components/ItemsList.vue
```
<template>
  <v-container class="items-list-container">
    <div v-if="isLoading">
      <v-skeleton-loader v-for="n in 3" :key="n" type="card" class="mb-4"></v-skeleton-loader>
    </div>
    <div v-else>
      <div v-if="settings.viewMode === 'card'">
        <v-card v-for="item in filteredItems" :key="item.id" class="mb-4" elevation="2">
          <!-- ✅ ИЗМЕНЕНИЕ: Используем хелпер getTitle -->
          <v-card-title class="font-weight-bold d-flex align-center">
            <v-icon v-if="novenaStore.isNovenaActive(item.id)" color="primary" class="mr-2">mdi-calendar-check</v-icon>
            <v-btn :icon="settings.isPinned(item.id) ? 'mdi-pin' : 'mdi-pin-outline'" :color="settings.isPinned(item.id) ? 'primary' : 'grey'" variant="text" size="small" class="mr-2" @click.stop="settings.togglePin(item.id)"></v-btn>
            <span @click="viewItem(item.id)" class="flex-grow-1" style="cursor: pointer;">{{ getTitle(item) }}</span>
          </v-card-title>
          <v-card-text class="pb-0" @click="viewItem(item.id)" style="cursor: pointer;">
            <p class="mb-4 text-medium-emphasis">{{ getPreviewText(item) }}</p>
            <v-chip-group><v-chip v-for="tag in item.tags" :key="tag" size="small" color="primary" variant="tonal">{{ tag }}</v-chip></v-chip-group>
          </v-card-text>
          <v-card-actions v-if="authStore.user">
            <v-icon v-if="item.hidden" color="grey" class="ml-2">mdi-eye-off-outline</v-icon>
            <v-spacer></v-spacer>
            <v-btn color="grey-darken-1" variant="text" @click.stop="navigateToEdit(item.id)">{{ $t('edit') }}</v-btn>
            <v-btn color="error" variant="text" @click.stop="openDeleteDialog(item.id)">{{ $t('delete') }}</v-btn>
          </v-card-actions>
        </v-card>
      </div>
      <v-list v-else-if="settings.viewMode === 'compact'" lines="one" density="compact">
        <v-list-item v-for="item in filteredItems" :key="item.id" @click="viewItem(item.id)">
          <template v-slot:prepend>
            <v-btn :icon="settings.isPinned(item.id) ? 'mdi-pin' : 'mdi-pin-outline'" :color="settings.isPinned(item.id) ? 'primary' : 'grey'" variant="text" size="medium" class="mr-2" @click.stop="settings.togglePin(item.id)"></v-btn>
          </template>
          <!-- ✅ ИЗМЕНЕНИЕ: Используем хелпер getTitle -->
          <v-list-item-title>{{ getTitle(item) }}</v-list-item-title>
          <template v-if="!authStore.user" v-slot:append>
            <v-progress-circular v-if="novenaStore.isNovenaActive(item.id)" :model-value="getNovenaProgress(item.id).percentage" :color="getNovenaProgress(item.id).color" size="24" width="2" class="ml-2"><small>{{ getNovenaProgress(item.id).completed }}</small></v-progress-circular>
            <v-icon v-if="item.hidden" color="grey" class="ml-2">mdi-eye-off-outline</v-icon>
          </template>
          <template v-if="authStore.user" v-slot:append>
            <v-icon v-if="item.hidden" color="grey" class="ml-2">mdi-eye-off-outline</v-icon>
            <v-progress-circular v-if="novenaStore.isNovenaActive(item.id)" :model-value="getNovenaProgress(item.id).percentage" :color="getNovenaProgress(item.id).color" size="24" width="2" class="ml-2"><small>{{ getNovenaProgress(item.id).completed }}</small></v-progress-circular>
            <v-btn icon="mdi-pencil" variant="text" size="small" @click.stop="navigateToEdit(item.id)"></v-btn>
            <v-btn icon="mdi-delete" variant="text" size="small" @click.stop="openDeleteDialog(item.id)"></v-btn>
          </template>
        </v-list-item>
      </v-list>
      <div v-if="!isLoading && filteredItems.length === 0" class="text-center text-grey-darken-1 mt-16">
        <v-icon size="48" class="mb-2">mdi-note-off-outline</v-icon>
        <p>{{ $t('noNotesFound') }}</p>
      </div>
    </div>
    <v-btn v-if="authStore.user" icon location="bottom right" size="large" color="primary" position="fixed" variant="elevated" elevation="8" class="ma-4" @click="router.push({ name: 'ItemAdd' })">
      <v-icon>mdi-plus</v-icon>
    </v-btn>
    <v-dialog v-model="isDeleteDialogOpen" persistent max-width="400px">
      <v-card>
        <v-card-title class="text-h5">{{ $t('confirmDeletion') }}</v-card-title>
        <!-- ✅ ИЗМЕНЕНИЕ: Используем хелпер getTitle -->
        <v-card-text>{{ $t('deleteConfirmationMessage', { title: getTitle(itemToDelete) }) }}</v-card-text>
        <v-card-actions>
          <v-spacer></v-spacer>
          <v-btn variant="text" @click="closeDeleteDialog">{{ $t('cancel') }}</v-btn>
          <v-btn color="error" variant="flat" @click="confirmDeletion">{{ $t('delete') }}</v-btn>
        </v-card-actions>
      </v-card>
    </v-dialog>
  </v-container>
</template>

<script setup>
import { ref, computed } from 'vue';
import { useRouter } from 'vue-router';
import { useItems } from '@/composables/useItems';
import { useFilters } from '@/composables/useFilters';
import { useI18n } from 'vue-i18n';
import { useSettingsStore } from '@/stores/settings';
import { useAuthStore } from '@/stores/auth';
import { useNotifier } from '@/composables/useNotifier';
import { useNovenaStore } from '@/stores/novena';

const router = useRouter();
const { t } = useI18n();
const { items, isLoading, deleteItem, getTitle } = useItems();
const { search, selectedTags } = useFilters();
const settings = useSettingsStore();
const authStore = useAuthStore();
const novenaStore = useNovenaStore();
const { showSuccess } = useNotifier();

const isDeleteDialogOpen = ref(false);
const itemToDeleteId = ref(null);
const itemToDelete = computed(() => itemToDeleteId.value ? items.value.find(item => item.id === itemToDeleteId.value) : null);

function getNovenaProgress(noteId) {
    const data = novenaStore.getNovenaData(noteId);
    if (!data || !data.totalDays) return { percentage: 0, color: 'grey', completed: 0 };
    const todayStr = novenaStore.getTodayDateString();
    const isTodayCompleted = data.completedDates.includes(todayStr);
    return {
        percentage: (data.completedDates.length / data.totalDays) * 100,
        completed: data.completedDates.length,
        color: isTodayCompleted ? 'success' : 'warning'
    };
}

function openDeleteDialog(id) {
  itemToDeleteId.value = id;
  isDeleteDialogOpen.value = true;
}

function closeDeleteDialog() {
  isDeleteDialogOpen.value = false;
  itemToDeleteId.value = null;
}

async function confirmDeletion() {
  if (itemToDeleteId.value) {
    await deleteItem(itemToDeleteId.value);
    showSuccess(t('noteDeletedSuccess'));
  }
  closeDeleteDialog();
}

function getPreviewText(item) {
  if (!item.textVersions) return 'Нет содержимого';
  const htmlContent = item.textVersions.be || item.textVersions.ru || item.textVersions.la || Object.values(item.textVersions).find(v => v) || '';
  if (!htmlContent) return 'Нет содержимого';
  const doc = new DOMParser().parseFromString(htmlContent, 'text/html');
  const text = (doc.body.textContent || "").trim();
  return text.length > 150 ? text.substring(0, 150) + '...' : text;
}

const filteredItems = computed(() => {
  if (isLoading.value) return [];
  const searchLower = search.value.toLowerCase().trim();
  return items.value.filter(item => {
    if (!settings.showHiddenItems && item.hidden) {
      return false;
    }
    const tagMatch = selectedTags.value.length === 0 || (item.tags && selectedTags.value.some(tag => item.tags.includes(tag)));
    if (!tagMatch) return false;
    if (searchLower) {
      // ✅ ИЗМЕНЕНИЕ: Поиск по всем версиям заголовков и текстов
      const titles = Object.values(item.titleVersions || {}).join(' ');
      const texts = Object.values(item.textVersions || {}).join(' ');
      const fullText = (titles + ' ' + texts).toLowerCase();
      return fullText.includes(searchLower);
    }
    return true;
  });
});

function viewItem(id) { router.push({ name: 'ItemView', params: { id } }); }
function navigateToEdit(id) { router.push({ name: 'ItemEdit', params: { id } }); }
</script>
```

### src/components/ItemView.vue
```
<template>
  <v-container class="note-view-container">
    <div v-if="!isLoading && item">
      <!-- Заголовок -->
      <h2 class="text-h5 font-weight-bold mb-4 note-content-area">{{ getTitle(item) }}</h2>

      <!-- Панель Новенны -->
      <v-expansion-panels v-if="novenaStore.isNovenaActive(props.id)" class="my-6">
        <v-expansion-panel>
          <v-expansion-panel-title>
            <div class="d-flex align-center justify-space-between w-100">
              <div class="d-flex align-center">
                <v-icon start color="primary">mdi-calendar-check</v-icon>
                <span class="font-weight-medium">{{ $t('prayerNovena') }}</span>
              </div>
              <div class="d-flex align-center mr-2">
                <v-progress-circular
                  :model-value="novenaProgress.percentage"
                  :color="novenaProgress.color"
                  size="24"
                  width="2"
                  class="mr-2"
                >
                  <small>{{ novenaProgress.completed }}</small>
                </v-progress-circular>
                <span class="text-body-2 text-medium-emphasis">
                  {{ novenaProgress.completed }} / {{ novenaProgress.total }}
                </span>
              </div>
            </div>
          </v-expansion-panel-title>
          <v-expansion-panel-text>
            <NovenaTracker :note-id="props.id" />
          </v-expansion-panel-text>
        </v-expansion-panel>
      </v-expansion-panels>

      <!-- Быстрая навигация по языкам -->
      <v-chip-group v-if="sortedLangs.length > 1" class="mb-6">
        <v-chip
          v-for="lang in sortedLangs"
          :key="`chip-${lang}`"
          @click="scrollToLang(lang)"
        >
          {{ t(`langLabels.${lang}`) }}
        </v-chip>
      </v-chip-group>

      <!-- Текст молитвы -->
      <div 
        v-for="lang in sortedLangs" 
        :key="lang" 
        class="mb-4"
        @click="handleContentClick"
        :ref="el => (langRefs[lang] = el)"
      >
        <div class="lang-label">{{ t('langLabels.' + lang) }}</div>
        <div v-html="processedHtml[lang]" class="note-content-area"></div>
      </div>

      <!-- Связанные заметки -->
      <div v-if="linkedNotes.length > 0" class="mt-8">
        <v-divider class="mb-4"></v-divider>
        <v-list lines="one" density="compact" class="pa-0 bg-transparent linked-notes-list">
          <v-list-item
            v-for="linkedNote in linkedNotes"
            :key="linkedNote.id"
            @click="router.push({ name: 'ItemView', params: { id: linkedNote.id } })"
            class="mb-1"
          >
            <template v-slot:prepend>
              <v-icon color="grey-darken-1">mdi-link-variant</v-icon>
            </template>
          <v-list-item-title class="text-primary font-weight-medium">{{ getTitle(linkedNote) }}</v-list-item-title>
          </v-list-item>
        </v-list>
      </div>

      <!-- Кнопка для старта новенны -->
      <div v-if="item.isNovenaPrayer && !novenaStore.isNovenaActive(props.id)"  class="text-center my-8">
        <v-btn
          @click="isNovenaDialogVisible = true"
          color="primary"
          variant="tonal"
          size="large"
          prepend-icon="mdi-play-circle-outline"
        >
          {{ $t('startNovena') }}
        </v-btn>
      </div>

      <!-- Источник и теги -->
      <div class="mt-6 text-body-2 text-medium-emphasis">
        <div v-if="item.source">
          <v-divider class="my-3"></v-divider>
          <strong>{{ $t('sourceLabel') }}</strong> {{ item.source }}
        </div>
        <div v-if="item.tags && item.tags.length > 0" class="mt-3">
          <strong>{{ $t('tagsLabel') }}</strong> {{ item.tags.join(', ') }}
        </div>
      </div>
    </div>

    <!-- Загрузка и состояние "не найдено" -->
    <div v-else-if="!isLoading && !item" class="text-center mt-16">
        <v-icon size="64" class="mb-4">mdi-file-question-outline</v-icon>
        <h2 class="text-h5 mb-4">{{ $t('noteNotFound') }}</h2>
        <p class="text-medium-emphasis mb-6">{{ $t('noteNotFoundMessage') }}</p>
        <v-btn color="primary" :to="{ name: 'ItemsList' }">{{ $t('backToHome') }}</v-btn>
    </div>
    <div v-else class="text-center text-grey-darken-1 mt-16">
      <v-progress-circular indeterminate color="primary"></v-progress-circular>
    </div>

    <!-- БЛОК С ПЛАВАЮЩИМИ КНОПКАМИ "РИТУАЛА" -->
    <div v-if="isNovenaActiveAndInProgress && !isTodayCompleted" class="fab-container">
      <!-- Кнопка "К началу" -->
      <v-btn
        v-if="hasStartMarker"
        icon="mdi-cross"
        :color="hasScrolledToStart ? 'success' : 'secondary'"
        variant="tonal"
        class="mb-2"
        @click="executeScrollStep('start')"
        title="Да ўступу"
      ></v-btn>

      <!-- Кнопка "К текущему дню" -->
      <v-btn
        v-if="currentNovenaDay"
        icon="mdi-crosshairs-gps"
        :color="hasScrolledToDay ? 'success' : 'secondary'"
        :disabled="!hasScrolledToStart"
        variant="tonal"
        class="mb-2"
        @click="executeScrollStep('day')"
        title="Да сённяшняга дня"
      ></v-btn>

      <!-- Кнопка "К окончанию" -->
      <v-btn
        v-if="hasFinishMarker"
        icon="mdi-flag-checkered"
        :color="hasScrolledToFinish ? 'success' : 'secondary'"
        :disabled="!hasScrolledToDay"
        variant="tonal"
        class="mb-2"
        @click="executeScrollStep('finish')"
        title="Да заканчэння"
      ></v-btn>
      
      <!-- Кнопка "Завершить день" -->
      <v-expand-transition>
          <v-btn
            v-if="showCompleteButton"
            icon="mdi-calendar-check"
            color="primary"
            variant="flat"
            @click="novenaStore.toggleDayCompletion(props.id, novenaStore.getTodayDateString())"
            title="Адзначыць дзень як выкананы"
          ></v-btn>
      </v-expand-transition>
    </div>
    
    <!-- Если день уже завершен, показываем одну кнопку-галочку -->
     <div v-if="isNovenaActiveAndInProgress && isTodayCompleted" class="fab-container">
        <v-btn
            icon="mdi-calendar-check"
            color="success"
            variant="flat"
            title="Дзень выкананы!"
            @click="novenaStore.toggleDayCompletion(props.id, novenaStore.getTodayDateString())"
          ></v-btn>
     </div>


    <!-- Диалог старта новенны -->
    <v-dialog v-model="isNovenaDialogVisible" max-width="400px">
      <v-card>
        <v-card-title>{{ $t('novenaDurationTitle') }}</v-card-title>
        <v-card-text>
          <p class="text-subtitle-1 mb-2">{{ $t('novenaDurationChoice') }}</p>
          <v-chip-group v-model="novenaDays" mandatory class="mb-4">
            <v-chip v-for="d in [7, 9, 33, 54]" :key="d" :value="d" filter>{{ d }} {{ $t('days') }}</v-chip>
          </v-chip-group>
          <p class="text-subtitle-1 mb-2">{{ $t('novenaDurationInput') }}</p>
          <v-text-field
            v-model.number="novenaDays"
            :label="$t('novenaDaysLabel')"
            type="number"
            variant="outlined"
            autofocus
          ></v-text-field>
        </v-card-text>
        <v-card-actions>
          <v-spacer></v-spacer>
          <v-btn text @click="isNovenaDialogVisible = false">{{ $t('cancel') }}</v-btn>
          <v-btn color="primary" variant="flat" @click="handleStartNovena">{{ $t('start') }}</v-btn>
        </v-card-actions>
      </v-card>
    </v-dialog>

  </v-container>
</template>

<script setup>
import { ref, computed, watch, onBeforeUpdate, watchEffect, onUnmounted } from 'vue';
import { useRouter, onBeforeRouteLeave } from 'vue-router';
import { useItems } from '@/composables/useItems';
import { useSettingsStore } from '@/stores/settings';
import { useWakeLock } from '@/composables/useWakeLock';
import { useI18n } from 'vue-i18n';
import { useNovenaStore } from '@/stores/novena';
import NovenaTracker from '@/components/NovenaTracker.vue';

const props = defineProps({ id: { type: String, required: true } });
const router = useRouter();
const { t } = useI18n();
const { items, isLoading, getTitle } = useItems();
const novenaStore = useNovenaStore();
const settings = useSettingsStore();
const { requestWakeLock, releaseWakeLock } = useWakeLock();

const item = computed(() => items.value.find(i => i.id === props.id));
const isNovenaDialogVisible = ref(false);
const novenaDays = ref(9);

// --- Логика для связанных заметок и ссылок в тексте ---
const linkedNotes = computed(() => item.value?.linkedNoteIds?.map(id => items.value.find(note => note.id === id)).filter(Boolean) || []);

function handleContentClick(event) {
  const link = event.target.closest('a');
  if (link && link.pathname.startsWith('/item/')) {
    event.preventDefault(); 
    router.push(link.pathname);
  }
}

// --- Логика для языковых версий ---
const availableVersions = computed(() => {
  if (!item.value?.textVersions) return {};
  return Object.fromEntries(
    Object.entries(item.value.textVersions).filter(([lang, text]) => text && text.trim() !== '<p></p>')
  );
});

const sortedLangs = computed(() => {
  const langs = Object.keys(availableVersions.value);
  return langs.sort((a, b) => (a === 'be' ? -1 : b === 'be' ? 1 : a.localeCompare(b)));
});

const langRefs = ref({});
onBeforeUpdate(() => {
  langRefs.value = {};
});

function scrollToLang(lang) {
  const element = langRefs.value[lang];
  if (element) {
    element.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }
}

// --- Логика Новенн ---
const isNovenaActiveAndInProgress = computed(() => novenaStore.isNovenaActive(props.id));

const currentNovenaDay = computed(() => {
  if (!isNovenaActiveAndInProgress.value) return null;
  const data = novenaStore.getNovenaData(props.id);
  if (!data) return null;
  const startDate = new Date(data.startDate);
  const today = new Date(novenaStore.getTodayDateString());
  const diffTime = Math.abs(today.getTime() - startDate.getTime());
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  const dayNumber = diffDays + 1;
  return dayNumber > 0 && dayNumber <= data.totalDays ? dayNumber : null;
});

// Логика "Ритуала"
const hasScrolledToStart = ref(false);
const hasScrolledToDay = ref(false);
const hasScrolledToFinish = ref(false);
const hasStartMarker = ref(false);
const hasFinishMarker = ref(false);

const isTodayCompleted = computed(() => {
    if (!currentNovenaDay.value) return false;
    const data = novenaStore.getNovenaData(props.id);
    const todayStr = novenaStore.getTodayDateString();
    return data?.completedDates.includes(todayStr) || false;
});

const showCompleteButton = computed(() => {
    return hasScrolledToStart.value && hasScrolledToDay.value && hasScrolledToFinish.value;
});

function executeScrollStep(step) {
    if (step === 'start') {
        scrollToMarker('start');
        hasScrolledToStart.value = true;
    } else if (step === 'day') {
        scrollToCurrentDay();
        hasScrolledToDay.value = true;
    } else if (step === 'finish') {
        scrollToMarker('finish');
        hasScrolledToFinish.value = true;
    }
}

function resetRitualState() {
    hasScrolledToStart.value = false;
    hasScrolledToDay.value = false;
    hasScrolledToFinish.value = false;
}

onBeforeRouteLeave(() => { resetRitualState(); });
onUnmounted(() => { resetRitualState(); });

watchEffect(() => {
  const versions = availableVersions.value;
  if (typeof window === 'undefined' || !item.value || Object.keys(versions).length === 0) {
    hasStartMarker.value = false;
    hasFinishMarker.value = false;
    return;
  }
  const firstLangHtml = versions[sortedLangs.value[0]];
  if (!firstLangHtml) return;

  const parser = new DOMParser();
  const doc = parser.parseFromString(firstLangHtml, 'text/html');
  hasStartMarker.value = !!doc.querySelector('[data-marker="start"]');
  hasFinishMarker.value = !!doc.querySelector('[data-marker="finish"]');
});

const processedHtml = computed(() => {
  const versions = availableVersions.value;
  const dayToHighlight = currentNovenaDay.value;
  if (!dayToHighlight) return versions;

  const processed = {};
  for (const lang in versions) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(versions[lang], 'text/html');
    const element = doc.querySelector(`[data-day="${dayToHighlight}"]`);
    if (element) {
      element.classList.add('current-day-marker');
    }
    processed[lang] = doc.body.innerHTML;
  }
  return processed;
});

const novenaProgress = computed(() => {
    const data = novenaStore.getNovenaData(props.id);
    if (!data || !data.totalDays) return { percentage: 0, color: 'grey', completed: 0, total: 0 };
    const todayStr = novenaStore.getTodayDateString();
    const isTodayCompleted = data.completedDates.includes(todayStr);
    return {
        percentage: (data.completedDates.length / data.totalDays) * 100,
        completed: data.completedDates.length,
        total: data.totalDays,
        color: isTodayCompleted ? 'success' : 'warning'
    };
});

function handleStartNovena() {
  novenaStore.startNovena(props.id, novenaDays.value);
  isNovenaDialogVisible.value = false;
}

function scrollToCurrentDay() {
  const el = document.querySelector('.current-day-marker');
  if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

function scrollToMarker(markerType) {
  const el = document.querySelector(`[data-marker="${markerType}"]`);
  if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

watchEffect(() => {
  if (settings.keepScreenOn) requestWakeLock();
  else releaseWakeLock();
});

</script>

<style scoped>
.note-view-container {
  padding-left: 8px;
  padding-right: 8px;
}
.fab-container {
    position: fixed;
    bottom: 24px;
    right: 24px;
    display: flex;
    flex-direction: column;
    z-index: 5;
}
</style>
```

### src/components/LoginView.vue
```
<template>
  <v-container class="fill-height justify-center">
    <v-card width="100%" max-width="400">
      <v-card-title class="text-center text-h5 py-4">{{ $t('loginTitle') }}</v-card-title>
      <v-card-text>
        <v-form @submit.prevent="handleLogin">
          <v-text-field
            v-model="email"
            :label="$t('email')"
            type="email"
            variant="outlined"
            class="mb-2"
            :rules="[v => !!v || $t('emailRequired')]"
            required
          ></v-text-field>
          <v-text-field
            v-model="password"
            :label="$t('password')"
            type="password"
            variant="outlined"
            :rules="[v => !!v || $t('passwordRequired')]"
            required
          ></v-text-field>
          <v-alert v-if="error" type="error" density="compact" class="mt-4" text>{{ error }}</v-alert>
          <v-btn type="submit" color="primary" block size="large" class="mt-6" :loading="isLoggingIn">{{ $t('login') }}</v-btn>
        </v-form>
      </v-card-text>
    </v-card>
  </v-container>
</template>

<script setup>
import { ref } from 'vue';
import { useAuthStore } from '@/stores/auth';
import { useI18n } from 'vue-i18n';

const { t } = useI18n();
const email = ref('');
const password = ref('');
const error = ref(null);
const isLoggingIn = ref(false);
const authStore = useAuthStore();

const handleLogin = async () => {
  isLoggingIn.value = true;
  error.value = null;
  try {
    await authStore.login(email.value, password.value);
  } catch (e) {
    error.value = t('loginError');
  } finally {
    isLoggingIn.value = false;
  }
};
</script>
```

### src/components/NotificationSnackbar.vue
```
<template>
  <v-snackbar
    v-model="visible"
    :color="color"
    :timeout="timeout"
    location="bottom right"
    variant="elevated"
  >
    {{ message }}
    <template v-slot:actions>
      <v-btn icon="mdi-close" @click="hide"></v-btn>
    </template>
  </v-snackbar>
</template>

<script setup>
import { ref } from 'vue';

const visible = ref(false);
const message = ref('');
const color = ref('success');
const timeout = ref(3000);

// Глобальная функция для показа уведомления
function show(newMessage, newColor = 'success') {
  message.value = newMessage;
  color.value = newColor;
  visible.value = true;
}

function hide() {
  visible.value = false;
}

// Делаем функцию show доступной извне через ref
defineExpose({ show });
</script>
```

### src/components/NovenaBuilder.vue
```
<template>
  <v-card variant="outlined" class="pa-3 mb-3">
    <div class="d-flex align-center ga-3 flex-wrap mb-2">
      <v-text-field
        v-model.number="novena.totalDays"
        type="number" min="1" max="99"
        density="compact"
        :label="$t('novenaDaysLabel')"
        style="max-width: 160px"
      />
      <v-chip-group v-model="selectedDay" class="ml-2" mandatory>
        <v-chip v-for="d in novena.totalDays" :key="`d-${lang}-${d}`" :value="d" size="small" filter>{{ d }}</v-chip>
      </v-chip-group>

      <v-spacer />

      <v-switch
        v-model="novena.useSingleText"
        class="ml-auto"
        inset
        :label="$t('singleTextMode')"
      />
    </div>

    <h4 class="text-subtitle-1 mb-2">{{ $t('opening') }}</h4>
    <Editor v-model="novena.openingTextVersions[lang]" class="mb-4" />

    <template v-if="novena.useSingleText">
      <h4 class="text-subtitle-1 mb-2">{{ $t('day') }} 1…{{ novena.totalDays }}</h4>
      <Editor v-model="novena.singleTextVersions[lang]" class="mb-4" />
    </template>
    <template v-else>
      <h4 class="text-subtitle-1 mb-2">{{ $t('day') }} {{ selectedDay }}</h4>
      <Editor v-model="dayModel" class="mb-4" />
    </template>

    <h4 class="text-subtitle-1 mb-2">{{ $t('closing') }}</h4>
    <Editor v-model="novena.closingTextVersions[lang]" />
  </v-card>
</template>

<script setup>
import { computed, ref, watch } from 'vue';
import Editor from '@/components/Editor.vue';

const props = defineProps({
  modelValue: { type: Object, required: true }, // novena
  lang: { type: String, required: true },
});

const emit = defineEmits(['update:modelValue']);

const novena = computed({
  get: () => props.modelValue,
  set: (v) => emit('update:modelValue', v),
});

const selectedDay = ref(1);

// Дневной текст для текущего дня/языка
const dayModel = computed({
  get() {
    const key = String(selectedDay.value);
    return novena.value.dailyTextVersions?.[key]?.[props.lang] || '';
  },
  set(v) {
    const key = String(selectedDay.value);
    if (!novena.value.dailyTextVersions[key]) novena.value.dailyTextVersions[key] = {};
    novena.value.dailyTextVersions[key][props.lang] = v;
  }
});

// Инициализация структур
watch(() => props.lang, () => {
  if (!novena.value.openingTextVersions) novena.value.openingTextVersions = {};
  if (!novena.value.closingTextVersions) novena.value.closingTextVersions = {};
  if (!novena.value.singleTextVersions) novena.value.singleTextVersions = {};
  if (!novena.value.dailyTextVersions) novena.value.dailyTextVersions = {};
}, { immediate: true });
</script>
```

### src/components/NovenaTracker.vue
```
<!-- src/components/NovenaTracker.vue -->
<template>
  <div class="pa-2">
    <div class="d-flex justify-space-between align-center mb-4">
      <h3 class="text-h6 font-weight-medium">{{ $t('prayerNovena') }}</h3>
      <v-chip color="primary" variant="flat" label>
        <v-icon start>mdi-flag-checkered</v-icon>
        {{ progressText }}
      </v-chip>
    </div>

    <p class="text-body-2 text-medium-emphasis mb-6">
      {{ $t('novenaTrackerHint') }}
    </p>

    <!-- Новый трекер в виде сетки -->
    <div class="grid-container">
      <div
        v-for="day in daySlots"
        :key="day.date"
        :class="['day-cell', day.status, { 'today': day.isToday }]"
        @click="onDayClick(day)"
      >
        <div class="day-number">{{ day.dayNumber }}</div>
        <div class="day-date">{{ formatDate(day.date) }}</div>
        <v-icon v-if="day.status === 'completed'" class="day-icon" size="small">mdi-check-circle</v-icon>
        <v-icon v-if="day.status === 'missed'" class="day-icon" size="small">mdi-alert-circle</v-icon>
      </div>
    </div>
    
    <v-divider class="my-4"></v-divider>
    
    <v-btn 
      @click="novenaStore.endNovena(noteId)"
      variant="text" 
      color="error" 
      block
    >
      {{ $t('endNovena') }}
    </v-btn>

</div>
</template>

<script setup>
import { computed } from 'vue';
import { useNovenaStore } from '@/stores/novena';
import { useI18n } from 'vue-i18n';

const props = defineProps({ noteId: { type: String, required: true } });
const { t, d } = useI18n(); // d - для форматирования дат
const novenaStore = useNovenaStore();
const today = new Date(novenaStore.getTodayDateString());

const novena = computed(() => novenaStore.getNovenaData(props.noteId));

// Главная логика вычисления статуса каждого дня
const daySlots = computed(() => {
  if (!novena.value) return [];
  const slots = [];
  const startDate = new Date(novena.value.startDate);

  for (let i = 0; i < novena.value.totalDays; i++) {
    const currentDate = new Date(startDate);
    currentDate.setDate(startDate.getDate() + i);
    const dateString = currentDate.toISOString().split('T')[0];
    
    let status = 'pending';
    const isCompleted = novena.value.completedDates.includes(dateString);

    if (isCompleted) {
      status = 'completed';
    } else if (currentDate < today) {
      status = 'missed';
    } else if (currentDate > today) {
      status = 'future';
    } else {
      status = 'today';
    }

    slots.push({
      dayNumber: i + 1,
      date: dateString,
      status: status, // 'completed', 'missed', 'today', 'future'
      isToday: dateString === novenaStore.getTodayDateString(),
    });
  }
  return slots;
});

const onDayClick = (day) => {
  // Позволяем кликать только по прошедшим и сегодняшним дням
  if (day.status === 'future') return;
  novenaStore.toggleDayCompletion(props.noteId, day.date);
};

const completedCount = computed(() => novena.value?.completedDates.length || 0);
const progressText = computed(() => `${completedCount.value} / ${novena.value?.totalDays || 0}`);

const formatDate = (dateString) => {
  // Форматируем дату, например "14 авг"
  const date = new Date(dateString);
  return d(date, 'short'); // Используем i18n для форматирования
};
</script>

<style scoped>
.grid-container {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
  gap: 8px;
}
.day-cell {
  border: 1px solid rgba(0,0,0,0.12);
  border-radius: 8px;
  padding: 8px;
  text-align: center;
  position: relative;
  transition: all 0.2s ease-in-out;
  cursor: pointer;
}
.day-cell.future {
  opacity: 0.5;
  cursor: not-allowed;
  background-color: rgba(0,0,0,0.02);
}
.day-cell.today {
  border-width: 2px;
  border-color: rgba(var(--v-theme-primary));
}
.day-cell.completed {
  background-color: rgba(var(--v-theme-primary), 0.1);
  border-color: transparent;
  color: rgb(var(--v-theme-primary));
}
.day-cell.missed {
  border-color: rgba(var(--v-theme-error), 0.5);
}
.day-cell:not(.future):hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}
.day-number {
  font-size: 0.8rem;
  font-weight: 500;
  opacity: 0.7;
}
.day-date {
  font-size: 1rem;
  font-weight: bold;
}
.day-icon {
  position: absolute;
  top: 4px;
  right: 4px;
  opacity: 0.8;
}
</style>
```

### src/components/PrayerRuleView.vue
```
<template>
  <v-container>
    <h2 class="text-h5 font-weight-medium mb-6">{{ $t('myPrayerRule') }}</h2>
    
    <!-- ======================= -->
    <!--    РЕЖИМ РЕДАКТИРОВАНИЯ   -->
    <!-- ======================= -->
    <div v-if="isEditing">
      <div v-if="prayerRule.ruleItems.length === 0" class="text-center mt-16">
        <p class="text-h6">{{ $t('ruleIsEmpty') }}</p>
        <p class="text-medium-emphasis">{{ $t('ruleIsEmptyHint') }}</p>
      </div>
      <div v-else>
        <div v-for="(item, index) in prayerRule.ruleItems" :key="item.itemId" class="prayer-item-container">
          <h3 class="text-h5 mb-3">{{ getItemTitle(item.itemId) }}</h3>
          <div class="d-flex align-center flex-wrap ga-2 mb-4 pa-2 control-panel">
            <div>
              <v-btn icon="mdi-arrow-up" variant="text" size="small" :disabled="index === 0" @click="prayerRule.moveItem(index, index - 1)"></v-btn>
              <v-btn icon="mdi-arrow-down" variant="text" size="small" :disabled="index === prayerRule.ruleItems.length - 1" @click="prayerRule.moveItem(index, index + 1)"></v-btn>
            </div>
            <v-spacer></v-spacer>
            <v-btn-toggle :model-value="item.lang" @update:model-value="prayerRule.updateItemLanguage(index, $event)" variant="outlined" density="compact" mandatory>
              <v-btn value="be" size="x-small">Бел</v-btn>
              <v-btn value="ru" size="x-small">Рус</v-btn>
              <v-btn value="la" size="x-small">Lat</v-btn>
            </v-btn-toggle>
            <v-btn icon="mdi-delete-outline" variant="text" @click="prayerRule.removeItem(index)"></v-btn>
          </div>
          <div v-html="getItemContent(item)" class="note-content-area ProseMirror"></div>
          <v-divider class="my-8"></v-divider>
        </div>
      </div>
      <v-btn icon="mdi-plus" location="bottom right" size="large" color="primary" position="fixed" variant="elevated" elevation="8" class="ma-4" @click="isAddDialogOpen = true"></v-btn>
    </div>

    <!-- ======================= -->
    <!--    РЕЖИМ ПРОСМОТРА      -->
    <!-- ======================= -->
    <div v-else>
      <div v-if="prayerRule.ruleItems.length > 0">
        <div v-for="(item, index) in prayerRule.ruleItems" :key="`view-${item.itemId}`">
          <h3 class="text-h5 mb-3">{{ getItemTitle(item.itemId) }}</h3>
          <div v-html="getItemContent(item)" class="note-content-area ProseMirror"></div>
          <v-divider class="my-8"></v-divider>
        </div>
      </div>
      <div v-else class="text-center mt-16">
        <v-icon size="64" class="mb-4 text-medium-emphasis">mdi-book-remove-outline</v-icon>
        <p class="text-h6">{{ $t('noRuleCreated') }}</p>
        <p class="text-medium-emphasis mb-4">{{ $t('noRuleCreatedHint') }}</p>
        <v-btn size="large" color="primary" @click="setEditing(true)">
          <v-icon start>mdi-pencil</v-icon>
          {{ $t('createRule') }}
        </v-btn>
      </div>
    </div>

    <!-- ✅ ИЗМЕНЕНИЕ: НОВЫЙ ДИАЛОГ ВМЕСТО АВТОКОМПЛИТА -->
    <v-dialog
      v-model="isAddDialogOpen"
      max-width="600px"
      :fullscreen="$vuetify.display.mobile"
      scrollable
    >
      <v-card>
        <v-card-title>{{ $t('addPrayerToRule') }}</v-card-title>
        <v-card-text class="pa-4">
          <v-text-field
            v-model="searchQuery"
            :placeholder="$t('findPrayer')"
            variant="outlined"
            density="compact"
            autofocus
            hide-details
            class="mb-4"
          ></v-text-field>

          <v-list v-if="filteredAvailableItems.length > 0">
            <v-list-item
              v-for="item in filteredAvailableItems"
              :key="item.id"
              :title="getTitle(item)"
              @click="handleAddItem(item)"
            >
              <template v-slot:prepend>
                <v-icon>mdi-note-text-outline</v-icon>
              </template>
            </v-list-item>
          </v-list>
          <div v-else class="text-center text-grey py-4">{{ $t('noNotesFound') }}</div>
        </v-card-text>
        <v-card-actions>
            <v-spacer></v-spacer>
            <v-btn text @click="isAddDialogOpen = false">{{ $t('cancel') }}</v-btn>
        </v-card-actions>
      </v-card>
    </v-dialog>

  </v-container>
</template>

<script setup>
import { ref, computed, onUnmounted , onMounted } from 'vue';
import { usePageMode } from '@/composables/usePageMode';
import { usePrayerRuleStore } from '@/stores/prayerRule';
import { useItems } from '@/composables/useItems';
import { useI18n } from 'vue-i18n';
import { getTitleByLang } from '@/utils/i18n';

const { isEditing, setEditing } = usePageMode();
const prayerRule = usePrayerRuleStore();
const { items } = useItems();
const { t } = useI18n();

const isAddDialogOpen = ref(false);
const searchQuery = ref('');

onUnmounted(() => {
  setEditing(false);
});

// ✅ Хелпер для получения заголовка
const getTitle = (item) => getTitleByLang(item);

const availableItems = computed(() => {
    const ruleItemIds = new Set(prayerRule.ruleItems.map(i => i.itemId));
    return items.value.filter(item => !ruleItemIds.has(item.id));
});

// ✅ Фильтруем доступные элементы на основе поиска
const filteredAvailableItems = computed(() => {
  if (!searchQuery.value) {
    return availableItems.value;
  }
  return availableItems.value.filter(item =>
    getTitle(item).toLowerCase().includes(searchQuery.value.toLowerCase())
  );
});

const getItemTitle = (itemId) => {
    const item = items.value.find(i => i.id === itemId);
    return item ? getTitle(item) : `[${t('noteNotFound')}]`;
};

const getItemContent = (ruleItem) => {
    const fullItem = items.value.find(i => i.id === ruleItem.itemId);
    if (!fullItem) return `[${t('noteNotFound')}]`;
    return fullItem.textVersions[ruleItem.lang] || `[${t('noTextInLang')}]`;
};

// ✅ Обновленная функция добавления
function handleAddItem(item) {
    if (!item) return;
    prayerRule.addItem(item);
    searchQuery.value = ''; // Сбрасываем поиск
    isAddDialogOpen.value = false; // Закрываем диалог
}

onMounted(() => {
  console.log('%c[PrayerRuleView.vue] Компонент успешно смонтирован!', 'background: #28a745; color: white; padding: 2px 5px; border-radius: 3px;');
});
</script>

<style scoped>
.control-panel {
  border: 1px solid rgba(var(--v-border-color), var(--v-border-opacity));
  border-radius: 8px;
  background-color: rgba(var(--v-theme-surface-variant), 0.2);
}
.prayer-item-container:last-of-type .v-divider, 
div[v-else] > div > div:last-of-type .v-divider {
  display: none;
}
</style>
```

### src/components/ReloadPrompt.vue
```
<!-- src/components/ReloadPrompt.vue -->
<template>
  <v-snackbar
    :model-value="needRefresh"
    color="primary"
    variant="elevated"
    :timeout="-1"
    location="bottom right"
    class="mb-4"
  >
    <div class="text-subtitle-1">
      Доступна новая версия приложения!
    </div>

    <template v-slot:actions>
      <v-btn
        variant="text"
        @click="updateServiceWorker()"
      >
        Обновить
      </v-btn>
       <v-btn
        icon="mdi-close"
        variant="text"
        @click="close"
      >
      </v-btn>
    </template>
  </v-snackbar>
</template>

<script setup>
import { useRegisterSW } from 'virtual:pwa-register/vue';

// useRegisterSW - это специальная функция из плагина VitePWA
// needRefresh - станет true, когда новый SW будет готов
// updateServiceWorker - функция, которая активирует новый SW и перезагрузит страницу
const {
  needRefresh,
  updateServiceWorker,
} = useRegisterSW();

const close = () => {
  needRefresh.value = false;
};
</script>
```

### src/components/SettingsView.vue
```
<template>
  <v-container>
    
    <v-list lines="two" subheader>
      <!-- ✅ ВРЕМЕННЫЙ БЛОК ДЛЯ ТЕСТИРОВАНИЯ НОВЕНН
    <v-list-subheader>Инструменты разработчика</v-list-subheader>
    <v-card variant="outlined" class="pa-4 mt-2">
       <h3 class="text-subtitle-1 mb-3">Тестирование предложений новенн</h3>
       <v-text-field
            v-model="simulatedDate"
            label="Симулировать дату"
            type="date"
            variant="outlined"
            density="compact"
            class="mb-2"
        ></v-text-field>
        <v-btn @click="runTestCheck" block>Запустить проверку для даты</v-btn>
    </v-card>
    <v-divider class="my-4"></v-divider> -->
    
      <v-list-subheader>{{ $t('generalSettings') }}</v-list-subheader>
      <v-list-item :title="$t('keepScreenOn')" :subtitle="$t('keepScreenOnHint')">
        <template v-slot:prepend><v-icon>mdi-lightbulb-on-outline</v-icon></template>
        <template v-slot:append>
          <v-switch 
            :model-value="settings.keepScreenOn" 
            @update:model-value="settings.setKeepScreenOn" 
            inset color="primary" hide-details>
          </v-switch>
        </template>
      </v-list-item>

      <v-list-subheader>{{ $t('appearance') }}</v-list-subheader>
      
      <v-list-item :title="$t('fontFamily')" :subtitle="$t('fontFamilyHint')">
        <template v-slot:prepend><v-icon>mdi-format-font</v-icon></template>
      </v-list-item>
      <v-chip-group 
        class="px-4 pb-2"
        :model-value="settings.fontFamily" 
        @update:model-value="settings.setFontFamily"
        mandatory
      >
        <v-chip v-for="font in fontOptions" :key="font.value" :value="font.value" filter variant="outlined" :style="{ fontFamily: font.value }">
          {{ font.title }}
        </v-chip>
      </v-chip-group>

    <v-list-item :title="$t('fontSize')" :subtitle="$t('fontSizeHint')">
        <template v-slot:prepend><v-icon>mdi-format-font-size-increase</v-icon></template>
        <template v-slot:append>
          <div class="d-flex align-center">
            <v-btn icon="mdi-minus" variant="text" size="small" @click="settings.decreaseFontSize" :disabled="settings.fontSizeMultiplier <= 0.8"></v-btn>
            <span class="mx-2 font-weight-bold" style="width: 40px; text-align: center;">{{ Math.round(settings.fontSizeMultiplier * 100) }}%</span>
            <v-btn icon="mdi-plus" variant="text" size="small" @click="settings.increaseFontSize" :disabled="settings.fontSizeMultiplier >= 1.5"></v-btn>
          </div>
        </template>
      </v-list-item>
      
      <!-- ✅ --- БЛОК ПРЕДПРОСМОТРА РАЗМЕРА ШРИФТА --- ✅ -->
      <div class="px-4 pb-2">
        <v-card variant="outlined" class="pa-4">
          <div class="note-content-area">
            <p>{{ $t('previewText') }}</p>
          </div>
        </v-card>
      </div>

      <v-list-item :title="$t('darkTheme')" :subtitle="$t('themeIs', { themeName: $t('themeNames.' + settings.currentTheme) })">
        <template v-slot:prepend><v-icon>mdi-theme-light-dark</v-icon></template>
        <template v-slot:append><v-switch :model-value="settings.currentTheme === 'dark'" @update:model-value="settings.toggleTheme" inset color="primary" hide-details></v-switch></template>
      </v-list-item>
      
      <v-list-item :title="$t('viewMode')" :subtitle="$t('viewModeHint')">
        <template v-slot:prepend><v-icon>mdi-view-dashboard-outline</v-icon></template>
        <template v-slot:append>
          <v-btn-toggle :model-value="settings.viewMode" @update:model-value="settings.toggleViewMode" mandatory variant="outlined" density="compact">
            <v-btn value="card"><v-icon>mdi-view-grid</v-icon></v-btn>
            <v-btn value="compact"><v-icon>mdi-view-list</v-icon></v-btn>
          </v-btn-toggle>
        </template>
      </v-list-item>
    </v-list>
    
    <!-- Остальная часть файла с языком и категориями остается без изменений -->
    <v-divider class="my-4"></v-divider>
    <v-list-subheader>{{ $t('language') }}</v-list-subheader>
    <v-item-group mandatory :model-value="settings.currentLanguage" @update:model-value="settings.setLanguage" class="pa-2">
      <v-item v-for="lang in langOptions" :key="lang.value" :value="lang.value" v-slot="{ isSelected, toggle }">
        <v-btn :variant="isSelected ? 'tonal' : 'outlined'" @click="toggle" class="mr-2 mb-2">{{ lang.title }}</v-btn>
      </v-item>
    </v-item-group>

    <v-divider class="my-4"></v-divider>

     <!-- ✅ НОВЫЙ ПЕРЕКЛЮЧАТЕЛЬ ДЛЯ УВЕДОМЛЕНИЙ -->
      <v-list-item :title="$t('enableNovenaSuggestions')" :subtitle="$t('enableNovenaSuggestionsHint')">
        <template v-slot:prepend>
          <v-icon>mdi-bell-ring-outline</v-icon>
        </template>
        <template v-slot:append>
          <v-switch
            v-model="settings.novenaNotificationsEnabled"
            color="primary"
            inset
            hide-details
          ></v-switch>
        </template>
      </v-list-item>
    <v-divider class="my-4"></v-divider>
      <!-- ✅ --- ВОЗВРАЩАЕМ ЛОГИКУ ДОБАВЛЕНИЯ КАТЕГОРИЙ --- ✅ -->
    <v-list-subheader>{{ $t('menuCategories') }}</v-list-subheader>
    <v-list-item v-for="(cat, index) in settings.menuCategories" :key="index">
      <v-list-item-title>{{ cat.name }}</v-list-item-title>
      <v-list-item-subtitle>Фильтр по тегам: `{{ cat.tags?.join(', ') }}`</v-list-item-subtitle>
      <template v-slot:append>
        <v-btn icon="mdi-delete-outline" variant="text" color="grey" @click="settings.removeCategory(index)"></v-btn>
      </template>
    </v-list-item>
    <div class="pa-2">
       <v-btn color="primary" block @click="isAddCategoryDialogOpen = true">{{ $t('addCategory') }}</v-btn>
    </div>

    <AddCategoryDialog v-model="isAddCategoryDialogOpen" />
  </v-container>
</template>

<script setup>
import { ref } from 'vue';
import { useSettingsStore } from '@/stores/settings';
import { useItems } from '@/composables/useItems';
import AddCategoryDialog from '@/components/AddCategoryDialog.vue';
const settings = useSettingsStore();
const { allTags } = useItems();
const isAddCategoryDialogOpen = ref(false);

const fontOptions = ref([
  { title: 'Системный', value: settings.systemFont },
  { title: 'Yeseva One', value: 'Yeseva One' },
  { title: 'Comfortaa', value: 'Comfortaa' },
  { title: 'Old Standard TT', value: 'Old Standard TT' },
  { title: 'Kurale', value: 'Kurale' },
  { title: 'Pacifico', value: 'Pacifico' },
]);

const langOptions = ref([
  { title: 'Беларуская', value: 'be' },
  { title: 'Русский', value: 'ru' },
]);

import { useNovenaSuggestions } from '@/composables/useNovenaSuggestions'; // ✅ Импортируем
// ... (остальные ref'ы и функции)
const { checkSuggestions } = useNovenaSuggestions(); // ✅ Получаем функцию
const simulatedDate = ref(new Date().toISOString().split('T')[0]); // ✅ Сегодня по умолчанию
function runTestCheck() {
    if (simulatedDate.value) {
        console.log(`--- Запуск теста для даты: ${simulatedDate.value} ---`);
        checkSuggestions(simulatedDate.value);
    }
}
</script>
```

### src/components/TextSettingsSheet.vue
```
<template>
  <v-bottom-sheet v-model="isTextSettingsSheetOpen">
    <v-card class="pa-4" rounded="t-xl">
      <v-list lines="two" subheader>
       

        <!-- Настройка размера -->
<v-list-subheader>{{ $t('fontSize') }}</v-list-subheader>
<v-list-item>
  <div class="d-flex align-center justify-space-between">
    <!-- Кнопка уменьшения -->
    <v-btn 
      variant="tonal" 
      @click="settings.decreaseFontSize" 
      :disabled="settings.fontSizeMultiplier <= 0.8"
      class="font-size-button"
    >
      <span class="text-h6 font-weight-bold">A</span>
      <v-icon right>mdi-minus</v-icon>
    </v-btn>

    <!-- Текущее значение в процентах -->
    <span class="mx-4 font-weight-bold text-h6 text-center" style="min-width: 80px;">
      {{ Math.round(settings.fontSizeMultiplier * 100) }}%
    </span>

    <!-- Кнопка увеличения -->
    <v-btn 
      variant="tonal" 
      @click="settings.increaseFontSize" 
      :disabled="settings.fontSizeMultiplier >= 1.5"
      class="font-size-button"
    >
      <span class="text-h5 font-weight-bold">A</span>
      <v-icon right>mdi-plus</v-icon>
    </v-btn>
  </div>
</v-list-item>
 <!-- Настройка шрифта -->
        <v-list-subheader>{{ $t('fontFamily') }}</v-list-subheader>
        <v-list-item class="px-1">
          <v-chip-group 
            :model-value="settings.fontFamily" 
            @update:model-value="settings.setFontFamily"
            mandatory
          >
            <v-chip v-for="font in fontOptions" :key="font.value" :value="font.value" filter variant="outlined" :style="{ fontFamily: font.value }">
              {{ font.title }}
            </v-chip>
          </v-chip-group>
        </v-list-item>
        <v-list-item :title="$t('keepScreenOn')" :subtitle="$t('keepScreenOnHint')">
          <template v-slot:prepend><v-icon>mdi-lightbulb-on-outline</v-icon></template>
          <template v-slot:append>
            <v-switch 
              :model-value="settings.keepScreenOn" 
              @update:model-value="settings.setKeepScreenOn" 
              inset color="primary" hide-details>
            </v-switch>
          </template>
        </v-list-item>
      </v-list>
      <!-- <v-card-actions>
        <v-spacer></v-spacer>
        <v-btn color="primary" variant="text" @click="isTextSettingsSheetOpen = false">{{ $t('done') }}</v-btn>
      </v-card-actions> -->
    </v-card>
  </v-bottom-sheet>
</template>

<script setup>
import { ref, watch } from 'vue';
import { useSettingsStore } from '@/stores/settings';
import { useAppBar } from '@/composables/useAppBar';

const settings = useSettingsStore();
const { isTextSettingsSheetOpen } = useAppBar();

// // ✅ ЛОГ 4: Отслеживаем, получает ли этот компонент обновление состояния
// watch(isTextSettingsSheetOpen, (newValue, oldValue) => {
//   console.log(`%c[TextSettingsSheet.vue WATCHER] 'isTextSettingsSheetOpen' changed from ${oldValue} to ${newValue}`, 'color: green; font-weight: bold;');
// });

const fontOptions = ref([
  { title: 'Системный', value: "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif" },
  { title: 'Kurale', value: 'Kurale' },
  { title: 'Yeseva One', value: 'Yeseva One' },
  { title: 'Old Standard TT', value: 'Old Standard TT' },
  { title: 'Pacifico', value: 'Pacifico' },
  { title: 'Comfortaa', value: 'Comfortaa' },
]);
</script>
```

### src/composables/useAppBar.js
```
import { ref } from 'vue';

// Глобальные реактивные переменные
const showBackButton = ref(false);
const isDrawerOpen = ref(false);
const isSearchActive = ref(false);
const isFilterSheetOpen = ref(false);
const isTextSettingsSheetOpen = ref(false); // ✅ ДОБАВЛЯЕМ НОВОЕ СОСТОЯНИЕ


console.log('[useAppBar.js] Module loaded. Creating reactive variables.');

export function useAppBar() {
  // Эта функция будет просто переключать видимость кнопки "Назад"
  const setBackButtonVisibility = (visible) => {
    showBackButton.value = visible;
  };

  return { 
    showBackButton,
    setBackButtonVisibility,
    isDrawerOpen, 
    isSearchActive, 
    isFilterSheetOpen, 
    isTextSettingsSheetOpen 
  };
}
```

### src/composables/useFilters.js
```
import { ref } from 'vue';

// Создаем реактивные переменные для наших фильтров
const search = ref('');
const selectedTags = ref([]);

// Экспортируем функцию, которая будет предоставлять доступ
// к этим переменным в любом компоненте
export function useFilters() {
  return {
    search,
    selectedTags,
  };
}
```

### src/composables/useItems.js
```
import { ref, computed } from 'vue';
import { db } from '@/firebase';
import { 
  collection, 
  onSnapshot, 
  addDoc, 
  deleteDoc, 
  updateDoc, 
  doc,
  serverTimestamp,
  query,
  orderBy
} from 'firebase/firestore';
import { useSettingsStore } from '@/stores/settings';
import { getTitleByLang } from '@/utils/i18n'; // ✅ 1. ИМПОРТИРУЕМ

const items = ref([]);
const allTags = ref([]);
const isLoading = ref(true); // ✅ Добавляем состояние загрузки

const itemsCollection = collection(db, 'items');
const itemsQuery = query(itemsCollection, orderBy('createdAt', 'desc'));

onSnapshot(itemsQuery, (snapshot) => {
  items.value = snapshot.docs.map(doc => ({
    id: doc.id,
    ...doc.data()
  }));
  allTags.value = [...new Set(items.value.flatMap(item => item.tags || []))].sort();
  isLoading.value = false; // ✅ Выключаем загрузку, когда данные получены
}, (error) => {
  console.error("Ошибка получения данных из Firestore: ", error);
  isLoading.value = false;
});

export function useItems() {
  const settings = useSettingsStore();

  // ✅ Создаем вычисляемое свойство для сортировки по закрепленным заметкам
  const sortedItems = computed(() => {
    if (!items.value) return [];
    return [...items.value].sort((a, b) => (settings.isPinned(b.id) - settings.isPinned(a.id)));
  });

  // ✅ ПРЕВРАЩАЕМ allTags В COMPUTED СВОЙСТВО
  const allTags = computed(() => {
    // Сначала фильтруем заметки
    const visibleItems = items.value.filter(item => 
      settings.showHiddenItems ? true : !item.hidden
    );
    // Затем собираем теги только из видимых заметок
    const tags = visibleItems.flatMap(item => item.tags || []);
    return [...new Set(tags)].sort();
  });

  const addItem = async (data) => {
    const docRef = await addDoc(itemsCollection, {
      ...data,
      createdAt: serverTimestamp()
    });
    return docRef;
  };

  const deleteItem = async (id) => {
    await deleteDoc(doc(db, 'items', id));
  };

  const updateItem = async (id, data) => {
    const dataToUpdate = { ...data };
    delete dataToUpdate.id; 
    await updateDoc(doc(db, 'items', id), dataToUpdate);
  };

   // ✅ 2. СОЗДАЕМ И ЭКСПОРТИРУЕМ ФУНКЦИЮ
  const getTitle = (item) => {
    if (!item) return '';
    // Можно указать предпочитаемый порядок языков прямо здесь
    return getTitleByLang(item, ['be', 'ru', 'la', 'pl']);
  };

  return {
    items: sortedItems, // ✅ Экспортируем уже отсортированный массив
    allTags,
    isLoading, // ✅ Экспортируем состояние загрузки
    addItem,
    deleteItem,
    updateItem,
    getTitle // ✅ 3. ЭКСПОРТИРУЕМ
  };
}
```

### src/composables/useNotifier.js
```
import { ref } from 'vue';

// Эта переменная будет хранить ссылку на наш компонент уведомлений
export const notifier = ref(null);

export function useNotifier() {
  const showSuccess = (message) => {
    if (notifier.value) {
      notifier.value.show(message, 'success');
    }
  };

  const showError = (message) => {
    if (notifier.value) {
      notifier.value.show(message, 'error');
    }
  };

  return { showSuccess, showError };
}   
```

### src/composables/useNovenaSuggestions.js
```
// src/composables/useNovenaSuggestions.js
import { ref } from 'vue';
import { useItems } from '@/composables/useItems';
import { useNovenaStore } from '@/stores/novena';
import { useRouter } from 'vue-router';


const suggestion = ref(null); // { item, days }

export function useNovenaSuggestions() {
  const { items } = useItems();
  const novenaStore = useNovenaStore();
  const router = useRouter();

   // Загружаем отклоненные предложения из localStorage
  const dismissedSuggestions = ref(JSON.parse(localStorage.getItem('dismissedSuggestions') || '{}'));

  /**
   * Проверяет предложения по новеннам.
   * @param {Date} [simulatedDate=new Date()] - Опциональная дата для симуляции "сегодняшнего дня" при тестировании.
   */
  const checkSuggestions = (simulatedDate) => {
    const today = simulatedDate ? new Date(simulatedDate) : new Date();
    today.setHours(0, 0, 0, 0); // Обнуляем время для точного сравнения дат

    for (const item of items.value) {
      if (item.isNovenaPrayer && item.recommendedDate && !novenaStore.isNovenaActive(item.id)) {
        
        const recommended = new Date(item.recommendedDate);
        const recommendedMonth = recommended.getMonth();
        const recommendedDay = recommended.getDate();

        // Проверяем для текущего и следующего года, чтобы обработать переходы через год
        for (const year of [today.getFullYear(), today.getFullYear() + 1]) {
            const targetDate = new Date(year, recommendedMonth, recommendedDay);

            // Проверяем новенны на 9 дня
            for (const days of [9]) {
                const startDate = new Date(targetDate);
                startDate.setDate(targetDate.getDate() - (days - 1));

                if (startDate.getTime() === today.getTime()) {
                    const suggestionId = `${item.id}-${days}-${year}`;
                    
            // ✅ Проверяем, не было ли это предложение уже отклонено
            if (!dismissedSuggestions.value[suggestionId]) {
                suggestion.value = { item, days, id: suggestionId };
                return;
            }
                }
            }
        }
      }
    }
    console.log('Подходящих предложений по новеннам не найдено.');
  };

    // ✅ НОВАЯ ЛОГИКА для кнопки "Посмотреть"
  const viewSuggestedNovena = () => {
    if (!suggestion.value) return;
    const { item } = suggestion.value;
    // Переходим на страницу молитвы
    router.push({ name: 'ItemView', params: { id: item.id } });
    // Запоминаем, что это предложение было принято (или просмотрено)
    dismissSuggestion(true); 
  };
  
  // ✅ НОВАЯ ЛОГИКА для кнопки "Закрыть"
  const dismissSuggestion = (permanently = false) => {
    if (permanently && suggestion.value) {
        // Добавляем ID предложения в список отклоненных с меткой времени
        dismissedSuggestions.value[suggestion.value.id] = Date.now();
        localStorage.setItem('dismissedSuggestions', JSON.stringify(dismissedSuggestions.value));
    }
    suggestion.value = null;
  };

  return {
    suggestion,
    checkSuggestions,
    dismissSuggestion,
    viewSuggestedNovena, // ✅ Экспортируем новую функцию
  };
}
```

### src/composables/usePageMode.js
```
// src/composables/usePageMode.js
import { ref } from 'vue';

// Объявляем состояние ВНЕ функции, чтобы оно было синглтоном (единым для всех)
const isEditing = ref(false);

// ✅ ИСПРАВЛЕНИЕ ЗДЕСЬ: Добавлено слово 'export'
export function usePageMode() {
  const toggleEditing = () => {
    isEditing.value = !isEditing.value;
  };

  const setEditing = (value) => {
    isEditing.value = value;
  };

  return {
    isEditing,
    toggleEditing,
    setEditing,
  };
}
```

### src/composables/useWakeLock.js
```
// src/composables/useWakeLock.js
import { onUnmounted } from 'vue';

let wakeLock = null;

// Асинхронная функция для запроса блокировки
const requestWakeLock = async () => {
  // Проверяем, поддерживается ли API
  if ('wakeLock' in navigator) {
    try {
      wakeLock = await navigator.wakeLock.request('screen');
      console.log('Screen Wake Lock is active.');
      // Полезно слушать событие, когда система сама отпускает блокировку (например, при сворачивании)
      wakeLock.addEventListener('release', () => {
        console.log('Screen Wake Lock was released by the system.');
        wakeLock = null;
      });
    } catch (err) {
      console.error(`Wake Lock request failed: ${err.name}, ${err.message}`);
    }
  } else {
    console.warn('Wake Lock API is not supported by this browser.');
  }
};

// Асинхронная функция для снятия блокировки
const releaseWakeLock = async () => {
  if (wakeLock !== null) {
    try {
      await wakeLock.release();
      wakeLock = null;
      console.log('Screen Wake Lock released.');
    } catch (err) {
      console.error(`Wake Lock release failed: ${err.name}, ${err.message}`);
    }
  }
};

// Экспортируем основную функцию composable
export function useWakeLock() {
  // При уничтожении компонента, который использует эту логику, мы гарантированно снимаем блокировку
  onUnmounted(() => {
    releaseWakeLock();
  });

  return {
    requestWakeLock,
    releaseWakeLock,
  };
}
```

### src/firebase.js
```
import { initializeApp } from "firebase/app";
// ✅ Возвращаем правильную инициализацию Firestore с поддержкой оффлайн-кэширования
import { initializeFirestore, persistentLocalCache } from "firebase/firestore";

const firebaseConfig = {
  apiKey: "AIzaSyDF2TD4MTcKiBChKRssauvL-nNyT4Am9N0",
  authDomain: "molitwy.firebaseapp.com",
  projectId: "molitwy",
  storageBucket: "molitwy.firebasestorage.app",
  messagingSenderId: "654293224787",
  appId: "1:654293224787:web:5f4fce64abf5ba1b1ea5a6"
};

const app = initializeApp(firebaseConfig);

// ✅ Используем НОВЫЙ метод инициализации с настройками кэша,
// который заменяет и getFirestore(), и enableIndexedDbPersistence()
const db = initializeFirestore(app, {
  localCache: persistentLocalCache({})
});

// Экспортируем db, как и раньше
export { db };
```

### src/i18n.js
```
import { createI18n } from 'vue-i18n';
import ru from './locales/ru.json';
import be from './locales/be.json';

const savedLanguage = localStorage.getItem('language') || 'ru';

const i18n = createI18n({
  legacy: false, 
  locale: savedLanguage,
  fallbackLocale: 'be',
  messages: {
    ru,
    be
  },
  datetimeFormats: {
    'ru': { short: { day: 'numeric', month: 'short' } },
    'be': { short: { day: 'numeric', month: 'short' } }
  }
});

export default i18n;
```

### src/locales/be.json
```
{
  "appTitle": "Мае малітвы",
  "allPrayers": "Усе малітвы",
  "myPrayerRule": "Малітоўнае правіла",

  "searchPlaceholder": "Пошук...",
  "filterByTags": "Фільтр па тэгах",
  "viewMode": "Выгляд спісу",
  "viewModeHint": "Карткі ці кампактны спіс",

  "done": "Гатова",
  "edit": "Рэдагаваць",
  "delete": "Выдаліць",
  "cancel": "Адмена",
  "add": "Дадаць",
  "start": "Пачаць",
  "days": "дзён",

  "pin": "Замацаваць",
  "unpin": "Адмацаваць",
  "loading": "Загрузка...",
  "backToHome": "Вярнуцца на галоўную",

  "title": "Назва",
  "source": "Крыніца",
  "tags": "Тэгі",
  "sourceLabel": "Крыніца:",
  "tagsLabel": "Тэгі:",
  "newNote": "Новая нататка",
  "editing": "Рэдагаванне",
  "noteSavedSuccess": "Нататка паспяхова захавана!",
  "noteDeletedSuccess": "Нататка паспяхова выдалена!",
  "hiddenNote": "Нататка схаваная (не бачная іншым)",
  "noNotesFound": "Нататак не знойдзена",
  "noteNotFound": "Нататка не знойдзена",
  "noteNotFoundMessage": "Магчыма, яна была выдаленая або спасылка няправільная.",
  "confirmDeletion": "Пацвердзіце выдаленне",
  "deleteConfirmationMessage": "Вы ўпэўнены, што хочаце назаўсёды выдаліць нататку \"{title}\"?",

  "style": {
    "normal": "Звычайны",
    "h2": "Загаловак 1",
    "h3": "Загаловак 2",
    "rubric": "Рубрыка"
  },
  "linkedNotesAdd": "Дадаць сувязь",
  "linkedNotesSelect": "Абярыце нататку для сувязі",
  "noTextInLang": "Тэкст на гэтай мове адсутнічае",

  "settings": "Налады",
  "generalSettings": "Агульныя налады",
  "appearance": "Знешні выгляд",
  "darkTheme": "Цёмная тэма",
  "themeIs": "Зараз выкарыстоўваецца {themeName} тэма",
  "themeNames": { "light": "светлая", "dark": "цёмная" },
  "fontSize": "Памер тэксту",
  "fontSizeHint": "Наладзьце памер шрыфту для чытання",
  "fontFamily": "Шрыфт праграмы",
  "fontFamilyHint": "Абярыце асноўны шрыфт для інтэрфейсу",
  "previewText": "Так будзе выглядаць асноўны тэкст вашай нататкі.",
  "keepScreenOn": "Не выключаць экран",
  "keepScreenOnHint": "Карысна падчас малітвы або чытання",
  "language": "Мова",
  "menuCategories": "Катэгорыі ў меню",
  "addCategory": "Дадаць катэгорыю",
  "categoryName": "Назва катэгорыі",
  "categoryTags": "Абярыце або ўвядзіце тэгі",
  "textSettings": "Налады тэксту",

  "admin": "Адмінка",
  "adminText": "Тут будзе панэль адміністратара. Пакуль гэта толькі нарыхтоўка для будучых функцый.",
  "showHiddenNotes": "Паказваць скрытыя нататкі",
  "showHiddenNotesHint": "Уплывае толькі на ваш выгляд спісу",

  "about": "Аб праграме",
  "aboutText": "Гэта праграма створана для асабістага збору малітваў і нататак.",
  "version": "Версія: 1.0.0",
  "devWithLove": "Распрацавана з любоўю.",

  "login": "Уваход",
  "logout": "Выхад",
  "loginTitle": "Уваход для адміністратара",
  "email": "Email",
  "emailRequired": "Email абавязковы",
  "password": "Пароль",
  "passwordRequired": "Пароль абавязковы",
  "loginError": "Няправільны email або пароль.",

  "langLabels": {
    "ru": "Рус",
    "be": "Бел",
    "la": "Lat",
    "pl": "Pl"
  },

  "novenaSettings": "Налады навэнны",
  "isNovenaPrayerLabel": "Гэта малітва-навэнна",
  "recommendedDateLabel": "Дата свята (для прапаноў)",
  "recommendedDateHint": "Пазначце дзень, да якога прывязана навэнна",
  "startNovena": "Пачаць навэнну",
  "endNovena": "Завяршыць навэнну",
  "novenaDurationTitle": "Працягласць навэнны",
  "novenaDaysLabel": "Колькасць дзён",
  "prayerNovena": "Малітоўная навэнна",
  "novenaTrackerHint": "Націскайце на ячэйкі, каб адзначыць выкананыя або прапушчаныя дні.",
  "novenaSuggestionTitle": "Прапанова навэнны",
  "novenaSuggestionText": "Сёння пачынаецца навэнна «{title}» ({days} дзён). Не жадаеце памаліцца?",
  "viewPrayer": "Паглядзець",
  "remindLater": "Пазней",
  "enableNovenaSuggestions": "Прапановы па навэннах",
  "enableNovenaSuggestionsHint": "Паказваць апавяшчэнні, калі падыходзіць час для рэкамендаваных навэнн",

  "addPrayerToRule": "Дадаць малітву ў правіла",
  "findPrayer": "Знайсці малітву...",
  "ruleIsEmpty": "Ваша правіла пакуль пустое.",
  "ruleIsEmptyHint": "Дадайце малітвы, каб скласці сваё правіла.",
  "noRuleCreated": "Малітоўнае правіла яшчэ не створана",
  "noRuleCreatedHint": "Націсніце кнопку ніжэй, каб скласці свой спіс штодзённых малітваў.",
  "createRule": "Стварыць правіла",
  "decline": "Адхіліць",

  "novenaDurationChoice": "Выберы колькасць дзён",
  "novenaDurationInput": "Альбо, напішы"
}
```

### src/locales/ru.json
```
{
  "appTitle": "Мои молитвы",
  "allPrayers": "Все молитвы",
  "myPrayerRule": "Молитвенное правило",

  "searchPlaceholder": "Поиск...",
  "filterByTags": "Фильтр по тегам",
  "viewMode": "Вид списка",
  "viewModeHint": "Карточки или компактный список",

  "done": "Готово",
  "edit": "Редактировать",
  "delete": "Удалить",
  "cancel": "Отмена",
  "add": "Добавить",
  "start": "Начать",
  "days": "дней",

  "pin": "Закрепить",
  "unpin": "Открепить",
  "loading": "Загрузка...",
  "backToHome": "Вернуться на главную",

  "title": "Название",
  "source": "Источник",
  "tags": "Теги",
  "sourceLabel": "Источник:",
  "tagsLabel": "Теги:",
  "newNote": "Новая заметка",
  "editing": "Редактирование",
  "noteSavedSuccess": "Заметка успешно сохранена!",
  "noteDeletedSuccess": "Заметка успешно удалена!",
  "hiddenNote": "Заметка скрыта (не видна другим)",
  "noNotesFound": "Заметок не найдено",
  "noteNotFound": "Заметка не найдена",
  "noteNotFoundMessage": "Возможно, она была удалена или ссылка неверна.",
  "confirmDeletion": "Подтвердите удаление",
  "deleteConfirmationMessage": "Вы уверены, что хотите навсегда удалить заметку \"{title}\"?",

  "style": {
    "normal": "Обычный",
    "h2": "Заголовок 1",
    "h3": "Заголовок 2",
    "rubric": "Рубрика"
  },
  "linkedNotesAdd": "Добавить связь",
  "linkedNotesSelect": "Выберите заметку для связи",
  "noTextInLang": "Текст на этом языке отсутствует",

  "settings": "Настройки",
  "generalSettings": "Общие настройки",
  "appearance": "Внешний вид",
  "darkTheme": "Тёмная тема",
  "themeIs": "Сейчас используется {themeName} тема",
  "themeNames": { "light": "светлая", "dark": "тёмная" },
  "fontSize": "Размер текста",
  "fontSizeHint": "Настройте размер шрифта для чтения",
  "fontFamily": "Шрифт приложения",
  "fontFamilyHint": "Выберите основной шрифт для интерфейса",
  "previewText": "Так будет выглядеть основной текст вашей заметки.",
  "keepScreenOn": "Не выключать экран",
  "keepScreenOnHint": "Полезно во время молитвы или чтения",
  "language": "Язык",
  "menuCategories": "Категории в меню",
  "addCategory": "Добавить категорию",
  "categoryName": "Название категории",
  "categoryTags": "Выберите или введите теги",
  "textSettings": "Настройки текста",

  "admin": "Админка",
  "adminText": "Здесь будет панель администратора. Пока это лишь заготовка для будущих функций.",
  "showHiddenNotes": "Показывать скрытые заметки",
  "showHiddenNotesHint": "Влияет только на ваш вид списка",

  "about": "О приложении",
  "aboutText": "Это приложение создано для личного сбора молитв и заметок.",
  "version": "Версия: 1.0.0",
  "devWithLove": "Разработано с любовью.",

  "login": "Вход",
  "logout": "Выход",
  "loginTitle": "Вход для администратора",
  "email": "Email",
  "emailRequired": "Email обязателен",
  "password": "Пароль",
  "passwordRequired": "Пароль обязателен",
  "loginError": "Неверный email или пароль.",

  "langLabels": {
    "ru": "Рус",
    "be": "Бел",
    "la": "Lat",
    "pl": "Pl"
  },

  "novenaSettings": "Настройки новенны",
  "isNovenaPrayerLabel": "Это молитва-новенна",
  "recommendedDateLabel": "Дата праздника (для предложений)",
  "recommendedDateHint": "Укажите день, к которому привязана новенна",
  "startNovena": "Начать новенну",
  "endNovena": "Завершить новенну",
  "novenaDurationTitle": "Длительность новенны",
  "novenaDaysLabel": "Количество дней",
  "prayerNovena": "Молитвенная новенна",
  "novenaTrackerHint": "Нажимайте на ячейки, чтобы отметить выполненные или пропущенные дни.",
  "novenaSuggestionTitle": "Предложение новенны",
  "novenaSuggestionText": "Сегодня начинается новенна «{title}» ({days} дней). Не хотите помолиться?",
  "viewPrayer": "Посмотреть",
  "remindLater": "Позже",
  "enableNovenaSuggestions": "Предложения по новеннам",
  "enableNovenaSuggestionsHint": "Показывать уведомления, когда подходит время для рекомендованных новенн",

  "addPrayerToRule": "Добавить молитву в правило",
  "findPrayer": "Найти молитву...",
  "ruleIsEmpty": "Ваше правило пока пусто.",
  "ruleIsEmptyHint": "Добавьте молитвы, чтобы составить свое правило.",
  "noRuleCreated": "Молитвенное правило еще не создано",
  "noRuleCreatedHint": "Нажмите кнопку ниже, чтобы составить свой список ежедневных молитв.",
  "createRule": "Создать правило",
  "decline": "Отклонить",

  "novenaDurationChoice": "Выбери колличество дней",
  "novenaDurationInput": "Или, введи"
}
```

### src/main.js
```
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'
import router from './router'
import vuetify from './plugins/vuetify'
import i18n from './i18n'
import './firebase' // Импортируем для инициализации Firebase
import '@mdi/font/css/materialdesignicons.css'
import './styles/main.css'

const app = createApp(App)

app.use(createPinia())
app.use(router)
app.use(vuetify)
app.use(i18n)

app.mount('#app')
```

### src/plugins/vuetify.js
```

import 'vuetify/styles';
import { createVuetify } from 'vuetify';
import * as components from 'vuetify/components';
import * as directives from 'vuetify/directives';

export default createVuetify({
  components,
  directives,
});


```

### src/router/index.js
```
import { createRouter, createWebHistory } from 'vue-router';
import { getAuth, onAuthStateChanged } from 'firebase/auth';
import { useAuthStore } from '@/stores/auth';

const getCurrentUser = () => {
  return new Promise((resolve, reject) => {
    const removeListener = onAuthStateChanged(
      getAuth(),
      (user) => {
        removeListener();
        resolve(user);
      },
      reject
    );
  });
};

const routes = [
  { path: '/login', name: 'Login', component: () => import('@/components/LoginView.vue') },
  { path: '/', name: 'ItemsList', component: () => import('@/components/ItemsList.vue') },
  { path: '/item/:id', name: 'ItemView', component: () => import('@/components/ItemView.vue'), props: true },
  { path: '/settings', name: 'Settings', component: () => import('@/components/SettingsView.vue') },
  { path: '/edit/:id', name: 'ItemEdit', component: () => import('@/components/ItemForm.vue'), props: true, meta: { requiresAuth: true } },
  { path: '/add', name: 'ItemAdd', component: () => import('@/components/ItemForm.vue'), meta: { requiresAuth: true } },
  { path: '/admin', name: 'Admin', component: () => import('@/components/AdminView.vue'), meta: { requiresAuth: true } },
  { path: '/about', name: 'About', component: () => import('@/components/AboutView.vue') },
    { path: '/rule', name: 'PrayerRule', component: () => import('@/components/PrayerRuleView.vue') },
];

const router = createRouter({
  history: createWebHistory(),
  routes,
  // ✅ ДОБАВЬТЕ ЭТОТ БЛОК
  scrollBehavior(to, from, savedPosition) {
    // Если есть сохраненная позиция (при навигации назад/вперед),
    // то возвращаемся к ней.
    if (savedPosition) {
      return savedPosition;
    }
    // В противном случае (при новой навигации) всегда
    // прокручиваем в начало страницы.
    else {
      return { top: 0, left: 0 };
    }
  },
});

// --- ✅ НАВИГАЦИОННЫЙ СТРАЖ С ПОДРОБНЫМ ЛОГИРОВАНИЕМ ---
router.beforeEach(async (to, from, next) => {

  const authStore = useAuthStore();
  const requiresAuth = to.matched.some(record => record.meta.requiresAuth);
  const userIsLoggedIn = !!authStore.user;
  if (requiresAuth && !userIsLoggedIn) {
    next({ name: 'Login' });
  } else {
    next();
  }
});

export default router;
```

### src/stores/auth.js
```
import { defineStore } from 'pinia';
import { ref } from 'vue';
import { getAuth, signInWithEmailAndPassword, signOut, onAuthStateChanged } from 'firebase/auth';
import router from '@/router';

export const useAuthStore = defineStore('auth', () => {
  const user = ref(null);
  const auth = getAuth();
  const loading = ref(true);

  // --- ✅ ЛОГИРОВАНИЕ ВНУТРИ ХРАНИЛИЩА ---
  console.log('[AUTH STORE] Initializing...');

  const unsubscribe = onAuthStateChanged(auth, (firebaseUser) => {
    // Этот лог покажет нам КАЖДЫЙ раз, когда Firebase меняет статус
    console.log(`%c[FIREBASE AUTH STATE CHANGED] User status updated.`, 'color: #881391; font-weight: bold;', firebaseUser ? `Logged in as ${firebaseUser.email}` : 'Logged out.');
    user.value = firebaseUser;
    loading.value = false;
  });

  const login = async (email, password) => {
    try {
      await signInWithEmailAndPassword(auth, email, password);
      // После успешного входа, роутер сам перенаправит куда нужно
      // Добавляем небольшой таймаут, чтобы дать роутеру время на обработку нового состояния
      setTimeout(() => {
        const redirectPath = router.currentRoute.value.query.redirect || '/';
        router.push(redirectPath);
      }, 100);

    } catch (error) {
      console.error("Login Error:", error.code);
      throw error;
    }
  };

  const logout = async () => {
    await signOut(auth);
    // При выходе всегда перенаправляем на страницу входа
    router.push({ name: 'Login' });
  };
  
  const unbind = () => {
    unsubscribe();
  };

  return { user, login, logout, unbind, loading };
});
```

### src/stores/novena.js
```
import { defineStore } from 'pinia';
import { ref, watch, computed } from 'vue';
import { useSettingsStore } from './settings'; // ✅ Импортируем хранилище настроек

// Функция для получения даты в формате YYYY-MM-DD
const getTodayDateString = () => new Date().toISOString().split('T')[0];

export const useNovenaStore = defineStore('novenas', () => {
  // Структура: { noteId: { startDate, totalDays, completedDates: ['YYYY-MM-DD'] } }
  const novenas = ref(JSON.parse(localStorage.getItem('prayerNovenas') || '{}'));
const settings = useSettingsStore(); // ✅ Инициализируем settingsStore
  // Автосохранение в localStorage при любых изменениях
  watch(novenas, (newNovenas) => {
    localStorage.setItem('prayerNovenas', JSON.stringify(newNovenas));
  }, { deep: true });

  // --- ACTIONS (Действия) ---

  function startNovena(noteId, totalDays) {
    if (!noteId || !totalDays) return;
    novenas.value[noteId] = {
      startDate: getTodayDateString(),
      totalDays: Number(totalDays),
      completedDates: [],
    };
    // ✅ АВТОМАТИЧЕСКИ ЗАКРЕПЛЯЕМ МОЛИТВУ
    // Проверяем, не закреплена ли она уже, чтобы не открепить случайно
    if (!settings.isPinned(noteId)) {
        settings.togglePin(noteId);
    }
  }

  function endNovena(noteId) {
    delete novenas.value[noteId];
  }

  function toggleDayCompletion(noteId, dateString) {
    const novena = novenas.value[noteId];
    if (!novena) return;
    
    const completedIndex = novena.completedDates.indexOf(dateString);
    if (completedIndex > -1) {
      // Если день уже отмечен, снимаем отметку
      novena.completedDates.splice(completedIndex, 1);
    } else {
      // Иначе, добавляем
      novena.completedDates.push(dateString);
      novena.completedDates.sort(); // Держим массив отсортированным
    }
  }

  // --- GETTERS (Вычисляемые свойства) ---

  const isNovenaActive = computed(() => (noteId) => {
    return !!novenas.value[noteId];
  });
  
  const getNovenaData = computed(() => (noteId) => {
      return novenas.value[noteId];
  });


  return {
    novenas,
    startNovena,
    endNovena,
    toggleDayCompletion,
    isNovenaActive,
    getNovenaData,
    getTodayDateString,
  };
});
```

### src/stores/prayerRule.js
```
// src/stores/prayerRuleStore.js
import { defineStore } from 'pinia';
import { ref, watch } from 'vue';

export const usePrayerRuleStore = defineStore('prayerRule', () => {
  const ruleItems = ref(JSON.parse(localStorage.getItem('prayerRule') || '[]'));

  watch(ruleItems, (newRule) => {
    localStorage.setItem('prayerRule', JSON.stringify(newRule));
  }, { deep: true });

  function addItem(item) {
    if (!item || ruleItems.value.some(rule => rule.itemId === item.id)) return;
    ruleItems.value.push({
      itemId: item.id,
      lang: 'be', 
    });
  }

  function removeItem(index) {
    ruleItems.value.splice(index, 1);
  }

  function updateItemLanguage(index, newLang) {
    if (ruleItems.value[index]) {
      ruleItems.value[index].lang = newLang;
    }
  }
  
  // ✅ ВОЗВРАЩАЕМ ЭТУ ФУНКЦИЮ ДЛЯ РАБОТЫ КНОПОК
  function moveItem(fromIndex, toIndex) {
    if (fromIndex < 0 || fromIndex >= ruleItems.value.length || toIndex < 0 || toIndex >= ruleItems.value.length) {
      return;
    }
    // Вырезаем элемент и вставляем его в новую позицию
    const [item] = ruleItems.value.splice(fromIndex, 1);
    ruleItems.value.splice(toIndex, 0, item);
  }

  return { 
    ruleItems, 
    addItem,
    removeItem,
    updateItemLanguage,
    moveItem // ✅ Убедитесь, что она экспортируется
  };
});
```

### src/stores/settings.js
```
import { defineStore } from 'pinia';
import { ref, watch } from 'vue';
import { useTheme } from 'vuetify';
import { useI18n } from 'vue-i18n';

const defaultCategories = [
  { name: 'Марыйныя', tags: ['Марыя'] },
  { name: 'Літаніі', tags: ['Літанія'] }
];

const systemFont = "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'";

export const useSettingsStore = defineStore('settings', () => {
  const theme = useTheme();
  const { locale } = useI18n();

  // --- Состояния (Refs) ---
  const currentTheme = ref(localStorage.getItem('theme') || 'light');
  const keepScreenOn = ref(JSON.parse(localStorage.getItem('keepScreenOn') || 'false'));
  const fontFamily = ref(localStorage.getItem('fontFamily') || systemFont);
  const fontSizeMultiplier = ref(parseFloat(localStorage.getItem('fontSizeMultiplier')) || 1.2);
  const viewMode = ref(localStorage.getItem('viewMode') || 'compact');
  const currentLanguage = ref(localStorage.getItem('language') || 'be');
  const pinnedIds = ref(JSON.parse(localStorage.getItem('pinnedIds') || '[]'));
  const menuCategories = ref(JSON.parse(localStorage.getItem('menuCategories') || JSON.stringify(defaultCategories)));
  const showHiddenItems = ref(JSON.parse(localStorage.getItem('showHiddenItems') || 'false'));

    // ✅ НОВАЯ НАСТРОЙКА
const novenaNotificationsEnabled = ref(JSON.parse(localStorage.getItem('prayer-novena-notifications') || 'true'));
  // --- Слежение за изменениями и сохранение в localStorage (Watchers) ---
  // ✅ ИСПРАВЛЕНО: Предупреждение Vuetify. Теперь используется актуальный метод.
  watch(currentTheme, (newTheme) => {
    theme.change(newTheme)
    localStorage.setItem('theme', newTheme);
  }, { immediate: true });
  watch(fontFamily, (v) => { document.documentElement.style.setProperty('--app-font-family', v); localStorage.setItem('fontFamily', v); }, { immediate: true });
  watch(fontSizeMultiplier, (newMultiplier) => { 
    document.documentElement.style.setProperty('--font-size-multiplier', newMultiplier);
    localStorage.setItem('fontSizeMultiplier', String(newMultiplier));
  }, { immediate: true }); // immediate: true - применяет стиль при первой же загрузке

  watch(keepScreenOn, (v) => localStorage.setItem('keepScreenOn', v));
  watch(viewMode, (v) => localStorage.setItem('viewMode', v));
  watch(currentLanguage, (v) => { locale.value = v; localStorage.setItem('language', v); }, { immediate: true });
  watch(pinnedIds, (v) => localStorage.setItem('pinnedIds', JSON.stringify(v)), { deep: true });
  watch(menuCategories, (v) => localStorage.setItem('menuCategories', JSON.stringify(v)), { deep: true });
  watch(showHiddenItems, (v) => localStorage.setItem('showHiddenItems', v));

  // --- Функции для изменения состояний (Actions) ---
  function toggleTheme() { currentTheme.value = currentTheme.value === 'light' ? 'dark' : 'light'; }
  function setFontFamily(font) { fontFamily.value = font; }
  function increaseFontSize() { if (fontSizeMultiplier.value < 1.5) fontSizeMultiplier.value = parseFloat((fontSizeMultiplier.value + 0.1).toFixed(2)); }
  function decreaseFontSize() { if (fontSizeMultiplier.value > 0.8) fontSizeMultiplier.value = parseFloat((fontSizeMultiplier.value - 0.1).toFixed(2)); }
  function toggleViewMode() { viewMode.value = viewMode.value === 'card' ? 'compact' : 'card'; }
  function setLanguage(lang) { currentLanguage.value = lang; }
  
  // ✅ --- ИСПРАВЛЕНО: Возвращаем удаленные функции для закрепления ---
  function isPinned(noteId) { return pinnedIds.value.includes(noteId); }
  function togglePin(noteId) {
    const index = pinnedIds.value.indexOf(noteId);
    if (index > -1) pinnedIds.value.splice(index, 1);
    else pinnedIds.value.unshift(noteId);
  }

  function addCategory(cat) { if (cat && cat.name && cat.tags?.length > 0) menuCategories.value.push(cat); }
  function removeCategory(index) { menuCategories.value.splice(index, 1); }
  function toggleShowHiddenItems() { showHiddenItems.value = !showHiddenItems.value; }

  // Управление WakeLock API
  let wakeLock = null;
  const setKeepScreenOn = async (value) => {
    keepScreenOn.value = value;
    if (value && 'wakeLock' in navigator) {
      try { wakeLock = await navigator.wakeLock.request('screen'); } catch (err) { console.error(`${err.name}, ${err.message}`); }
    } else {
      if (wakeLock !== null) wakeLock.release().then(() => { wakeLock = null; });
    }
  };
  watch(keepScreenOn, setKeepScreenOn, { immediate: true });

  return {
    currentTheme, toggleTheme,
    keepScreenOn, setKeepScreenOn,
    fontFamily, setFontFamily, systemFont,
    fontSizeMultiplier, increaseFontSize, decreaseFontSize,
    currentLanguage, setLanguage,
    viewMode, toggleViewMode,
    pinnedIds, isPinned, togglePin, // ✅ Экспортируем isPinned
    menuCategories, addCategory, removeCategory,
    showHiddenItems, toggleShowHiddenItems, novenaNotificationsEnabled
  };
});
```

### src/style.css
```

```

### src/styles/main.css
```
/* ==========================================================================
   ✅ ИСПРАВЛЕНИЯ ДЛЯ МОБИЛЬНЫХ УСТРОЙСТВ И SAMSUNG
   ========================================================================== */

/* 1. Запрещаем "усиление шрифтов" в Chrome и Samsung Internet */
html {
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
  text-size-adjust: 100%;
}

/* 2. Гарантируем, что основной контейнер приложения никогда не будет шире экрана */
#app {
  width: 100%;
  overflow-x: hidden;
}

/* 3. Заставляем текст молитв правильно переноситься */
/* Это самое важное правило для решения проблемы */
.note-content-area {
  word-wrap: break-word;     /* Для старых браузеров */
  overflow-wrap: break-word; /* Стандартный способ */
  word-break: break-word;    /* Более "агрессивный" перенос, если нужно */

  /* Дополнительно предотвращаем горизонтальную прокрутку внутри блока */
  overflow-x: hidden;
}

/* ==========================================================================
   Глобальные переменные
   ========================================================================== */
:root {
  --font-size-multiplier: 1.0;
  /* Системный шрифт по умолчанию, если ничего не выбрано */
  --app-font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
}

/* ==========================================================================
   ТОЧЕЧНОЕ ПРИМЕНЕНИЕ ШРИФТОВ
   ========================================================================== */

/* 1. Применяем шрифт к тексту внутри заметок и к редактору */
.note-content-area, .ProseMirror {
  font-family: var(--app-font-family);
}

/* 2. Применяем шрифт к заголовку приложения в AppBar и в боковом меню */
.app-title {
  font-family: var(--app-font-family) !important; /* !important нужен здесь, чтобы перебить Vuetify */
}

/* ==========================================================================
   Стили для контента заметок (где работает изменение размера)
   ========================================================================== */
.note-content-area h2 { font-size: calc(1.5rem * var(--font-size-multiplier)); }
.note-content-area h3 { font-size: calc(1.15rem * var(--font-size-multiplier)); }
.note-content-area p, .note-content-area div { font-size: calc(1rem * var(--font-size-multiplier)); }
.note-content-area p {
  margin-bottom: 1em !important; 
}
/* Убираем лишний отступ у последнего элемента, чтобы не было "висячего" пробела */
.note-content-area > *:last-child {
    margin-bottom: 0 !important;
}
/* ... (остальные стили для .note-content-area и другие правила остаются как были) ... */
.note-content-area .rubric { color: rgb(var(--v-theme-error)); font-style: italic; text-align: center; }
.note-content-area > *:first-child { margin-top: 0 !important; }

.wrappable-toolbar-title { white-space: normal !important; line-height: 1.25 !important; font-size: 1.15rem !important; }
.lang-label { display: inline-block; padding: 2px 10px; background-color: rgba(var(--v-theme-on-surface), 0.08); color: rgba(var(--v-theme-on-surface), 0.7); border-radius: 12px; font-size: 0.8rem; font-weight: 700; margin-bottom: 12px; text-transform: uppercase; }
.ProseMirror { min-height: 200px; padding: 8px 12px; outline: none; }


.ProseMirror p { 
  margin-bottom: 0; 
}
.ProseMirror p.rubric { 
  margin: 1em 0; 
}
.ProseMirror-focused { 
  border-color: transparent; 
  box-shadow: none; 
}


/* Улучшенные стили для связанных заметок */
.linked-notes-list .v-list-item__prepend .v-icon { 
  margin-inline-end: 12px; 
}


/* Стили для компактного списка */
.v-list.v-list--density-compact .v-list-item {
  min-height: 52px;
  border-bottom: 1px solid rgba(var(--v-border-color), 0.12);
}

/* Общее правило для переноса длинных заголовков в карточках */
.v-card-title span.flex-grow-1 {
  white-space: normal;
  word-break: break-word;
  line-height: 1.4;
}
/* 
  Правило для заголовков в режиме "Компактный список".
  Используем !important, чтобы гарантированно переопределить стили Vuetify.
*/
.v-list-item-title {
  white-space: normal !important;
  word-break: break-word !important;
  line-height: 1.4 !important;
}


/* ==========================================================================
   СТИЛИ ДЛЯ НОВЕНН
   ========================================================================== */
.note-content-area .current-day-marker {
  background-color: rgba(var(--v-theme-primary), 0.08);
  border-left: 3px solid rgba(var(--v-theme-primary), 0.7);
  /* Плавный переход для красоты */
  transition: all 0.3s ease-in-out;
  /* Отступы, чтобы текст не прилипал к рамке */
  padding-left: 12px;
  /* Компенсация отступа, чтобы текст визуально остался на месте */
  margin-left: -15px; 
}

/* Добавляем немного больше отступа сверху и снизу для выделенного блока */
.note-content-area .current-day-marker {
    margin-top: 1em;
    margin-bottom: 1em;
    padding-top: 4px;
    padding-bottom: 4px;
}
/* Общие стили для всех меток в редакторе */
.ProseMirror p[data-day]::before,
.ProseMirror p[data-marker]::before {
  font-family: "Material Design Icons"; /* ✅ Используем шрифт иконок */
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 1.2em; /* Размер иконки */
  font-weight: normal;
  color: rgb(var(--v-theme-primary));
  background-color: rgba(var(--v-theme-primary), 0.1);
  margin-right: 12px;
  vertical-align: middle;
  width: 26px;
  height: 26px;
  line-height: 26px;
  text-align: center;
  border-radius: 50%;
  border: 1px solid rgba(var(--v-theme-primary), 0.2);
}
/* Иконка для метки дня */
.ProseMirror p[data-day]::before {
  content: attr(data-day); /* Оставляем номер для дней */
  font-family: var(--app-font-family); /* Возвращаем обычный шрифт */
  font-size: 0.8em;
  font-weight: bold;
}
/* Иконка для метки "старт" */
.ProseMirror p[data-marker="start"]::before {
  content: "\F040A"; /* Код иконки mdi-play-circle-outline */
}
/* Иконка для метки "финиш" */
.ProseMirror p[data-marker="finish"]::before {
  content: "\F023C"; /* Код иконки mdi-flag-checkered */
}
/* ==========================================================================
   СТИЛИ ДЛЯ ПЛАВАЮЩИХ КНОПОК
   ========================================================================== */
.fab-container {
    position: fixed;
    bottom: 24px;
    right: 24px;
    display: flex;
    flex-direction: column;
    z-index: 5; /* Чуть ниже стандартных диалогов */
}

/* ==========================================================================
   Адаптивные стили для мобильных устройств
   ========================================================================== */

@media (max-width: 600px) {
  .v-main .v-container.items-list-container {
    padding: 8px 0 0 0 !important;
  }
  .items-list-container .v-card {
    margin-left: 8px; 
    margin-right: 8px; 
    margin-top: 12px; 
    border-radius: 8px !important;
  }
  .items-list-container .v-card:first-child { 
    margin-top: 0; 
  }
  .items-list-container .v-list { 
    padding: 0; 
  }
}


```

### src/utils/i18n.js
```
// src/utils/i18n.js

/**
 * Получает заголовок для элемента в соответствии с предпочитаемым языком и резервными вариантами.
 *
 * @param {object} item - Объект заметки, содержащий titleVersions.
 * @param {string[]} langOrder - Массив кодов языков в порядке предпочтения (напр., ['be', 'ru', 'la', 'pl']).
 * @returns {string} - Наиболее подходящий заголовок или пустая строка.
 */
export function getTitleByLang(item, langOrder = ['be', 'ru', 'la', 'pl']) {
  if (!item || !item.titleVersions) {
    return '';
  }

  // 1. Ищем заголовок в соответствии с порядком языков
  for (const lang of langOrder) {
    if (item.titleVersions[lang]) {
      return item.titleVersions[lang];
    }
  }

  // 2. Если ничего не найдено, берем первый доступный заголовок из объекта
  const availableLangs = Object.keys(item.titleVersions).filter(k => item.titleVersions[k]);
  if (availableLangs.length > 0) {
    return item.titleVersions[availableLangs[0]];
  }
  
  // 3. Если заголовков нет вообще
  return '';
}
```
